
/Users/rickierha/Projects/Particle/ee1301/fazbear/target/2.3.1/photon/fazbear.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00008174  080a001c  080a001c  0001001c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       00000004  40024000  080a8190  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000090  20000000  080a8194  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00001b30  20000090  20000090  00040090  2**3
                  ALLOC
  6 .module_info_suffix 00000028  080a8224  080a8224  00038224  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  080a824c  080a824c  0003824c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   00206ba0  00000000  00000000  00038250  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00020b4e  00000000  00000000  0023edf0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0002df45  00000000  00000000  0025f93e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00003068  00000000  00000000  0028d883  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00007af0  00000000  00000000  002908eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000356ad  00000000  00000000  002983db  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0004c8d1  00000000  00000000  002cda88  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000c1873  00000000  00000000  0031a359  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00008338  00000000  00000000  003dbbcc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <link_dynalib_end+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <link_dynalib_end+0x2c>)
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}
    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <link_dynalib_end+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f007 fc1b 	bl	80a7868 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <link_dynalib_end+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <link_dynalib_end+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f007 fc3d 	bl	80a78b8 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <link_dynalib_end+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000000 	.word	0x20000000
 80a0048:	080a8194 	.word	0x080a8194
 80a004c:	20000090 	.word	0x20000090
 80a0050:	20000090 	.word	0x20000090
 80a0054:	20001bbd 	.word	0x20001bbd
 80a0058:	20001bbd 	.word	0x20001bbd

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f006 fadb 	bl	80a6618 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0062:	2500      	movs	r5, #0
 80a0064:	4e05      	ldr	r6, [pc, #20]	; (80a007c <module_user_init+0x20>)
 80a0066:	4c06      	ldr	r4, [pc, #24]	; (80a0080 <module_user_init+0x24>)
 80a0068:	1ba4      	subs	r4, r4, r6
 80a006a:	08a4      	lsrs	r4, r4, #2
 80a006c:	42a5      	cmp	r5, r4
 80a006e:	d100      	bne.n	80a0072 <module_user_init+0x16>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a0070:	bd70      	pop	{r4, r5, r6, pc}
        link_constructors_location[ctor_num]();
 80a0072:	f856 3b04 	ldr.w	r3, [r6], #4
 80a0076:	4798      	blx	r3
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f7      	b.n	80a006c <module_user_init+0x10>
 80a007c:	080a8168 	.word	0x080a8168
 80a0080:	080a818c 	.word	0x080a818c

080a0084 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0084:	f000 bf22 	b.w	80a0ecc <setup>

080a0088 <module_user_loop>:
}

void module_user_loop() {
 80a0088:	b508      	push	{r3, lr}
    loop();
 80a008a:	f000 fcc9 	bl	80a0a20 <loop>
    _post_loop();
}
 80a008e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _post_loop();
 80a0092:	f006 ba79 	b.w	80a6588 <_post_loop>

080a0096 <_Znwj>:
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size)
{
	return malloc(size);
 80a0096:	f004 ba81 	b.w	80a459c <malloc>

080a009a <_Znaj>:
 80a009a:	f004 ba7f 	b.w	80a459c <malloc>

080a009e <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a009e:	f004 ba85 	b.w	80a45ac <free>
	...

080a00a4 <__cxa_pure_virtual>:
    return (char*)"";
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00a4:	2100      	movs	r1, #0
 80a00a6:	200c      	movs	r0, #12
void __cxa_pure_virtual() {
 80a00a8:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00aa:	4a02      	ldr	r2, [pc, #8]	; (80a00b4 <__cxa_pure_virtual+0x10>)
 80a00ac:	f004 f9ba 	bl	80a4424 <panic_>
  while (1);
 80a00b0:	e7fe      	b.n	80a00b0 <__cxa_pure_virtual+0xc>
 80a00b2:	bf00      	nop
 80a00b4:	080a4131 	.word	0x080a4131

080a00b8 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00b8:	7800      	ldrb	r0, [r0, #0]
 80a00ba:	fab0 f080 	clz	r0, r0
 80a00be:	0940      	lsrs	r0, r0, #5
 80a00c0:	4770      	bx	lr

080a00c2 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00c2:	2301      	movs	r3, #1
 80a00c4:	7003      	strb	r3, [r0, #0]
 80a00c6:	4770      	bx	lr

080a00c8 <DAC_DeInit>:
 80a00c8:	b508      	push	{r3, lr}
 80a00ca:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 80a00ce:	2101      	movs	r1, #1
 80a00d0:	f000 f93e 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a00d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a00d8:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 80a00dc:	2100      	movs	r1, #0
 80a00de:	f000 b937 	b.w	80a0350 <RCC_APB1PeriphResetCmd>
	...

080a00e4 <DAC_Init>:
 80a00e4:	f640 73fe 	movw	r3, #4094	; 0xffe
 80a00e8:	b530      	push	{r4, r5, lr}
 80a00ea:	4d08      	ldr	r5, [pc, #32]	; (80a010c <DAC_Init+0x28>)
 80a00ec:	4083      	lsls	r3, r0
 80a00ee:	682a      	ldr	r2, [r5, #0]
 80a00f0:	ea22 0403 	bic.w	r4, r2, r3
 80a00f4:	e891 000c 	ldmia.w	r1, {r2, r3}
 80a00f8:	431a      	orrs	r2, r3
 80a00fa:	688b      	ldr	r3, [r1, #8]
 80a00fc:	4313      	orrs	r3, r2
 80a00fe:	68ca      	ldr	r2, [r1, #12]
 80a0100:	4313      	orrs	r3, r2
 80a0102:	4083      	lsls	r3, r0
 80a0104:	4323      	orrs	r3, r4
 80a0106:	602b      	str	r3, [r5, #0]
 80a0108:	bd30      	pop	{r4, r5, pc}
 80a010a:	bf00      	nop
 80a010c:	40007400 	.word	0x40007400

080a0110 <DAC_StructInit>:
 80a0110:	2300      	movs	r3, #0
 80a0112:	6003      	str	r3, [r0, #0]
 80a0114:	6043      	str	r3, [r0, #4]
 80a0116:	6083      	str	r3, [r0, #8]
 80a0118:	60c3      	str	r3, [r0, #12]
 80a011a:	4770      	bx	lr

080a011c <DAC_Cmd>:
 80a011c:	4a06      	ldr	r2, [pc, #24]	; (80a0138 <DAC_Cmd+0x1c>)
 80a011e:	2301      	movs	r3, #1
 80a0120:	b119      	cbz	r1, 80a012a <DAC_Cmd+0xe>
 80a0122:	6811      	ldr	r1, [r2, #0]
 80a0124:	4083      	lsls	r3, r0
 80a0126:	430b      	orrs	r3, r1
 80a0128:	e003      	b.n	80a0132 <DAC_Cmd+0x16>
 80a012a:	6811      	ldr	r1, [r2, #0]
 80a012c:	4083      	lsls	r3, r0
 80a012e:	ea21 0303 	bic.w	r3, r1, r3
 80a0132:	6013      	str	r3, [r2, #0]
 80a0134:	4770      	bx	lr
 80a0136:	bf00      	nop
 80a0138:	40007400 	.word	0x40007400

080a013c <DAC_DMACmd>:
 80a013c:	4a06      	ldr	r2, [pc, #24]	; (80a0158 <DAC_DMACmd+0x1c>)
 80a013e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80a0142:	b119      	cbz	r1, 80a014c <DAC_DMACmd+0x10>
 80a0144:	6811      	ldr	r1, [r2, #0]
 80a0146:	4083      	lsls	r3, r0
 80a0148:	430b      	orrs	r3, r1
 80a014a:	e003      	b.n	80a0154 <DAC_DMACmd+0x18>
 80a014c:	6811      	ldr	r1, [r2, #0]
 80a014e:	4083      	lsls	r3, r0
 80a0150:	ea21 0303 	bic.w	r3, r1, r3
 80a0154:	6013      	str	r3, [r2, #0]
 80a0156:	4770      	bx	lr
 80a0158:	40007400 	.word	0x40007400

080a015c <DMA_DeInit>:
 80a015c:	6803      	ldr	r3, [r0, #0]
 80a015e:	f023 0301 	bic.w	r3, r3, #1
 80a0162:	6003      	str	r3, [r0, #0]
 80a0164:	2300      	movs	r3, #0
 80a0166:	6003      	str	r3, [r0, #0]
 80a0168:	6043      	str	r3, [r0, #4]
 80a016a:	6083      	str	r3, [r0, #8]
 80a016c:	60c3      	str	r3, [r0, #12]
 80a016e:	6103      	str	r3, [r0, #16]
 80a0170:	2321      	movs	r3, #33	; 0x21
 80a0172:	6143      	str	r3, [r0, #20]
 80a0174:	4b29      	ldr	r3, [pc, #164]	; (80a021c <DMA_DeInit+0xc0>)
 80a0176:	4298      	cmp	r0, r3
 80a0178:	d017      	beq.n	80a01aa <DMA_DeInit+0x4e>
 80a017a:	4b29      	ldr	r3, [pc, #164]	; (80a0220 <DMA_DeInit+0xc4>)
 80a017c:	4298      	cmp	r0, r3
 80a017e:	d01b      	beq.n	80a01b8 <DMA_DeInit+0x5c>
 80a0180:	4b28      	ldr	r3, [pc, #160]	; (80a0224 <DMA_DeInit+0xc8>)
 80a0182:	4298      	cmp	r0, r3
 80a0184:	d020      	beq.n	80a01c8 <DMA_DeInit+0x6c>
 80a0186:	4b28      	ldr	r3, [pc, #160]	; (80a0228 <DMA_DeInit+0xcc>)
 80a0188:	4298      	cmp	r0, r3
 80a018a:	d025      	beq.n	80a01d8 <DMA_DeInit+0x7c>
 80a018c:	4b27      	ldr	r3, [pc, #156]	; (80a022c <DMA_DeInit+0xd0>)
 80a018e:	4298      	cmp	r0, r3
 80a0190:	d02a      	beq.n	80a01e8 <DMA_DeInit+0x8c>
 80a0192:	4b27      	ldr	r3, [pc, #156]	; (80a0230 <DMA_DeInit+0xd4>)
 80a0194:	4298      	cmp	r0, r3
 80a0196:	d02e      	beq.n	80a01f6 <DMA_DeInit+0x9a>
 80a0198:	4b26      	ldr	r3, [pc, #152]	; (80a0234 <DMA_DeInit+0xd8>)
 80a019a:	4298      	cmp	r0, r3
 80a019c:	d032      	beq.n	80a0204 <DMA_DeInit+0xa8>
 80a019e:	4b26      	ldr	r3, [pc, #152]	; (80a0238 <DMA_DeInit+0xdc>)
 80a01a0:	4298      	cmp	r0, r3
 80a01a2:	d036      	beq.n	80a0212 <DMA_DeInit+0xb6>
 80a01a4:	4b25      	ldr	r3, [pc, #148]	; (80a023c <DMA_DeInit+0xe0>)
 80a01a6:	4298      	cmp	r0, r3
 80a01a8:	d103      	bne.n	80a01b2 <DMA_DeInit+0x56>
 80a01aa:	223d      	movs	r2, #61	; 0x3d
 80a01ac:	f843 2c08 	str.w	r2, [r3, #-8]
 80a01b0:	4770      	bx	lr
 80a01b2:	4b23      	ldr	r3, [pc, #140]	; (80a0240 <DMA_DeInit+0xe4>)
 80a01b4:	4298      	cmp	r0, r3
 80a01b6:	d104      	bne.n	80a01c2 <DMA_DeInit+0x66>
 80a01b8:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 80a01bc:	f843 2c20 	str.w	r2, [r3, #-32]
 80a01c0:	4770      	bx	lr
 80a01c2:	4b20      	ldr	r3, [pc, #128]	; (80a0244 <DMA_DeInit+0xe8>)
 80a01c4:	4298      	cmp	r0, r3
 80a01c6:	d104      	bne.n	80a01d2 <DMA_DeInit+0x76>
 80a01c8:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 80a01cc:	f843 2c38 	str.w	r2, [r3, #-56]
 80a01d0:	4770      	bx	lr
 80a01d2:	4b1d      	ldr	r3, [pc, #116]	; (80a0248 <DMA_DeInit+0xec>)
 80a01d4:	4298      	cmp	r0, r3
 80a01d6:	d104      	bne.n	80a01e2 <DMA_DeInit+0x86>
 80a01d8:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 80a01dc:	f843 2c50 	str.w	r2, [r3, #-80]
 80a01e0:	4770      	bx	lr
 80a01e2:	4b1a      	ldr	r3, [pc, #104]	; (80a024c <DMA_DeInit+0xf0>)
 80a01e4:	4298      	cmp	r0, r3
 80a01e6:	d103      	bne.n	80a01f0 <DMA_DeInit+0x94>
 80a01e8:	4a19      	ldr	r2, [pc, #100]	; (80a0250 <DMA_DeInit+0xf4>)
 80a01ea:	f843 2c64 	str.w	r2, [r3, #-100]
 80a01ee:	4770      	bx	lr
 80a01f0:	4b18      	ldr	r3, [pc, #96]	; (80a0254 <DMA_DeInit+0xf8>)
 80a01f2:	4298      	cmp	r0, r3
 80a01f4:	d103      	bne.n	80a01fe <DMA_DeInit+0xa2>
 80a01f6:	4a18      	ldr	r2, [pc, #96]	; (80a0258 <DMA_DeInit+0xfc>)
 80a01f8:	f843 2c7c 	str.w	r2, [r3, #-124]
 80a01fc:	4770      	bx	lr
 80a01fe:	4b17      	ldr	r3, [pc, #92]	; (80a025c <DMA_DeInit+0x100>)
 80a0200:	4298      	cmp	r0, r3
 80a0202:	d103      	bne.n	80a020c <DMA_DeInit+0xb0>
 80a0204:	4a16      	ldr	r2, [pc, #88]	; (80a0260 <DMA_DeInit+0x104>)
 80a0206:	f843 2c94 	str.w	r2, [r3, #-148]
 80a020a:	4770      	bx	lr
 80a020c:	4b15      	ldr	r3, [pc, #84]	; (80a0264 <DMA_DeInit+0x108>)
 80a020e:	4298      	cmp	r0, r3
 80a0210:	d103      	bne.n	80a021a <DMA_DeInit+0xbe>
 80a0212:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 80a0216:	f843 2cac 	str.w	r2, [r3, #-172]
 80a021a:	4770      	bx	lr
 80a021c:	40026010 	.word	0x40026010
 80a0220:	40026028 	.word	0x40026028
 80a0224:	40026040 	.word	0x40026040
 80a0228:	40026058 	.word	0x40026058
 80a022c:	40026070 	.word	0x40026070
 80a0230:	40026088 	.word	0x40026088
 80a0234:	400260a0 	.word	0x400260a0
 80a0238:	400260b8 	.word	0x400260b8
 80a023c:	40026410 	.word	0x40026410
 80a0240:	40026428 	.word	0x40026428
 80a0244:	40026440 	.word	0x40026440
 80a0248:	40026458 	.word	0x40026458
 80a024c:	40026470 	.word	0x40026470
 80a0250:	2000003d 	.word	0x2000003d
 80a0254:	40026488 	.word	0x40026488
 80a0258:	20000f40 	.word	0x20000f40
 80a025c:	400264a0 	.word	0x400264a0
 80a0260:	203d0000 	.word	0x203d0000
 80a0264:	400264b8 	.word	0x400264b8

080a0268 <DMA_Init>:
 80a0268:	6802      	ldr	r2, [r0, #0]
 80a026a:	4b13      	ldr	r3, [pc, #76]	; (80a02b8 <DMA_Init+0x50>)
 80a026c:	b510      	push	{r4, lr}
 80a026e:	4013      	ands	r3, r2
 80a0270:	68cc      	ldr	r4, [r1, #12]
 80a0272:	680a      	ldr	r2, [r1, #0]
 80a0274:	4314      	orrs	r4, r2
 80a0276:	694a      	ldr	r2, [r1, #20]
 80a0278:	4314      	orrs	r4, r2
 80a027a:	698a      	ldr	r2, [r1, #24]
 80a027c:	4314      	orrs	r4, r2
 80a027e:	69ca      	ldr	r2, [r1, #28]
 80a0280:	4314      	orrs	r4, r2
 80a0282:	6a0a      	ldr	r2, [r1, #32]
 80a0284:	4314      	orrs	r4, r2
 80a0286:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 80a0288:	4314      	orrs	r4, r2
 80a028a:	6a8a      	ldr	r2, [r1, #40]	; 0x28
 80a028c:	4314      	orrs	r4, r2
 80a028e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 80a0290:	4314      	orrs	r4, r2
 80a0292:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 80a0294:	4322      	orrs	r2, r4
 80a0296:	4313      	orrs	r3, r2
 80a0298:	6003      	str	r3, [r0, #0]
 80a029a:	6943      	ldr	r3, [r0, #20]
 80a029c:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 80a029e:	f023 0207 	bic.w	r2, r3, #7
 80a02a2:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80a02a4:	4323      	orrs	r3, r4
 80a02a6:	4313      	orrs	r3, r2
 80a02a8:	6143      	str	r3, [r0, #20]
 80a02aa:	690b      	ldr	r3, [r1, #16]
 80a02ac:	6043      	str	r3, [r0, #4]
 80a02ae:	684b      	ldr	r3, [r1, #4]
 80a02b0:	6083      	str	r3, [r0, #8]
 80a02b2:	688b      	ldr	r3, [r1, #8]
 80a02b4:	60c3      	str	r3, [r0, #12]
 80a02b6:	bd10      	pop	{r4, pc}
 80a02b8:	f01c803f 	.word	0xf01c803f

080a02bc <DMA_StructInit>:
 80a02bc:	2300      	movs	r3, #0
 80a02be:	6003      	str	r3, [r0, #0]
 80a02c0:	6043      	str	r3, [r0, #4]
 80a02c2:	6083      	str	r3, [r0, #8]
 80a02c4:	60c3      	str	r3, [r0, #12]
 80a02c6:	6103      	str	r3, [r0, #16]
 80a02c8:	6143      	str	r3, [r0, #20]
 80a02ca:	6183      	str	r3, [r0, #24]
 80a02cc:	61c3      	str	r3, [r0, #28]
 80a02ce:	6203      	str	r3, [r0, #32]
 80a02d0:	6243      	str	r3, [r0, #36]	; 0x24
 80a02d2:	6283      	str	r3, [r0, #40]	; 0x28
 80a02d4:	62c3      	str	r3, [r0, #44]	; 0x2c
 80a02d6:	6303      	str	r3, [r0, #48]	; 0x30
 80a02d8:	6343      	str	r3, [r0, #52]	; 0x34
 80a02da:	6383      	str	r3, [r0, #56]	; 0x38
 80a02dc:	4770      	bx	lr

080a02de <DMA_Cmd>:
 80a02de:	6803      	ldr	r3, [r0, #0]
 80a02e0:	b111      	cbz	r1, 80a02e8 <DMA_Cmd+0xa>
 80a02e2:	f043 0301 	orr.w	r3, r3, #1
 80a02e6:	e001      	b.n	80a02ec <DMA_Cmd+0xe>
 80a02e8:	f023 0301 	bic.w	r3, r3, #1
 80a02ec:	6003      	str	r3, [r0, #0]
 80a02ee:	4770      	bx	lr

080a02f0 <DMA_DoubleBufferModeConfig>:
 80a02f0:	6803      	ldr	r3, [r0, #0]
 80a02f2:	b112      	cbz	r2, 80a02fa <DMA_DoubleBufferModeConfig+0xa>
 80a02f4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80a02f8:	e001      	b.n	80a02fe <DMA_DoubleBufferModeConfig+0xe>
 80a02fa:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80a02fe:	6003      	str	r3, [r0, #0]
 80a0300:	6101      	str	r1, [r0, #16]
 80a0302:	4770      	bx	lr

080a0304 <DMA_DoubleBufferModeCmd>:
 80a0304:	6803      	ldr	r3, [r0, #0]
 80a0306:	b111      	cbz	r1, 80a030e <DMA_DoubleBufferModeCmd+0xa>
 80a0308:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80a030c:	e001      	b.n	80a0312 <DMA_DoubleBufferModeCmd+0xe>
 80a030e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80a0312:	6003      	str	r3, [r0, #0]
 80a0314:	4770      	bx	lr

080a0316 <DMA_GetCurrentMemoryTarget>:
 80a0316:	6800      	ldr	r0, [r0, #0]
 80a0318:	f3c0 40c0 	ubfx	r0, r0, #19, #1
 80a031c:	4770      	bx	lr
	...

080a0320 <RCC_AHB1PeriphClockCmd>:
 80a0320:	4b04      	ldr	r3, [pc, #16]	; (80a0334 <RCC_AHB1PeriphClockCmd+0x14>)
 80a0322:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80a0324:	b109      	cbz	r1, 80a032a <RCC_AHB1PeriphClockCmd+0xa>
 80a0326:	4310      	orrs	r0, r2
 80a0328:	e001      	b.n	80a032e <RCC_AHB1PeriphClockCmd+0xe>
 80a032a:	ea22 0000 	bic.w	r0, r2, r0
 80a032e:	6318      	str	r0, [r3, #48]	; 0x30
 80a0330:	4770      	bx	lr
 80a0332:	bf00      	nop
 80a0334:	40023800 	.word	0x40023800

080a0338 <RCC_APB1PeriphClockCmd>:
 80a0338:	4b04      	ldr	r3, [pc, #16]	; (80a034c <RCC_APB1PeriphClockCmd+0x14>)
 80a033a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80a033c:	b109      	cbz	r1, 80a0342 <RCC_APB1PeriphClockCmd+0xa>
 80a033e:	4310      	orrs	r0, r2
 80a0340:	e001      	b.n	80a0346 <RCC_APB1PeriphClockCmd+0xe>
 80a0342:	ea22 0000 	bic.w	r0, r2, r0
 80a0346:	6418      	str	r0, [r3, #64]	; 0x40
 80a0348:	4770      	bx	lr
 80a034a:	bf00      	nop
 80a034c:	40023800 	.word	0x40023800

080a0350 <RCC_APB1PeriphResetCmd>:
 80a0350:	4b04      	ldr	r3, [pc, #16]	; (80a0364 <RCC_APB1PeriphResetCmd+0x14>)
 80a0352:	6a1a      	ldr	r2, [r3, #32]
 80a0354:	b109      	cbz	r1, 80a035a <RCC_APB1PeriphResetCmd+0xa>
 80a0356:	4310      	orrs	r0, r2
 80a0358:	e001      	b.n	80a035e <RCC_APB1PeriphResetCmd+0xe>
 80a035a:	ea22 0000 	bic.w	r0, r2, r0
 80a035e:	6218      	str	r0, [r3, #32]
 80a0360:	4770      	bx	lr
 80a0362:	bf00      	nop
 80a0364:	40023800 	.word	0x40023800

080a0368 <RCC_APB2PeriphResetCmd>:
 80a0368:	4b04      	ldr	r3, [pc, #16]	; (80a037c <RCC_APB2PeriphResetCmd+0x14>)
 80a036a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80a036c:	b109      	cbz	r1, 80a0372 <RCC_APB2PeriphResetCmd+0xa>
 80a036e:	4310      	orrs	r0, r2
 80a0370:	e001      	b.n	80a0376 <RCC_APB2PeriphResetCmd+0xe>
 80a0372:	ea22 0000 	bic.w	r0, r2, r0
 80a0376:	6258      	str	r0, [r3, #36]	; 0x24
 80a0378:	4770      	bx	lr
 80a037a:	bf00      	nop
 80a037c:	40023800 	.word	0x40023800

080a0380 <TIM_DeInit>:
 80a0380:	b508      	push	{r3, lr}
 80a0382:	4b47      	ldr	r3, [pc, #284]	; (80a04a0 <TIM_DeInit+0x120>)
 80a0384:	4298      	cmp	r0, r3
 80a0386:	d105      	bne.n	80a0394 <TIM_DeInit+0x14>
 80a0388:	2001      	movs	r0, #1
 80a038a:	4601      	mov	r1, r0
 80a038c:	f7ff ffec 	bl	80a0368 <RCC_APB2PeriphResetCmd>
 80a0390:	2001      	movs	r0, #1
 80a0392:	e03d      	b.n	80a0410 <TIM_DeInit+0x90>
 80a0394:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80a0398:	d105      	bne.n	80a03a6 <TIM_DeInit+0x26>
 80a039a:	2001      	movs	r0, #1
 80a039c:	4601      	mov	r1, r0
 80a039e:	f7ff ffd7 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a03a2:	2001      	movs	r0, #1
 80a03a4:	e076      	b.n	80a0494 <TIM_DeInit+0x114>
 80a03a6:	4b3f      	ldr	r3, [pc, #252]	; (80a04a4 <TIM_DeInit+0x124>)
 80a03a8:	4298      	cmp	r0, r3
 80a03aa:	d105      	bne.n	80a03b8 <TIM_DeInit+0x38>
 80a03ac:	2002      	movs	r0, #2
 80a03ae:	2101      	movs	r1, #1
 80a03b0:	f7ff ffce 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a03b4:	2002      	movs	r0, #2
 80a03b6:	e06d      	b.n	80a0494 <TIM_DeInit+0x114>
 80a03b8:	4b3b      	ldr	r3, [pc, #236]	; (80a04a8 <TIM_DeInit+0x128>)
 80a03ba:	4298      	cmp	r0, r3
 80a03bc:	d105      	bne.n	80a03ca <TIM_DeInit+0x4a>
 80a03be:	2004      	movs	r0, #4
 80a03c0:	2101      	movs	r1, #1
 80a03c2:	f7ff ffc5 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a03c6:	2004      	movs	r0, #4
 80a03c8:	e064      	b.n	80a0494 <TIM_DeInit+0x114>
 80a03ca:	4b38      	ldr	r3, [pc, #224]	; (80a04ac <TIM_DeInit+0x12c>)
 80a03cc:	4298      	cmp	r0, r3
 80a03ce:	d105      	bne.n	80a03dc <TIM_DeInit+0x5c>
 80a03d0:	2008      	movs	r0, #8
 80a03d2:	2101      	movs	r1, #1
 80a03d4:	f7ff ffbc 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a03d8:	2008      	movs	r0, #8
 80a03da:	e05b      	b.n	80a0494 <TIM_DeInit+0x114>
 80a03dc:	4b34      	ldr	r3, [pc, #208]	; (80a04b0 <TIM_DeInit+0x130>)
 80a03de:	4298      	cmp	r0, r3
 80a03e0:	d105      	bne.n	80a03ee <TIM_DeInit+0x6e>
 80a03e2:	2010      	movs	r0, #16
 80a03e4:	2101      	movs	r1, #1
 80a03e6:	f7ff ffb3 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a03ea:	2010      	movs	r0, #16
 80a03ec:	e052      	b.n	80a0494 <TIM_DeInit+0x114>
 80a03ee:	4b31      	ldr	r3, [pc, #196]	; (80a04b4 <TIM_DeInit+0x134>)
 80a03f0:	4298      	cmp	r0, r3
 80a03f2:	d105      	bne.n	80a0400 <TIM_DeInit+0x80>
 80a03f4:	2020      	movs	r0, #32
 80a03f6:	2101      	movs	r1, #1
 80a03f8:	f7ff ffaa 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a03fc:	2020      	movs	r0, #32
 80a03fe:	e049      	b.n	80a0494 <TIM_DeInit+0x114>
 80a0400:	4b2d      	ldr	r3, [pc, #180]	; (80a04b8 <TIM_DeInit+0x138>)
 80a0402:	4298      	cmp	r0, r3
 80a0404:	d109      	bne.n	80a041a <TIM_DeInit+0x9a>
 80a0406:	2002      	movs	r0, #2
 80a0408:	2101      	movs	r1, #1
 80a040a:	f7ff ffad 	bl	80a0368 <RCC_APB2PeriphResetCmd>
 80a040e:	2002      	movs	r0, #2
 80a0410:	2100      	movs	r1, #0
 80a0412:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a0416:	f7ff bfa7 	b.w	80a0368 <RCC_APB2PeriphResetCmd>
 80a041a:	4b28      	ldr	r3, [pc, #160]	; (80a04bc <TIM_DeInit+0x13c>)
 80a041c:	4298      	cmp	r0, r3
 80a041e:	d107      	bne.n	80a0430 <TIM_DeInit+0xb0>
 80a0420:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80a0424:	2101      	movs	r1, #1
 80a0426:	f7ff ff9f 	bl	80a0368 <RCC_APB2PeriphResetCmd>
 80a042a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80a042e:	e7ef      	b.n	80a0410 <TIM_DeInit+0x90>
 80a0430:	4b23      	ldr	r3, [pc, #140]	; (80a04c0 <TIM_DeInit+0x140>)
 80a0432:	4298      	cmp	r0, r3
 80a0434:	d107      	bne.n	80a0446 <TIM_DeInit+0xc6>
 80a0436:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80a043a:	2101      	movs	r1, #1
 80a043c:	f7ff ff94 	bl	80a0368 <RCC_APB2PeriphResetCmd>
 80a0440:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80a0444:	e7e4      	b.n	80a0410 <TIM_DeInit+0x90>
 80a0446:	4b1f      	ldr	r3, [pc, #124]	; (80a04c4 <TIM_DeInit+0x144>)
 80a0448:	4298      	cmp	r0, r3
 80a044a:	d107      	bne.n	80a045c <TIM_DeInit+0xdc>
 80a044c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80a0450:	2101      	movs	r1, #1
 80a0452:	f7ff ff89 	bl	80a0368 <RCC_APB2PeriphResetCmd>
 80a0456:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80a045a:	e7d9      	b.n	80a0410 <TIM_DeInit+0x90>
 80a045c:	4b1a      	ldr	r3, [pc, #104]	; (80a04c8 <TIM_DeInit+0x148>)
 80a045e:	4298      	cmp	r0, r3
 80a0460:	d105      	bne.n	80a046e <TIM_DeInit+0xee>
 80a0462:	2040      	movs	r0, #64	; 0x40
 80a0464:	2101      	movs	r1, #1
 80a0466:	f7ff ff73 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a046a:	2040      	movs	r0, #64	; 0x40
 80a046c:	e012      	b.n	80a0494 <TIM_DeInit+0x114>
 80a046e:	4b17      	ldr	r3, [pc, #92]	; (80a04cc <TIM_DeInit+0x14c>)
 80a0470:	4298      	cmp	r0, r3
 80a0472:	d105      	bne.n	80a0480 <TIM_DeInit+0x100>
 80a0474:	2080      	movs	r0, #128	; 0x80
 80a0476:	2101      	movs	r1, #1
 80a0478:	f7ff ff6a 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a047c:	2080      	movs	r0, #128	; 0x80
 80a047e:	e009      	b.n	80a0494 <TIM_DeInit+0x114>
 80a0480:	4b13      	ldr	r3, [pc, #76]	; (80a04d0 <TIM_DeInit+0x150>)
 80a0482:	4298      	cmp	r0, r3
 80a0484:	d10b      	bne.n	80a049e <TIM_DeInit+0x11e>
 80a0486:	f44f 7080 	mov.w	r0, #256	; 0x100
 80a048a:	2101      	movs	r1, #1
 80a048c:	f7ff ff60 	bl	80a0350 <RCC_APB1PeriphResetCmd>
 80a0490:	f44f 7080 	mov.w	r0, #256	; 0x100
 80a0494:	2100      	movs	r1, #0
 80a0496:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a049a:	f7ff bf59 	b.w	80a0350 <RCC_APB1PeriphResetCmd>
 80a049e:	bd08      	pop	{r3, pc}
 80a04a0:	40010000 	.word	0x40010000
 80a04a4:	40000400 	.word	0x40000400
 80a04a8:	40000800 	.word	0x40000800
 80a04ac:	40000c00 	.word	0x40000c00
 80a04b0:	40001000 	.word	0x40001000
 80a04b4:	40001400 	.word	0x40001400
 80a04b8:	40010400 	.word	0x40010400
 80a04bc:	40014000 	.word	0x40014000
 80a04c0:	40014400 	.word	0x40014400
 80a04c4:	40014800 	.word	0x40014800
 80a04c8:	40001800 	.word	0x40001800
 80a04cc:	40001c00 	.word	0x40001c00
 80a04d0:	40002000 	.word	0x40002000

080a04d4 <TIM_SetAutoreload>:
 80a04d4:	62c1      	str	r1, [r0, #44]	; 0x2c
 80a04d6:	4770      	bx	lr

080a04d8 <TIM_Cmd>:
 80a04d8:	8803      	ldrh	r3, [r0, #0]
 80a04da:	b119      	cbz	r1, 80a04e4 <TIM_Cmd+0xc>
 80a04dc:	b29b      	uxth	r3, r3
 80a04de:	f043 0301 	orr.w	r3, r3, #1
 80a04e2:	e003      	b.n	80a04ec <TIM_Cmd+0x14>
 80a04e4:	f023 0301 	bic.w	r3, r3, #1
 80a04e8:	041b      	lsls	r3, r3, #16
 80a04ea:	0c1b      	lsrs	r3, r3, #16
 80a04ec:	8003      	strh	r3, [r0, #0]
 80a04ee:	4770      	bx	lr

080a04f0 <TIM_ITConfig>:
 80a04f0:	8983      	ldrh	r3, [r0, #12]
 80a04f2:	b29b      	uxth	r3, r3
 80a04f4:	b10a      	cbz	r2, 80a04fa <TIM_ITConfig+0xa>
 80a04f6:	4319      	orrs	r1, r3
 80a04f8:	e001      	b.n	80a04fe <TIM_ITConfig+0xe>
 80a04fa:	ea23 0101 	bic.w	r1, r3, r1
 80a04fe:	8181      	strh	r1, [r0, #12]
 80a0500:	4770      	bx	lr

080a0502 <TIM_SelectOutputTrigger>:
 80a0502:	8883      	ldrh	r3, [r0, #4]
 80a0504:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80a0508:	041b      	lsls	r3, r3, #16
 80a050a:	0c1b      	lsrs	r3, r3, #16
 80a050c:	8083      	strh	r3, [r0, #4]
 80a050e:	8883      	ldrh	r3, [r0, #4]
 80a0510:	b29b      	uxth	r3, r3
 80a0512:	4319      	orrs	r1, r3
 80a0514:	8081      	strh	r1, [r0, #4]
 80a0516:	4770      	bx	lr

080a0518 <_ZN8particle11SPISettingsD1Ev>:
  SPISettings()
  {
  }

  virtual ~SPISettings() {
  }
 80a0518:	4770      	bx	lr

080a051a <_ZN5spark10LogHandler5writeEPKcj>:
    }
}

inline void spark::LogHandler::write(const char *data, size_t size) {
    // Default implementation does nothing
}
 80a051a:	4770      	bx	lr

080a051c <_ZN5spark16StreamLogHandler5writeEPKcj>:
inline Print* spark::StreamLogHandler::stream() const {
    return stream_;
}

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
 80a051c:	6a00      	ldr	r0, [r0, #32]
 80a051e:	6803      	ldr	r3, [r0, #0]
 80a0520:	68db      	ldr	r3, [r3, #12]
 80a0522:	4718      	bx	r3

080a0524 <_ZN4File9availableEv>:
    return isOpen();
  }
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
 80a0524:	4602      	mov	r2, r0
  void setpos(FatPos_t* pos);
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available() {
    return isFile() ? fileSize() - curPosition() : 0;
 80a0526:	7c03      	ldrb	r3, [r0, #16]
 80a0528:	f013 0008 	ands.w	r0, r3, #8
 80a052c:	bf1e      	ittt	ne
 80a052e:	6a50      	ldrne	r0, [r2, #36]	; 0x24
 80a0530:	6ad3      	ldrne	r3, [r2, #44]	; 0x2c
 80a0532:	1a18      	subne	r0, r3, r0
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
 80a0534:	2800      	cmp	r0, #0
  }
 80a0536:	bfb8      	it	lt
 80a0538:	f06f 4000 	mvnlt.w	r0, #2147483648	; 0x80000000
 80a053c:	4770      	bx	lr

080a053e <_ZNSt17_Function_handlerIFi6StringEPFiPKcEE9_M_invokeERKSt9_Any_dataOS0_>:

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
	return (*_Base::_M_get_pointer(__functor))(
 80a053e:	6803      	ldr	r3, [r0, #0]
 80a0540:	6808      	ldr	r0, [r1, #0]
 80a0542:	4718      	bx	r3

080a0544 <_ZNSt14_Function_base13_Base_managerIPFiPKcEE10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation>:
	  switch (__op)
 80a0544:	2a01      	cmp	r2, #1
 80a0546:	d003      	beq.n	80a0550 <_ZNSt14_Function_base13_Base_managerIPFiPKcEE10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0xc>
 80a0548:	2a02      	cmp	r2, #2
 80a054a:	d003      	beq.n	80a0554 <_ZNSt14_Function_base13_Base_managerIPFiPKcEE10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0x10>
	}
 80a054c:	2000      	movs	r0, #0
 80a054e:	4770      	bx	lr
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a0550:	6001      	str	r1, [r0, #0]
	      break;
 80a0552:	e7fb      	b.n	80a054c <_ZNSt14_Function_base13_Base_managerIPFiPKcEE10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0x8>
	  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 80a0554:	680b      	ldr	r3, [r1, #0]
 80a0556:	6003      	str	r3, [r0, #0]
	}
 80a0558:	e7f8      	b.n	80a054c <_ZNSt14_Function_base13_Base_managerIPFiPKcEE10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0x8>

080a055a <_ZN4FileD1Ev>:
class File : public FatFile, public Stream {
 80a055a:	4770      	bx	lr

080a055c <_ZN8particle11SPISettingsD0Ev>:
  virtual ~SPISettings() {
 80a055c:	b510      	push	{r4, lr}
 80a055e:	4604      	mov	r4, r0
  }
 80a0560:	2110      	movs	r1, #16
 80a0562:	f006 f975 	bl	80a6850 <_ZdlPvj>
 80a0566:	4620      	mov	r0, r4
 80a0568:	bd10      	pop	{r4, pc}

080a056a <_ZN4FileD0Ev>:
 80a056a:	b510      	push	{r4, lr}
 80a056c:	4604      	mov	r4, r0
 80a056e:	2134      	movs	r1, #52	; 0x34
 80a0570:	f006 f96e 	bl	80a6850 <_ZdlPvj>
 80a0574:	4620      	mov	r0, r4
 80a0576:	bd10      	pop	{r4, pc}

080a0578 <_ZN4File4readEv>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
 80a0578:	b507      	push	{r0, r1, r2, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
 80a057a:	2201      	movs	r2, #1
 80a057c:	f10d 0107 	add.w	r1, sp, #7
 80a0580:	3010      	adds	r0, #16
 80a0582:	f000 fee8 	bl	80a1356 <_ZN7FatFile4readEPvj>
 80a0586:	2801      	cmp	r0, #1
 80a0588:	bf14      	ite	ne
 80a058a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80a058e:	f89d 0007 	ldrbeq.w	r0, [sp, #7]
    return FatFile::read();
  }
 80a0592:	b003      	add	sp, #12
 80a0594:	f85d fb04 	ldr.w	pc, [sp], #4

080a0598 <_ZN4File5flushEv>:
    FatFile::sync();
 80a0598:	3010      	adds	r0, #16
 80a059a:	f001 b8ab 	b.w	80a16f4 <_ZN7FatFile4syncEv>

080a059e <_ZN4File4peekEv>:
    return FatFile::peek();
 80a059e:	3010      	adds	r0, #16
 80a05a0:	f000 bf87 	b.w	80a14b2 <_ZN7FatFile4peekEv>

080a05a4 <_ZN4File5writeEPKhj>:
   * include write() is called before a file has been opened, write is called
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const uint8_t *buf, size_t size) {
    return FatFile::write(buf, size);
 80a05a4:	3010      	adds	r0, #16
 80a05a6:	f001 b94b 	b.w	80a1840 <_ZN7FatFile5writeEPKvj>

080a05aa <_ZN4File5writeEh>:
  size_t write(uint8_t b) {
 80a05aa:	b507      	push	{r0, r1, r2, lr}
  /** Write a single byte.
   * \param[in] b The byte to be written.
   * \return +1 for success or -1 for failure.
   */
  int write(uint8_t b) {
    return write(&b, 1);
 80a05ac:	2201      	movs	r2, #1
 80a05ae:	f88d 1007 	strb.w	r1, [sp, #7]
 80a05b2:	3010      	adds	r0, #16
 80a05b4:	f10d 0107 	add.w	r1, sp, #7
 80a05b8:	f001 f942 	bl	80a1840 <_ZN7FatFile5writeEPKvj>
  }
 80a05bc:	b003      	add	sp, #12
 80a05be:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a05c4 <__tcf_0>:
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a05c4:	4b02      	ldr	r3, [pc, #8]	; (80a05d0 <__tcf_0+0xc>)
 80a05c6:	6898      	ldr	r0, [r3, #8]
 80a05c8:	b108      	cbz	r0, 80a05ce <__tcf_0+0xa>
            os_mutex_recursive_destroy(handle_);
 80a05ca:	f003 bd91 	b.w	80a40f0 <os_mutex_recursive_destroy>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a05ce:	4770      	bx	lr
 80a05d0:	20000094 	.word	0x20000094

080a05d4 <_ZN5spark16SerialLogHandlerD1Ev>:
            StreamLogHandler(Serial, level, filters) {
        Serial.begin(baud);
        LogManager::instance()->addHandler(this);
    }

    virtual ~SerialLogHandler() {
 80a05d4:	b510      	push	{r4, lr}
 80a05d6:	4604      	mov	r4, r0
 80a05d8:	4b09      	ldr	r3, [pc, #36]	; (80a0600 <_ZN5spark16SerialLogHandlerD1Ev+0x2c>)
 80a05da:	6003      	str	r3, [r0, #0]
        LogManager::instance()->removeHandler(this);
 80a05dc:	f004 fc3a 	bl	80a4e54 <_ZN5spark10LogManager8instanceEv>
 80a05e0:	4621      	mov	r1, r4
 80a05e2:	f004 fe47 	bl	80a5274 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE>
        Serial.end();
 80a05e6:	f005 fe8b 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a05ea:	f005 fe6f 	bl	80a62cc <_ZN9USBSerial3endEv>
    virtual ~LogHandler() = default;
 80a05ee:	4620      	mov	r0, r4
 80a05f0:	4b04      	ldr	r3, [pc, #16]	; (80a0604 <_ZN5spark16SerialLogHandlerD1Ev+0x30>)
 80a05f2:	f840 3b04 	str.w	r3, [r0], #4
 80a05f6:	f004 fd2b 	bl	80a5050 <_ZN5spark6detail9LogFilterD1Ev>
    }
 80a05fa:	4620      	mov	r0, r4
 80a05fc:	bd10      	pop	{r4, pc}
 80a05fe:	bf00      	nop
 80a0600:	080a7de0 	.word	0x080a7de0
 80a0604:	080a7dc8 	.word	0x080a7dc8

080a0608 <_ZN5spark16SerialLogHandlerD0Ev>:
    virtual ~SerialLogHandler() {
 80a0608:	b510      	push	{r4, lr}
 80a060a:	4604      	mov	r4, r0
    }
 80a060c:	f7ff ffe2 	bl	80a05d4 <_ZN5spark16SerialLogHandlerD1Ev>
 80a0610:	4620      	mov	r0, r4
 80a0612:	2124      	movs	r1, #36	; 0x24
 80a0614:	f006 f91c 	bl	80a6850 <_ZdlPvj>
 80a0618:	4620      	mov	r0, r4
 80a061a:	bd10      	pop	{r4, pc}

080a061c <_ZN5Print6printfEPKcz>:
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);
    size_t println(const __FlashStringHelper*);

    size_t printf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
 80a061c:	b40e      	push	{r1, r2, r3}
 80a061e:	b503      	push	{r0, r1, lr}
 80a0620:	ab03      	add	r3, sp, #12
 80a0622:	f853 2b04 	ldr.w	r2, [r3], #4
    {
        va_list args;
        va_start(args, format);
        auto r = this->vprintf(false, format, args);
 80a0626:	2100      	movs	r1, #0
        va_start(args, format);
 80a0628:	9301      	str	r3, [sp, #4]
        auto r = this->vprintf(false, format, args);
 80a062a:	f005 fb4d 	bl	80a5cc8 <_ZN5Print7vprintfEbPKcSt9__va_list>
        va_end(args);
        return r;
    }
 80a062e:	b002      	add	sp, #8
 80a0630:	f85d eb04 	ldr.w	lr, [sp], #4
 80a0634:	b003      	add	sp, #12
 80a0636:	4770      	bx	lr

080a0638 <_ZNK8particle11SPISettings7printToER5Print>:
  bool operator!=(const SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a0638:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a063a:	4604      	mov	r4, r0
  {
    if (default_ && clock_ == 0)
 80a063c:	7922      	ldrb	r2, [r4, #4]
  virtual size_t printTo(Print& p) const
 80a063e:	4608      	mov	r0, r1
 80a0640:	68a3      	ldr	r3, [r4, #8]
    if (default_ && clock_ == 0)
 80a0642:	b132      	cbz	r2, 80a0652 <_ZNK8particle11SPISettings7printToER5Print+0x1a>
 80a0644:	b9a3      	cbnz	r3, 80a0670 <_ZNK8particle11SPISettings7printToER5Print+0x38>
      return p.print("<SPISettings default>");
 80a0646:	490b      	ldr	r1, [pc, #44]	; (80a0674 <_ZNK8particle11SPISettings7printToER5Print+0x3c>)
    else
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
          bitOrder_ == MSBFIRST ? "MSB" : "LSB", (unsigned int)dataMode_);
  }
 80a0648:	b002      	add	sp, #8
 80a064a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return p.print("<SPISettings default>");
 80a064e:	f005 bb0b 	b.w	80a5c68 <_ZN5Print5printEPKc>
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
 80a0652:	4a09      	ldr	r2, [pc, #36]	; (80a0678 <_ZNK8particle11SPISettings7printToER5Print+0x40>)
 80a0654:	7b26      	ldrb	r6, [r4, #12]
 80a0656:	4d09      	ldr	r5, [pc, #36]	; (80a067c <_ZNK8particle11SPISettings7printToER5Print+0x44>)
 80a0658:	4909      	ldr	r1, [pc, #36]	; (80a0680 <_ZNK8particle11SPISettings7printToER5Print+0x48>)
 80a065a:	7b64      	ldrb	r4, [r4, #13]
 80a065c:	2e01      	cmp	r6, #1
 80a065e:	bf18      	it	ne
 80a0660:	4629      	movne	r1, r5
 80a0662:	e9cd 1400 	strd	r1, r4, [sp]
 80a0666:	4907      	ldr	r1, [pc, #28]	; (80a0684 <_ZNK8particle11SPISettings7printToER5Print+0x4c>)
 80a0668:	f7ff ffd8 	bl	80a061c <_ZN5Print6printfEPKcz>
  }
 80a066c:	b002      	add	sp, #8
 80a066e:	bd70      	pop	{r4, r5, r6, pc}
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
 80a0670:	4a05      	ldr	r2, [pc, #20]	; (80a0688 <_ZNK8particle11SPISettings7printToER5Print+0x50>)
 80a0672:	e7ef      	b.n	80a0654 <_ZNK8particle11SPISettings7printToER5Print+0x1c>
 80a0674:	080a7c71 	.word	0x080a7c71
 80a0678:	080a7ecd 	.word	0x080a7ecd
 80a067c:	080a7c6d 	.word	0x080a7c6d
 80a0680:	080a7c69 	.word	0x080a7c69
 80a0684:	080a7c87 	.word	0x080a7c87
 80a0688:	080a7c60 	.word	0x080a7c60

080a068c <_ZNK5spark6Logger4infoEPKcz>:
    va_start(args, fmt);
    log(LOG_LEVEL_TRACE, fmt, args);
    va_end(args);
}

inline void spark::Logger::info(const char *fmt, ...) const {
 80a068c:	b40e      	push	{r1, r2, r3}
 80a068e:	b510      	push	{r4, lr}
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
 80a0690:	2300      	movs	r3, #0
    log(LOG_LEVEL_INFO, fmt, args);
 80a0692:	6801      	ldr	r1, [r0, #0]
    attr.flags = 0;
 80a0694:	2020      	movs	r0, #32
inline void spark::Logger::info(const char *fmt, ...) const {
 80a0696:	b08d      	sub	sp, #52	; 0x34
 80a0698:	aa0f      	add	r2, sp, #60	; 0x3c
 80a069a:	f852 4b04 	ldr.w	r4, [r2], #4
    attr.flags = 0;
 80a069e:	e9cd 0304 	strd	r0, r3, [sp, #16]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a06a2:	e9cd 4200 	strd	r4, r2, [sp]
    va_start(args, fmt);
 80a06a6:	9203      	str	r2, [sp, #12]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a06a8:	201e      	movs	r0, #30
 80a06aa:	aa04      	add	r2, sp, #16
 80a06ac:	f003 fec2 	bl	80a4434 <log_message_v>
}
 80a06b0:	b00d      	add	sp, #52	; 0x34
 80a06b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a06b6:	b003      	add	sp, #12
 80a06b8:	4770      	bx	lr

080a06ba <_ZNK5spark6Logger4warnEPKcz>:
inline void spark::Logger::warn(const char *fmt, ...) const {
 80a06ba:	b40e      	push	{r1, r2, r3}
 80a06bc:	b510      	push	{r4, lr}
    attr.flags = 0;
 80a06be:	2300      	movs	r3, #0
    log(LOG_LEVEL_WARN, fmt, args);
 80a06c0:	6801      	ldr	r1, [r0, #0]
    attr.flags = 0;
 80a06c2:	2020      	movs	r0, #32
inline void spark::Logger::warn(const char *fmt, ...) const {
 80a06c4:	b08d      	sub	sp, #52	; 0x34
 80a06c6:	aa0f      	add	r2, sp, #60	; 0x3c
 80a06c8:	f852 4b04 	ldr.w	r4, [r2], #4
    attr.flags = 0;
 80a06cc:	e9cd 0304 	strd	r0, r3, [sp, #16]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a06d0:	e9cd 4200 	strd	r4, r2, [sp]
    va_start(args, fmt);
 80a06d4:	9203      	str	r2, [sp, #12]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a06d6:	2028      	movs	r0, #40	; 0x28
 80a06d8:	aa04      	add	r2, sp, #16
 80a06da:	f003 feab 	bl	80a4434 <log_message_v>
}
 80a06de:	b00d      	add	sp, #52	; 0x34
 80a06e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a06e4:	b003      	add	sp, #12
 80a06e6:	4770      	bx	lr

080a06e8 <_ZNK5spark6Logger5errorEPKcz>:
inline void spark::Logger::error(const char *fmt, ...) const {
 80a06e8:	b40e      	push	{r1, r2, r3}
 80a06ea:	b510      	push	{r4, lr}
    attr.flags = 0;
 80a06ec:	2300      	movs	r3, #0
    log(LOG_LEVEL_ERROR, fmt, args);
 80a06ee:	6801      	ldr	r1, [r0, #0]
    attr.flags = 0;
 80a06f0:	2020      	movs	r0, #32
inline void spark::Logger::error(const char *fmt, ...) const {
 80a06f2:	b08d      	sub	sp, #52	; 0x34
 80a06f4:	aa0f      	add	r2, sp, #60	; 0x3c
 80a06f6:	f852 4b04 	ldr.w	r4, [r2], #4
    attr.flags = 0;
 80a06fa:	e9cd 0304 	strd	r0, r3, [sp, #16]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a06fe:	e9cd 4200 	strd	r4, r2, [sp]
    va_start(args, fmt);
 80a0702:	9203      	str	r2, [sp, #12]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a0704:	2032      	movs	r0, #50	; 0x32
 80a0706:	aa04      	add	r2, sp, #16
 80a0708:	f003 fe94 	bl	80a4434 <log_message_v>
}
 80a070c:	b00d      	add	sp, #52	; 0x34
 80a070e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a0712:	b003      	add	sp, #12
 80a0714:	4770      	bx	lr

080a0716 <_ZNK5spark6Logger6printfEPKcz>:
inline void spark::Logger::printf(const char *fmt, ...) const {
 80a0716:	b40e      	push	{r1, r2, r3}
 80a0718:	b50f      	push	{r0, r1, r2, r3, lr}
 80a071a:	aa05      	add	r2, sp, #20
 80a071c:	f852 3b04 	ldr.w	r3, [r2], #4
    log_printf_v(DEFAULT_LEVEL, name_, nullptr, fmt, args);
 80a0720:	9200      	str	r2, [sp, #0]
 80a0722:	6801      	ldr	r1, [r0, #0]
    va_start(args, fmt);
 80a0724:	9203      	str	r2, [sp, #12]
    log_printf_v(DEFAULT_LEVEL, name_, nullptr, fmt, args);
 80a0726:	201e      	movs	r0, #30
 80a0728:	2200      	movs	r2, #0
 80a072a:	f003 fe8b 	bl	80a4444 <log_printf_v>
}
 80a072e:	b004      	add	sp, #16
 80a0730:	f85d eb04 	ldr.w	lr, [sp], #4
 80a0734:	b003      	add	sp, #12
 80a0736:	4770      	bx	lr

080a0738 <_ZN5SdFatC1Ev>:
#else  // ENABLE_EXTENDED_TRANSFER_CLASS || ENABLE_SDIO_CLASS
class SdSpiCard {
#endif  // ENABLE_EXTENDED_TRANSFER_CLASS || ENABLE_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() : m_errorCode(SD_CARD_ERROR_INIT_NOT_CALLED), m_type(0) {}
 80a0738:	2264      	movs	r2, #100	; 0x64
 * \brief Main file system class for %SdFat library.
 */
class SdFat : public SdFileSystem<SdSpiCard> {
 public:
#if IMPLEMENT_SPI_PORT_SELECTION || defined(DOXYGEN)
  SdFat() {
 80a073a:	b570      	push	{r4, r5, r6, lr}
 80a073c:	f880 2460 	strb.w	r2, [r0, #1120]	; 0x460
  {
 80a0740:	4a15      	ldr	r2, [pc, #84]	; (80a0798 <_ZN5SdFatC1Ev+0x60>)
 */
class FatVolume {
 public:
  /** Create an instance of FatVolume
   */
  FatVolume() : m_fatType(0) {}
 80a0742:	2300      	movs	r3, #0
 80a0744:	f8c0 2470 	str.w	r2, [r0, #1136]	; 0x470
 80a0748:	2201      	movs	r2, #1
 80a074a:	4e14      	ldr	r6, [pc, #80]	; (80a079c <_ZN5SdFatC1Ev+0x64>)
 80a074c:	71c3      	strb	r3, [r0, #7]
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
 80a074e:	f8a0 343c 	strh.w	r3, [r0, #1084]	; 0x43c
 80a0752:	f880 346a 	strb.w	r3, [r0, #1130]	; 0x46a
 80a0756:	f880 2474 	strb.w	r2, [r0, #1140]	; 0x474
 80a075a:	f8c0 3478 	str.w	r3, [r0, #1144]	; 0x478
 80a075e:	f8a0 347c 	strh.w	r3, [r0, #1148]	; 0x47c
 80a0762:	7831      	ldrb	r1, [r6, #0]
 80a0764:	4604      	mov	r4, r0
 80a0766:	ea11 0502 	ands.w	r5, r1, r2
 80a076a:	f3bf 8f5b 	dmb	ish
 80a076e:	d10d      	bne.n	80a078c <_ZN5SdFatC1Ev+0x54>
 80a0770:	4630      	mov	r0, r6
 80a0772:	f7ff fca1 	bl	80a00b8 <__cxa_guard_acquire>
 80a0776:	b148      	cbz	r0, 80a078c <_ZN5SdFatC1Ev+0x54>
 80a0778:	4629      	mov	r1, r5
 80a077a:	4809      	ldr	r0, [pc, #36]	; (80a07a0 <_ZN5SdFatC1Ev+0x68>)
 80a077c:	f005 fb58 	bl	80a5e30 <_ZN8SPIClassC1E19hal_spi_interface_t>
 80a0780:	4630      	mov	r0, r6
 80a0782:	f7ff fc9e 	bl	80a00c2 <__cxa_guard_release>
 80a0786:	4807      	ldr	r0, [pc, #28]	; (80a07a4 <_ZN5SdFatC1Ev+0x6c>)
 80a0788:	f007 f85a 	bl	80a7840 <atexit>
#if IMPLEMENT_SPI_PORT_SELECTION || defined(DOXYGEN)
  /** Set SPI port number.
   * \param[in] spiPort Hardware SPI port.
   */
  void setPort(SPIClass* spiPort) {
    m_spi = spiPort ? spiPort : &SDCARD_SPI;
 80a078c:	4b04      	ldr	r3, [pc, #16]	; (80a07a0 <_ZN5SdFatC1Ev+0x68>)
    m_spi.setPort(nullptr);
  }
 80a078e:	4620      	mov	r0, r4
 80a0790:	f8c4 346c 	str.w	r3, [r4, #1132]	; 0x46c
 80a0794:	bd70      	pop	{r4, r5, r6, pc}
 80a0796:	bf00      	nop
 80a0798:	080a7db4 	.word	0x080a7db4
 80a079c:	20000090 	.word	0x20000090
 80a07a0:	20000094 	.word	0x20000094
 80a07a4:	080a05c5 	.word	0x080a05c5

080a07a8 <_Z9readChunkv>:
  }

  return retVal;
}

int readChunk() {
 80a07a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a07ac:	b083      	sub	sp, #12
  int retVal = 0;
  if (wavFile.isOpen()) {
 80a07ae:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 80a0880 <_Z9readChunkv+0xd8>
int readChunk() {
 80a07b2:	af00      	add	r7, sp, #0
  if (wavFile.isOpen()) {
 80a07b4:	f89b 4010 	ldrb.w	r4, [fp, #16]
 80a07b8:	2c00      	cmp	r4, #0
 80a07ba:	d04e      	beq.n	80a085a <_Z9readChunkv+0xb2>
      meanSquareValue += ((int16_t)(wav[retVal-1]))*((int16_t)(wav[retVal-1]));
    }
    

    meanSquareValue = sqrt(meanSquareValue);
    soundVolume = sqrt(1048525 - meanSquareValue);
 80a07bc:	46e9      	mov	r9, sp
    uint8_t   buf[BUFFERSIZE * 2 * wh.num_channels];
 80a07be:	4d2b      	ldr	r5, [pc, #172]	; (80a086c <_Z9readChunkv+0xc4>)
    uint16_t* wav = speaker.getBuffer();
 80a07c0:	482b      	ldr	r0, [pc, #172]	; (80a0870 <_Z9readChunkv+0xc8>)
 80a07c2:	f003 fc7f 	bl	80a40c4 <_ZN7Speaker9getBufferEv>
    uint8_t   buf[BUFFERSIZE * 2 * wh.num_channels];
 80a07c6:	8aeb      	ldrh	r3, [r5, #22]
    uint16_t* wav = speaker.getBuffer();
 80a07c8:	4606      	mov	r6, r0
    uint8_t   buf[BUFFERSIZE * 2 * wh.num_channels];
 80a07ca:	02dc      	lsls	r4, r3, #11
 80a07cc:	eba9 23c3 	sub.w	r3, r9, r3, lsl #11
 80a07d0:	469d      	mov	sp, r3
    int       n = wavFile.read(buf, sizeof(buf));
 80a07d2:	4622      	mov	r2, r4
 80a07d4:	4669      	mov	r1, sp
 80a07d6:	f10b 0010 	add.w	r0, fp, #16
 80a07da:	f000 fdbc 	bl	80a1356 <_ZN7FatFile4readEPvj>
    if (n < sizeof(buf)) wavFile.close();               // when all data is read close the file
 80a07de:	4284      	cmp	r4, r0
    uint8_t   buf[BUFFERSIZE * 2 * wh.num_channels];
 80a07e0:	46ea      	mov	sl, sp
    int       n = wavFile.read(buf, sizeof(buf));
 80a07e2:	4680      	mov	r8, r0
    if (n < sizeof(buf)) wavFile.close();               // when all data is read close the file
 80a07e4:	d903      	bls.n	80a07ee <_Z9readChunkv+0x46>
 80a07e6:	f10b 0010 	add.w	r0, fp, #16
 80a07ea:	f000 ffb9 	bl	80a1760 <_ZN7FatFile5closeEv>
    memset((uint8_t*)wav, 0x80, BUFFERSIZE);            // reset buffer to bias value 0x8080
 80a07ee:	f04f 0b00 	mov.w	fp, #0
 80a07f2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80a07f6:	2180      	movs	r1, #128	; 0x80
 80a07f8:	4630      	mov	r0, r6
 80a07fa:	f007 f85d 	bl	80a78b8 <memset>
    float meanSquareValue = 0;
 80a07fe:	2400      	movs	r4, #0
    for(int b = 0; b < n; b += wh.sample_alignment) {
 80a0800:	465a      	mov	r2, fp
 80a0802:	4590      	cmp	r8, r2
 80a0804:	dd15      	ble.n	80a0832 <_Z9readChunkv+0x8a>
      wav[retVal++] = *(uint16_t*)&buf[b] + 32768;      // convert int16_t to uin16_t with bias 0x8000
 80a0806:	f83a 3002 	ldrh.w	r3, [sl, r2]
 80a080a:	607a      	str	r2, [r7, #4]
 80a080c:	f483 4300 	eor.w	r3, r3, #32768	; 0x8000
      meanSquareValue += ((int16_t)(wav[retVal-1]))*((int16_t)(wav[retVal-1]));
 80a0810:	b218      	sxth	r0, r3
      wav[retVal++] = *(uint16_t*)&buf[b] + 32768;      // convert int16_t to uin16_t with bias 0x8000
 80a0812:	f826 301b 	strh.w	r3, [r6, fp, lsl #1]
      meanSquareValue += ((int16_t)(wav[retVal-1]))*((int16_t)(wav[retVal-1]));
 80a0816:	4340      	muls	r0, r0
 80a0818:	f006 fde2 	bl	80a73e0 <__aeabi_i2f>
 80a081c:	4601      	mov	r1, r0
 80a081e:	4620      	mov	r0, r4
 80a0820:	f006 fd2a 	bl	80a7278 <__addsf3>
    for(int b = 0; b < n; b += wh.sample_alignment) {
 80a0824:	8c2b      	ldrh	r3, [r5, #32]
 80a0826:	687a      	ldr	r2, [r7, #4]
      meanSquareValue += ((int16_t)(wav[retVal-1]))*((int16_t)(wav[retVal-1]));
 80a0828:	4604      	mov	r4, r0
    for(int b = 0; b < n; b += wh.sample_alignment) {
 80a082a:	441a      	add	r2, r3
 80a082c:	f10b 0b01 	add.w	fp, fp, #1
 80a0830:	e7e7      	b.n	80a0802 <_Z9readChunkv+0x5a>
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
 80a0832:	4620      	mov	r0, r4
 80a0834:	f8c7 b004 	str.w	fp, [r7, #4]
 80a0838:	f006 f814 	bl	80a6864 <sqrtf>
 80a083c:	4601      	mov	r1, r0
    soundVolume = sqrt(1048525 - meanSquareValue);
 80a083e:	480d      	ldr	r0, [pc, #52]	; (80a0874 <_Z9readChunkv+0xcc>)
 80a0840:	f006 fd18 	bl	80a7274 <__aeabi_fsub>
 80a0844:	f006 f80e 	bl	80a6864 <sqrtf>
 80a0848:	4a0b      	ldr	r2, [pc, #44]	; (80a0878 <_Z9readChunkv+0xd0>)
 80a084a:	6010      	str	r0, [r2, #0]
 80a084c:	46cd      	mov	sp, r9
  {
    speaker.end();
    FreddyAttackLight = 0xFFFFFF; // Reset special laugh light, just in case
  }

  return retVal;
 80a084e:	687b      	ldr	r3, [r7, #4]
}
 80a0850:	4618      	mov	r0, r3
 80a0852:	370c      	adds	r7, #12
 80a0854:	46bd      	mov	sp, r7
 80a0856:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    speaker.end();
 80a085a:	4805      	ldr	r0, [pc, #20]	; (80a0870 <_Z9readChunkv+0xc8>)
 80a085c:	f003 fc12 	bl	80a4084 <_ZN7Speaker3endEv>
    FreddyAttackLight = 0xFFFFFF; // Reset special laugh light, just in case
 80a0860:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 80a0864:	4b05      	ldr	r3, [pc, #20]	; (80a087c <_Z9readChunkv+0xd4>)
 80a0866:	601a      	str	r2, [r3, #0]
  int retVal = 0;
 80a0868:	4623      	mov	r3, r4
  return retVal;
 80a086a:	e7f1      	b.n	80a0850 <_Z9readChunkv+0xa8>
 80a086c:	200015e4 	.word	0x200015e4
 80a0870:	2000157c 	.word	0x2000157c
 80a0874:	497ffcd0 	.word	0x497ffcd0
 80a0878:	20001578 	.word	0x20001578
 80a087c:	200000a0 	.word	0x200000a0
 80a0880:	200015b0 	.word	0x200015b0

080a0884 <_Z10selectFilePKc>:
int selectFile(const char* filename) {
 80a0884:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (!strcmp("ls", filename) || !strcmp("dir", filename)) {
 80a0888:	4601      	mov	r1, r0
int selectFile(const char* filename) {
 80a088a:	4607      	mov	r7, r0
 80a088c:	b08e      	sub	sp, #56	; 0x38
  if (!strcmp("ls", filename) || !strcmp("dir", filename)) {
 80a088e:	483b      	ldr	r0, [pc, #236]	; (80a097c <_Z10selectFilePKc+0xf8>)
 80a0890:	f007 f889 	bl	80a79a6 <strcmp>
 80a0894:	b120      	cbz	r0, 80a08a0 <_Z10selectFilePKc+0x1c>
 80a0896:	4639      	mov	r1, r7
 80a0898:	4839      	ldr	r0, [pc, #228]	; (80a0980 <_Z10selectFilePKc+0xfc>)
 80a089a:	f007 f884 	bl	80a79a6 <strcmp>
 80a089e:	b9b8      	cbnz	r0, 80a08d0 <_Z10selectFilePKc+0x4c>
   * LS_R - Recursive list of subdirectories.
   *
   * \return true for success or false if an error occurred.
   */
  bool ls(const char* path, uint8_t flags = 0) {
    return ls(&Serial, path, flags);
 80a08a0:	f005 fd2e 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a08a4:	2500      	movs	r5, #0
 80a08a6:	4604      	mov	r4, r0
   *
   * \return true for success or false if an error occurred.
   */
  bool ls(print_t* pr, const char* path, uint8_t flags) {
    FatFile dir;
    return dir.open(vwd(), path, O_RDONLY) && dir.ls(pr, flags);
 80a08a8:	462b      	mov	r3, r5
 80a08aa:	4a36      	ldr	r2, [pc, #216]	; (80a0984 <_Z10selectFilePKc+0x100>)
 80a08ac:	4936      	ldr	r1, [pc, #216]	; (80a0988 <_Z10selectFilePKc+0x104>)
 80a08ae:	a801      	add	r0, sp, #4
 80a08b0:	f8ad 5004 	strh.w	r5, [sp, #4]
 80a08b4:	f000 ff5b 	bl	80a176e <_ZN7FatFile4openEPS_PKci>
 80a08b8:	b128      	cbz	r0, 80a08c6 <_Z10selectFilePKc+0x42>
 80a08ba:	462b      	mov	r3, r5
 80a08bc:	2208      	movs	r2, #8
 80a08be:	4621      	mov	r1, r4
 80a08c0:	a801      	add	r0, sp, #4
 80a08c2:	f001 fc9f 	bl	80a2204 <_ZN7FatFile2lsEP5Printhh>
    return 0;
 80a08c6:	2600      	movs	r6, #0
}
 80a08c8:	4630      	mov	r0, r6
 80a08ca:	b00e      	add	sp, #56	; 0x38
 80a08cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (wavFile.isOpen()) wavFile.close();
 80a08d0:	4b2e      	ldr	r3, [pc, #184]	; (80a098c <_Z10selectFilePKc+0x108>)
 80a08d2:	7c1a      	ldrb	r2, [r3, #16]
 80a08d4:	4698      	mov	r8, r3
 80a08d6:	b11a      	cbz	r2, 80a08e0 <_Z10selectFilePKc+0x5c>
 80a08d8:	f103 0010 	add.w	r0, r3, #16
 80a08dc:	f000 ff40 	bl	80a1760 <_ZN7FatFile5closeEv>
  if(!strcmp(filename, "laugh3.wav")) FreddyAttackLight = 0xFFFF00;
 80a08e0:	4638      	mov	r0, r7
 80a08e2:	492b      	ldr	r1, [pc, #172]	; (80a0990 <_Z10selectFilePKc+0x10c>)
 80a08e4:	f007 f85f 	bl	80a79a6 <strcmp>
 80a08e8:	b910      	cbnz	r0, 80a08f0 <_Z10selectFilePKc+0x6c>
 80a08ea:	4b2a      	ldr	r3, [pc, #168]	; (80a0994 <_Z10selectFilePKc+0x110>)
 80a08ec:	4a2a      	ldr	r2, [pc, #168]	; (80a0998 <_Z10selectFilePKc+0x114>)
 80a08ee:	601a      	str	r2, [r3, #0]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a08f0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a08f4:	2600      	movs	r6, #0
 80a08f6:	9303      	str	r3, [sp, #12]
  File() {}
 80a08f8:	4b28      	ldr	r3, [pc, #160]	; (80a099c <_Z10selectFilePKc+0x118>)
class File : public FatFile, public Stream {
 80a08fa:	4d29      	ldr	r5, [pc, #164]	; (80a09a0 <_Z10selectFilePKc+0x11c>)
    tmpFile.open(vwd(), path, oflag);
 80a08fc:	463a      	mov	r2, r7
 80a08fe:	4922      	ldr	r1, [pc, #136]	; (80a0988 <_Z10selectFilePKc+0x104>)
  File() {}
 80a0900:	9301      	str	r3, [sp, #4]
 80a0902:	a805      	add	r0, sp, #20
 80a0904:	4633      	mov	r3, r6
class File : public FatFile, public Stream {
 80a0906:	ac05      	add	r4, sp, #20
 80a0908:	f8ad 6014 	strh.w	r6, [sp, #20]
    Print() : write_error(0) {}
 80a090c:	9602      	str	r6, [sp, #8]
 80a090e:	f000 ff2e 	bl	80a176e <_ZN7FatFile4openEPS_PKci>
 80a0912:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a0914:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a0916:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a0918:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a091a:	6823      	ldr	r3, [r4, #0]
  if (wavFile) {
 80a091c:	f898 4010 	ldrb.w	r4, [r8, #16]
 80a0920:	602b      	str	r3, [r5, #0]
class Print
 80a0922:	9b02      	ldr	r3, [sp, #8]
 80a0924:	f8c8 3004 	str.w	r3, [r8, #4]
class Stream : public Print
 80a0928:	9b03      	ldr	r3, [sp, #12]
 80a092a:	f8c8 3008 	str.w	r3, [r8, #8]
 80a092e:	9b04      	ldr	r3, [sp, #16]
 80a0930:	f8c8 300c 	str.w	r3, [r8, #12]
 80a0934:	b1dc      	cbz	r4, 80a096e <_Z10selectFilePKc+0xea>
    if (sizeof(wh) == wavFile.read((uint8_t*)&wh, sizeof(wh))) {
 80a0936:	4c1b      	ldr	r4, [pc, #108]	; (80a09a4 <_Z10selectFilePKc+0x120>)
    memset((uint8_t*)data, 0x80, sizeof(data)); // reset buffer to bias value 0x8080 (quicker via memset() than writing 0x8000 in a loop)
 80a0938:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80a093c:	2180      	movs	r1, #128	; 0x80
 80a093e:	481a      	ldr	r0, [pc, #104]	; (80a09a8 <_Z10selectFilePKc+0x124>)
 80a0940:	f006 ffba 	bl	80a78b8 <memset>
    if (sizeof(wh) == wavFile.read((uint8_t*)&wh, sizeof(wh))) {
 80a0944:	222c      	movs	r2, #44	; 0x2c
 80a0946:	4621      	mov	r1, r4
 80a0948:	f1a5 0020 	sub.w	r0, r5, #32
 80a094c:	f000 fd03 	bl	80a1356 <_ZN7FatFile4readEPvj>
 80a0950:	282c      	cmp	r0, #44	; 0x2c
 80a0952:	d1b9      	bne.n	80a08c8 <_Z10selectFilePKc+0x44>
      retVal = wh.data_bytes;
 80a0954:	6aa6      	ldr	r6, [r4, #40]	; 0x28
      readChunk();
 80a0956:	f7ff ff27 	bl	80a07a8 <_Z9readChunkv>
      speaker.begin(wh.sample_rate);
 80a095a:	8b21      	ldrh	r1, [r4, #24]
 80a095c:	4813      	ldr	r0, [pc, #76]	; (80a09ac <_Z10selectFilePKc+0x128>)
 80a095e:	f003 fb8d 	bl	80a407c <_ZN7Speaker5beginEt>
      Log.printf("Playing %s", filename);
 80a0962:	463a      	mov	r2, r7
 80a0964:	4912      	ldr	r1, [pc, #72]	; (80a09b0 <_Z10selectFilePKc+0x12c>)
 80a0966:	4813      	ldr	r0, [pc, #76]	; (80a09b4 <_Z10selectFilePKc+0x130>)
 80a0968:	f7ff fed5 	bl	80a0716 <_ZNK5spark6Logger6printfEPKcz>
 80a096c:	e7ac      	b.n	80a08c8 <_Z10selectFilePKc+0x44>
    Log.error("%s not found", filename);
 80a096e:	463a      	mov	r2, r7
 80a0970:	4911      	ldr	r1, [pc, #68]	; (80a09b8 <_Z10selectFilePKc+0x134>)
 80a0972:	4810      	ldr	r0, [pc, #64]	; (80a09b4 <_Z10selectFilePKc+0x130>)
 80a0974:	f7ff feb8 	bl	80a06e8 <_ZNK5spark6Logger5errorEPKcz>
  int retVal = 0;
 80a0978:	4626      	mov	r6, r4
 80a097a:	e7a5      	b.n	80a08c8 <_Z10selectFilePKc+0x44>
 80a097c:	080a7ca4 	.word	0x080a7ca4
 80a0980:	080a7ca7 	.word	0x080a7ca7
 80a0984:	080a7cab 	.word	0x080a7cab
 80a0988:	20001530 	.word	0x20001530
 80a098c:	200015b0 	.word	0x200015b0
 80a0990:	080a7cad 	.word	0x080a7cad
 80a0994:	200000a0 	.word	0x200000a0
 80a0998:	00ffff00 	.word	0x00ffff00
 80a099c:	080a7df8 	.word	0x080a7df8
 80a09a0:	200015c0 	.word	0x200015c0
 80a09a4:	200015e4 	.word	0x200015e4
 80a09a8:	200000c8 	.word	0x200000c8
 80a09ac:	2000157c 	.word	0x2000157c
 80a09b0:	080a7cb8 	.word	0x080a7cb8
 80a09b4:	20001634 	.word	0x20001634
 80a09b8:	080a7cc3 	.word	0x080a7cc3

080a09bc <_Z10attackModePKc>:
{
 80a09bc:	b570      	push	{r4, r5, r6, lr}
  Log.printf("Attempted attack at brightness %i\n", analogRead(LSPin));
 80a09be:	4e11      	ldr	r6, [pc, #68]	; (80a0a04 <_Z10attackModePKc+0x48>)
  if(!FreddyAttackMode && analogRead(LSPin) > 1000)
 80a09c0:	4c11      	ldr	r4, [pc, #68]	; (80a0a08 <_Z10attackModePKc+0x4c>)
  Log.printf("Attempted attack at brightness %i\n", analogRead(LSPin));
 80a09c2:	8830      	ldrh	r0, [r6, #0]
 80a09c4:	f005 fee1 	bl	80a678a <analogRead>
 80a09c8:	4910      	ldr	r1, [pc, #64]	; (80a0a0c <_Z10attackModePKc+0x50>)
 80a09ca:	4602      	mov	r2, r0
 80a09cc:	4810      	ldr	r0, [pc, #64]	; (80a0a10 <_Z10attackModePKc+0x54>)
 80a09ce:	f7ff fea2 	bl	80a0716 <_ZNK5spark6Logger6printfEPKcz>
  if(!FreddyAttackMode && analogRead(LSPin) > 1000)
 80a09d2:	7825      	ldrb	r5, [r4, #0]
 80a09d4:	b10d      	cbz	r5, 80a09da <_Z10attackModePKc+0x1e>
  int ret = 0;
 80a09d6:	2000      	movs	r0, #0
}
 80a09d8:	bd70      	pop	{r4, r5, r6, pc}
  if(!FreddyAttackMode && analogRead(LSPin) > 1000)
 80a09da:	8830      	ldrh	r0, [r6, #0]
 80a09dc:	f005 fed5 	bl	80a678a <analogRead>
 80a09e0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80a09e4:	dd06      	ble.n	80a09f4 <_Z10attackModePKc+0x38>
    FreddyAttackMode = ret = true;
 80a09e6:	2001      	movs	r0, #1
    FreddyAttackState = whenToActivate = 0;
 80a09e8:	4b0a      	ldr	r3, [pc, #40]	; (80a0a14 <_Z10attackModePKc+0x58>)
    FreddyAttackMode = ret = true;
 80a09ea:	7020      	strb	r0, [r4, #0]
    FreddyAttackState = whenToActivate = 0;
 80a09ec:	601d      	str	r5, [r3, #0]
 80a09ee:	4b0a      	ldr	r3, [pc, #40]	; (80a0a18 <_Z10attackModePKc+0x5c>)
 80a09f0:	601d      	str	r5, [r3, #0]
  return ret;
 80a09f2:	e7f1      	b.n	80a09d8 <_Z10attackModePKc+0x1c>
  else if(!FreddyAttackMode)
 80a09f4:	7824      	ldrb	r4, [r4, #0]
 80a09f6:	2c00      	cmp	r4, #0
 80a09f8:	d1ed      	bne.n	80a09d6 <_Z10attackModePKc+0x1a>
    selectFile("block.wav");
 80a09fa:	4808      	ldr	r0, [pc, #32]	; (80a0a1c <_Z10attackModePKc+0x60>)
 80a09fc:	f7ff ff42 	bl	80a0884 <_Z10selectFilePKc>
  int ret = 0;
 80a0a00:	4620      	mov	r0, r4
  return ret;
 80a0a02:	e7e9      	b.n	80a09d8 <_Z10attackModePKc+0x1c>
 80a0a04:	20000004 	.word	0x20000004
 80a0a08:	200000a4 	.word	0x200000a4
 80a0a0c:	080a7cd0 	.word	0x080a7cd0
 80a0a10:	20001634 	.word	0x20001634
 80a0a14:	20001610 	.word	0x20001610
 80a0a18:	200000a8 	.word	0x200000a8
 80a0a1c:	080a7cf3 	.word	0x080a7cf3

080a0a20 <loop>:
void loop() {
 80a0a20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FreddyNoseState = digitalRead(FREDDY_NOSE_PIN);
 80a0a24:	2005      	movs	r0, #5
void loop() {
 80a0a26:	b08d      	sub	sp, #52	; 0x34
  FreddyNoseState = digitalRead(FREDDY_NOSE_PIN);
 80a0a28:	f005 fe9c 	bl	80a6764 <digitalRead>
 80a0a2c:	3800      	subs	r0, #0
 80a0a2e:	bf18      	it	ne
 80a0a30:	2001      	movne	r0, #1
 80a0a32:	4cad      	ldr	r4, [pc, #692]	; (80a0ce8 <loop+0x2c8>)
 80a0a34:	7020      	strb	r0, [r4, #0]
  if(speaker.ready())
 80a0a36:	48ad      	ldr	r0, [pc, #692]	; (80a0cec <loop+0x2cc>)
 80a0a38:	f003 fb34 	bl	80a40a4 <_ZN7Speaker5readyEv>
 80a0a3c:	46a3      	mov	fp, r4
 80a0a3e:	b108      	cbz	r0, 80a0a44 <loop+0x24>
    readChunk();
 80a0a40:	f7ff feb2 	bl	80a07a8 <_Z9readChunkv>
  if(!FreddyAttackMode) // Regular headlamp functionality
 80a0a44:	4baa      	ldr	r3, [pc, #680]	; (80a0cf0 <loop+0x2d0>)
 80a0a46:	4dab      	ldr	r5, [pc, #684]	; (80a0cf4 <loop+0x2d4>)
 80a0a48:	781a      	ldrb	r2, [r3, #0]
 80a0a4a:	4698      	mov	r8, r3
 80a0a4c:	4caa      	ldr	r4, [pc, #680]	; (80a0cf8 <loop+0x2d8>)
 80a0a4e:	2a00      	cmp	r2, #0
 80a0a50:	f040 80dc 	bne.w	80a0c0c <loop+0x1ec>
    double angleToAimFor = wavFile.isOpen() ? soundVolume / 20.0 : 5.0;
 80a0a54:	4ba9      	ldr	r3, [pc, #676]	; (80a0cfc <loop+0x2dc>)
 80a0a56:	7c1e      	ldrb	r6, [r3, #16]
 80a0a58:	2e00      	cmp	r6, #0
 80a0a5a:	f000 80cd 	beq.w	80a0bf8 <loop+0x1d8>
 80a0a5e:	4ba8      	ldr	r3, [pc, #672]	; (80a0d00 <loop+0x2e0>)
 80a0a60:	6818      	ldr	r0, [r3, #0]
 80a0a62:	f006 f90b 	bl	80a6c7c <__aeabi_f2d>
 80a0a66:	2200      	movs	r2, #0
 80a0a68:	4ba6      	ldr	r3, [pc, #664]	; (80a0d04 <loop+0x2e4>)
 80a0a6a:	f006 fa89 	bl	80a6f80 <__aeabi_ddiv>
 80a0a6e:	4680      	mov	r8, r0
 80a0a70:	4689      	mov	r9, r1
    return m_attr;
 80a0a72:	3e00      	subs	r6, #0
 80a0a74:	bf18      	it	ne
 80a0a76:	2601      	movne	r6, #1
    Log.printf("%f // %i // %f\n", angleToAimFor, wavFile.isOpen(), currentAngle);
 80a0a78:	f8df a2d0 	ldr.w	sl, [pc, #720]	; 80a0d4c <loop+0x32c>
 80a0a7c:	49a2      	ldr	r1, [pc, #648]	; (80a0d08 <loop+0x2e8>)
 80a0a7e:	e9da 2300 	ldrd	r2, r3, [sl]
 80a0a82:	48a2      	ldr	r0, [pc, #648]	; (80a0d0c <loop+0x2ec>)
 80a0a84:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80a0a88:	9600      	str	r6, [sp, #0]
 80a0a8a:	4642      	mov	r2, r8
 80a0a8c:	464b      	mov	r3, r9
 80a0a8e:	f7ff fe42 	bl	80a0716 <_ZNK5spark6Logger6printfEPKcz>
    currentAngle = lerp(currentAngle, angleToAimFor, (millis() - lastMillis)/70.0);
 80a0a92:	e9da 2300 	ldrd	r2, r3, [sl]
 80a0a96:	e9cd 2304 	strd	r2, r3, [sp, #16]

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a0a9a:	f003 fb59 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
 80a0a9e:	682b      	ldr	r3, [r5, #0]
 80a0aa0:	1ac0      	subs	r0, r0, r3
 80a0aa2:	f006 f8c9 	bl	80a6c38 <__aeabi_ui2d>
 80a0aa6:	2200      	movs	r2, #0
 80a0aa8:	4b99      	ldr	r3, [pc, #612]	; (80a0d10 <loop+0x2f0>)
 80a0aaa:	f006 fa69 	bl	80a6f80 <__aeabi_ddiv>
  double res = a + ((b - a) * t);
 80a0aae:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    currentAngle = lerp(currentAngle, angleToAimFor, (millis() - lastMillis)/70.0);
 80a0ab2:	4606      	mov	r6, r0
 80a0ab4:	460f      	mov	r7, r1
  double res = a + ((b - a) * t);
 80a0ab6:	4640      	mov	r0, r8
 80a0ab8:	4649      	mov	r1, r9
 80a0aba:	f005 ff7f 	bl	80a69bc <__aeabi_dsub>
 80a0abe:	4602      	mov	r2, r0
 80a0ac0:	460b      	mov	r3, r1
 80a0ac2:	4630      	mov	r0, r6
 80a0ac4:	4639      	mov	r1, r7
 80a0ac6:	f006 f931 	bl	80a6d2c <__aeabi_dmul>
 80a0aca:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80a0ace:	f005 ff77 	bl	80a69c0 <__adddf3>
  if (isnan(a) || isnan(b)) {b = 5;}
 80a0ad2:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  double res = a + ((b - a) * t);
 80a0ad6:	4606      	mov	r6, r0
 80a0ad8:	460f      	mov	r7, r1
  if (isnan(a) || isnan(b)) {b = 5;}
 80a0ada:	4610      	mov	r0, r2
 80a0adc:	4619      	mov	r1, r3
 80a0ade:	f006 fb37 	bl	80a7150 <__aeabi_dcmpun>
 80a0ae2:	2800      	cmp	r0, #0
 80a0ae4:	f040 808d 	bne.w	80a0c02 <loop+0x1e2>
 80a0ae8:	4642      	mov	r2, r8
 80a0aea:	464b      	mov	r3, r9
 80a0aec:	4640      	mov	r0, r8
 80a0aee:	4649      	mov	r1, r9
 80a0af0:	f006 fb2e 	bl	80a7150 <__aeabi_dcmpun>
 80a0af4:	2800      	cmp	r0, #0
 80a0af6:	f040 8084 	bne.w	80a0c02 <loop+0x1e2>
 80a0afa:	e9cd 8904 	strd	r8, r9, [sp, #16]
  if (isnan(res)) {res = b;}
 80a0afe:	4632      	mov	r2, r6
 80a0b00:	463b      	mov	r3, r7
 80a0b02:	4630      	mov	r0, r6
 80a0b04:	4639      	mov	r1, r7
 80a0b06:	f006 fb23 	bl	80a7150 <__aeabi_dcmpun>
 80a0b0a:	b108      	cbz	r0, 80a0b10 <loop+0xf0>
 80a0b0c:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    if (isnan(currentAngle)) currentAngle = angleToAimFor;
 80a0b10:	4632      	mov	r2, r6
 80a0b12:	463b      	mov	r3, r7
 80a0b14:	4630      	mov	r0, r6
 80a0b16:	4639      	mov	r1, r7
    currentAngle = lerp(currentAngle, angleToAimFor, (millis() - lastMillis)/70.0);
 80a0b18:	e9ca 6700 	strd	r6, r7, [sl]
    if (isnan(currentAngle)) currentAngle = angleToAimFor;
 80a0b1c:	f006 fb18 	bl	80a7150 <__aeabi_dcmpun>
 80a0b20:	b108      	cbz	r0, 80a0b26 <loop+0x106>
 80a0b22:	e9ca 8900 	strd	r8, r9, [sl]
    FreddyJaw.write(currentAngle);
 80a0b26:	e9da 0100 	ldrd	r0, r1, [sl]
 80a0b2a:	f006 fb27 	bl	80a717c <__aeabi_d2iz>
 80a0b2e:	4601      	mov	r1, r0
 80a0b30:	4878      	ldr	r0, [pc, #480]	; (80a0d14 <loop+0x2f4>)
 80a0b32:	f005 f912 	bl	80a5d5a <_ZN5Servo5writeEi>
    if(FreddyNoseState == HIGH && oldFreddyNoseState == LOW)
 80a0b36:	f89b 3000 	ldrb.w	r3, [fp]
 80a0b3a:	b14b      	cbz	r3, 80a0b50 <loop+0x130>
 80a0b3c:	4b76      	ldr	r3, [pc, #472]	; (80a0d18 <loop+0x2f8>)
 80a0b3e:	781b      	ldrb	r3, [r3, #0]
 80a0b40:	b933      	cbnz	r3, 80a0b50 <loop+0x130>
      selectFile("honk.wav");
 80a0b42:	4876      	ldr	r0, [pc, #472]	; (80a0d1c <loop+0x2fc>)
 80a0b44:	f7ff fe9e 	bl	80a0884 <_Z10selectFilePKc>
      FreddyLightOn = !FreddyLightOn;
 80a0b48:	7823      	ldrb	r3, [r4, #0]
 80a0b4a:	f083 0301 	eor.w	r3, r3, #1
 80a0b4e:	7023      	strb	r3, [r4, #0]
 80a0b50:	f003 fafe 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
    if(millis() > whenToActivate)
 80a0b54:	4e72      	ldr	r6, [pc, #456]	; (80a0d20 <loop+0x300>)
 80a0b56:	6833      	ldr	r3, [r6, #0]
 80a0b58:	4283      	cmp	r3, r0
 80a0b5a:	d238      	bcs.n	80a0bce <loop+0x1ae>
      int index = (rand() % 31)/10;
 80a0b5c:	f006 fed8 	bl	80a7910 <rand>
      char laughPath[] = "laughN.wav";
 80a0b60:	4a70      	ldr	r2, [pc, #448]	; (80a0d24 <loop+0x304>)
      int index = (rand() % 31)/10;
 80a0b62:	4607      	mov	r7, r0
      char laughPath[] = "laughN.wav";
 80a0b64:	6851      	ldr	r1, [r2, #4]
 80a0b66:	6810      	ldr	r0, [r2, #0]
 80a0b68:	ab09      	add	r3, sp, #36	; 0x24
 80a0b6a:	c303      	stmia	r3!, {r0, r1}
 80a0b6c:	8911      	ldrh	r1, [r2, #8]
 80a0b6e:	7a92      	ldrb	r2, [r2, #10]
 80a0b70:	8019      	strh	r1, [r3, #0]
      strcpy(fileName, "laugh");
 80a0b72:	a807      	add	r0, sp, #28
 80a0b74:	496c      	ldr	r1, [pc, #432]	; (80a0d28 <loop+0x308>)
      char laughPath[] = "laughN.wav";
 80a0b76:	709a      	strb	r2, [r3, #2]
      strcpy(fileName, "laugh");
 80a0b78:	f006 ff1f 	bl	80a79ba <strcpy>
      strncat(fileName, itoa(index, new char[2], 10), 1);
 80a0b7c:	2002      	movs	r0, #2
 80a0b7e:	f7ff fa8c 	bl	80a009a <_Znaj>
      int index = (rand() % 31)/10;
 80a0b82:	231f      	movs	r3, #31
 80a0b84:	fb97 f3f3 	sdiv	r3, r7, r3
      strncat(fileName, itoa(index, new char[2], 10), 1);
 80a0b88:	220a      	movs	r2, #10
      int index = (rand() % 31)/10;
 80a0b8a:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 80a0b8e:	1afb      	subs	r3, r7, r3
      strncat(fileName, itoa(index, new char[2], 10), 1);
 80a0b90:	4601      	mov	r1, r0
 80a0b92:	fb93 f0f2 	sdiv	r0, r3, r2
 80a0b96:	f005 fcac 	bl	80a64f2 <itoa>
 80a0b9a:	2201      	movs	r2, #1
 80a0b9c:	4601      	mov	r1, r0
 80a0b9e:	a807      	add	r0, sp, #28
 80a0ba0:	f006 ff1b 	bl	80a79da <strncat>
      strncpy(laughPath, fileName, 6);
 80a0ba4:	2206      	movs	r2, #6
 80a0ba6:	a907      	add	r1, sp, #28
 80a0ba8:	a809      	add	r0, sp, #36	; 0x24
 80a0baa:	f006 ff3b 	bl	80a7a24 <strncpy>
      selectFile(laughPath);
 80a0bae:	a809      	add	r0, sp, #36	; 0x24
 80a0bb0:	f7ff fe68 	bl	80a0884 <_Z10selectFilePKc>
      whenToActivate += rand() % 100000 + 5000;
 80a0bb4:	f006 feac 	bl	80a7910 <rand>
 80a0bb8:	4b5c      	ldr	r3, [pc, #368]	; (80a0d2c <loop+0x30c>)
 80a0bba:	fb90 f2f3 	sdiv	r2, r0, r3
 80a0bbe:	fb02 0013 	mls	r0, r2, r3, r0
 80a0bc2:	6833      	ldr	r3, [r6, #0]
 80a0bc4:	f500 509c 	add.w	r0, r0, #4992	; 0x1380
 80a0bc8:	3008      	adds	r0, #8
 80a0bca:	4418      	add	r0, r3
 80a0bcc:	6030      	str	r0, [r6, #0]
    strip.setPixelColor(0, (FreddyLightOn ? FreddyAttackLight : 0x000000));
 80a0bce:	7822      	ldrb	r2, [r4, #0]
 80a0bd0:	b10a      	cbz	r2, 80a0bd6 <loop+0x1b6>
 80a0bd2:	4b57      	ldr	r3, [pc, #348]	; (80a0d30 <loop+0x310>)
 80a0bd4:	681a      	ldr	r2, [r3, #0]
 80a0bd6:	2100      	movs	r1, #0
 80a0bd8:	4856      	ldr	r0, [pc, #344]	; (80a0d34 <loop+0x314>)
 80a0bda:	f003 f973 	bl	80a3ec4 <_ZN17Adafruit_NeoPixel13setPixelColorEtm>
  strip.show();
 80a0bde:	4855      	ldr	r0, [pc, #340]	; (80a0d34 <loop+0x314>)
 80a0be0:	f002 f8c0 	bl	80a2d64 <_ZN17Adafruit_NeoPixel4showEv>
  oldFreddyNoseState = FreddyNoseState;
 80a0be4:	f89b 3000 	ldrb.w	r3, [fp]
 80a0be8:	4a4b      	ldr	r2, [pc, #300]	; (80a0d18 <loop+0x2f8>)
 80a0bea:	7013      	strb	r3, [r2, #0]
 80a0bec:	f003 fab0 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
  lastMillis = millis();
 80a0bf0:	6028      	str	r0, [r5, #0]
}
 80a0bf2:	b00d      	add	sp, #52	; 0x34
 80a0bf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    double angleToAimFor = wavFile.isOpen() ? soundVolume / 20.0 : 5.0;
 80a0bf8:	f04f 0800 	mov.w	r8, #0
 80a0bfc:	f8df 9138 	ldr.w	r9, [pc, #312]	; 80a0d38 <loop+0x318>
 80a0c00:	e737      	b.n	80a0a72 <loop+0x52>
  if (isnan(a) || isnan(b)) {b = 5;}
 80a0c02:	2200      	movs	r2, #0
 80a0c04:	4b4c      	ldr	r3, [pc, #304]	; (80a0d38 <loop+0x318>)
 80a0c06:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80a0c0a:	e778      	b.n	80a0afe <loop+0xde>
 80a0c0c:	f003 faa0 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
    if(millis() > whenToActivate)
 80a0c10:	4f43      	ldr	r7, [pc, #268]	; (80a0d20 <loop+0x300>)
 80a0c12:	4e4a      	ldr	r6, [pc, #296]	; (80a0d3c <loop+0x31c>)
 80a0c14:	683b      	ldr	r3, [r7, #0]
 80a0c16:	4283      	cmp	r3, r0
 80a0c18:	d22a      	bcs.n	80a0c70 <loop+0x250>
      switch(FreddyAttackState)
 80a0c1a:	6833      	ldr	r3, [r6, #0]
 80a0c1c:	2b07      	cmp	r3, #7
 80a0c1e:	d827      	bhi.n	80a0c70 <loop+0x250>
 80a0c20:	e8df f013 	tbh	[pc, r3, lsl #1]
 80a0c24:	003f0008 	.word	0x003f0008
 80a0c28:	00960049 	.word	0x00960049
 80a0c2c:	00c400b8 	.word	0x00c400b8
 80a0c30:	00e900d7 	.word	0x00e900d7
          FreddyJaw.write(0);
 80a0c34:	4837      	ldr	r0, [pc, #220]	; (80a0d14 <loop+0x2f4>)
 80a0c36:	2100      	movs	r1, #0
 80a0c38:	f005 f88f 	bl	80a5d5a <_ZN5Servo5writeEi>
          FreddyLightOn = false;
 80a0c3c:	2300      	movs	r3, #0
          selectFile("powerdown.wav");
 80a0c3e:	4840      	ldr	r0, [pc, #256]	; (80a0d40 <loop+0x320>)
          FreddyLightOn = false;
 80a0c40:	7023      	strb	r3, [r4, #0]
          selectFile("powerdown.wav");
 80a0c42:	f7ff fe1f 	bl	80a0884 <_Z10selectFilePKc>
 80a0c46:	f003 fa83 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
 80a0c4a:	4680      	mov	r8, r0
          whenToActivate = millis() + 5000 + (rand() % 4) * 5000;
 80a0c4c:	f006 fe60 	bl	80a7910 <rand>
 80a0c50:	4242      	negs	r2, r0
 80a0c52:	f000 0303 	and.w	r3, r0, #3
 80a0c56:	f241 3088 	movw	r0, #5000	; 0x1388
 80a0c5a:	f002 0203 	and.w	r2, r2, #3
 80a0c5e:	bf58      	it	pl
 80a0c60:	4253      	negpl	r3, r2
 80a0c62:	4480      	add	r8, r0
 80a0c64:	fb00 8303 	mla	r3, r0, r3, r8
 80a0c68:	603b      	str	r3, [r7, #0]
          FreddyAttackState++;
 80a0c6a:	6833      	ldr	r3, [r6, #0]
 80a0c6c:	3301      	adds	r3, #1
 80a0c6e:	6033      	str	r3, [r6, #0]
    strip.setPixelColor(0, (FreddyLightOn ? FreddyAttackLight : 0x000000));
 80a0c70:	7822      	ldrb	r2, [r4, #0]
 80a0c72:	b10a      	cbz	r2, 80a0c78 <loop+0x258>
 80a0c74:	4b2e      	ldr	r3, [pc, #184]	; (80a0d30 <loop+0x310>)
 80a0c76:	681a      	ldr	r2, [r3, #0]
 80a0c78:	2100      	movs	r1, #0
 80a0c7a:	482e      	ldr	r0, [pc, #184]	; (80a0d34 <loop+0x314>)
 80a0c7c:	f003 f922 	bl	80a3ec4 <_ZN17Adafruit_NeoPixel13setPixelColorEtm>
    if(FreddyAttackState == 2 && !(rand() % 10)) {FreddyLightOn = !FreddyLightOn;}
 80a0c80:	6833      	ldr	r3, [r6, #0]
 80a0c82:	2b02      	cmp	r3, #2
 80a0c84:	d1ab      	bne.n	80a0bde <loop+0x1be>
 80a0c86:	f006 fe43 	bl	80a7910 <rand>
 80a0c8a:	230a      	movs	r3, #10
 80a0c8c:	fb90 f2f3 	sdiv	r2, r0, r3
 80a0c90:	fb02 0313 	mls	r3, r2, r3, r0
 80a0c94:	2b00      	cmp	r3, #0
 80a0c96:	d1a2      	bne.n	80a0bde <loop+0x1be>
 80a0c98:	7823      	ldrb	r3, [r4, #0]
 80a0c9a:	f083 0301 	eor.w	r3, r3, #1
 80a0c9e:	7023      	strb	r3, [r4, #0]
 80a0ca0:	e79d      	b.n	80a0bde <loop+0x1be>
          selectFile("toreador.wav");  
 80a0ca2:	4828      	ldr	r0, [pc, #160]	; (80a0d44 <loop+0x324>)
 80a0ca4:	f7ff fdee 	bl	80a0884 <_Z10selectFilePKc>
          FreddyLightOn = true; FreddyAttackLight = 0xFFFFFF;
 80a0ca8:	2301      	movs	r3, #1
 80a0caa:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 80a0cae:	7023      	strb	r3, [r4, #0]
 80a0cb0:	4b1f      	ldr	r3, [pc, #124]	; (80a0d30 <loop+0x310>)
 80a0cb2:	601a      	str	r2, [r3, #0]
 80a0cb4:	e7c7      	b.n	80a0c46 <loop+0x226>
          selectFile("flicker.wav"); FreddyLightOn = false;
 80a0cb6:	4824      	ldr	r0, [pc, #144]	; (80a0d48 <loop+0x328>)
 80a0cb8:	f7ff fde4 	bl	80a0884 <_Z10selectFilePKc>
 80a0cbc:	2300      	movs	r3, #0
 80a0cbe:	7023      	strb	r3, [r4, #0]
 80a0cc0:	f003 fa46 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
 80a0cc4:	4680      	mov	r8, r0
          whenToActivate = millis() + 2000 + (rand() % 4000);
 80a0cc6:	f006 fe23 	bl	80a7910 <rand>
 80a0cca:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 80a0cce:	fb90 f2f3 	sdiv	r2, r0, r3
 80a0cd2:	fb02 0313 	mls	r3, r2, r3, r0
 80a0cd6:	f508 68fa 	add.w	r8, r8, #2000	; 0x7d0
 80a0cda:	4443      	add	r3, r8
 80a0cdc:	603b      	str	r3, [r7, #0]
          FreddyAttackState++;
 80a0cde:	6833      	ldr	r3, [r6, #0]
 80a0ce0:	3301      	adds	r3, #1
 80a0ce2:	6033      	str	r3, [r6, #0]
          break;
 80a0ce4:	e7c4      	b.n	80a0c70 <loop+0x250>
 80a0ce6:	bf00      	nop
 80a0ce8:	200000bc 	.word	0x200000bc
 80a0cec:	2000157c 	.word	0x2000157c
 80a0cf0:	200000a4 	.word	0x200000a4
 80a0cf4:	200010c8 	.word	0x200010c8
 80a0cf8:	20000000 	.word	0x20000000
 80a0cfc:	200015b0 	.word	0x200015b0
 80a0d00:	20001578 	.word	0x20001578
 80a0d04:	40340000 	.word	0x40340000
 80a0d08:	080a7cfd 	.word	0x080a7cfd
 80a0d0c:	20001634 	.word	0x20001634
 80a0d10:	40518000 	.word	0x40518000
 80a0d14:	200000ac 	.word	0x200000ac
 80a0d18:	200010f0 	.word	0x200010f0
 80a0d1c:	080a7d0d 	.word	0x080a7d0d
 80a0d20:	20001610 	.word	0x20001610
 80a0d24:	080a7d67 	.word	0x080a7d67
 80a0d28:	080a7d16 	.word	0x080a7d16
 80a0d2c:	000186a0 	.word	0x000186a0
 80a0d30:	200000a0 	.word	0x200000a0
 80a0d34:	2000158c 	.word	0x2000158c
 80a0d38:	40140000 	.word	0x40140000
 80a0d3c:	200000a8 	.word	0x200000a8
 80a0d40:	080a7d1c 	.word	0x080a7d1c
 80a0d44:	080a7d2a 	.word	0x080a7d2a
 80a0d48:	080a7d37 	.word	0x080a7d37
 80a0d4c:	200000c0 	.word	0x200000c0
          selectFile("footsteps.wav");
 80a0d50:	4836      	ldr	r0, [pc, #216]	; (80a0e2c <loop+0x40c>)
 80a0d52:	f7ff fd97 	bl	80a0884 <_Z10selectFilePKc>
 80a0d56:	f003 f9fb 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
 80a0d5a:	4680      	mov	r8, r0
          whenToActivate = millis() + 2000 + (rand() % (rand() % 8 + 2)) * 2000;
 80a0d5c:	f006 fdd8 	bl	80a7910 <rand>
 80a0d60:	4681      	mov	r9, r0
 80a0d62:	f006 fdd5 	bl	80a7910 <rand>
 80a0d66:	4242      	negs	r2, r0
 80a0d68:	f002 0207 	and.w	r2, r2, #7
 80a0d6c:	f000 0307 	and.w	r3, r0, #7
 80a0d70:	bf58      	it	pl
 80a0d72:	4253      	negpl	r3, r2
 80a0d74:	3302      	adds	r3, #2
 80a0d76:	fb99 f0f3 	sdiv	r0, r9, r3
 80a0d7a:	fb03 9310 	mls	r3, r3, r0, r9
 80a0d7e:	f44f 69fa 	mov.w	r9, #2000	; 0x7d0
 80a0d82:	f508 68fa 	add.w	r8, r8, #2000	; 0x7d0
 80a0d86:	fb09 8303 	mla	r3, r9, r3, r8
 80a0d8a:	603b      	str	r3, [r7, #0]
          FreddyAttackState++;
 80a0d8c:	6833      	ldr	r3, [r6, #0]
 80a0d8e:	3301      	adds	r3, #1
 80a0d90:	6033      	str	r3, [r6, #0]
          break;
 80a0d92:	e76d      	b.n	80a0c70 <loop+0x250>
          selectFile("scream.wav");          
 80a0d94:	4826      	ldr	r0, [pc, #152]	; (80a0e30 <loop+0x410>)
 80a0d96:	f7ff fd75 	bl	80a0884 <_Z10selectFilePKc>
          FreddyAttackState++;
 80a0d9a:	6833      	ldr	r3, [r6, #0]
 80a0d9c:	3301      	adds	r3, #1
 80a0d9e:	6033      	str	r3, [r6, #0]
 80a0da0:	f003 f9d6 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
          whenToActivate = millis() + 360;
 80a0da4:	f500 70b4 	add.w	r0, r0, #360	; 0x168
 80a0da8:	6038      	str	r0, [r7, #0]
          break;
 80a0daa:	e761      	b.n	80a0c70 <loop+0x250>
          FreddyLightOn = true; FreddyAttackLight = 0x00FF00;
 80a0dac:	2301      	movs	r3, #1
 80a0dae:	f44f 427f 	mov.w	r2, #65280	; 0xff00
 80a0db2:	7023      	strb	r3, [r4, #0]
 80a0db4:	4b1f      	ldr	r3, [pc, #124]	; (80a0e34 <loop+0x414>)
          FreddyJaw.write(40);
 80a0db6:	2128      	movs	r1, #40	; 0x28
 80a0db8:	481f      	ldr	r0, [pc, #124]	; (80a0e38 <loop+0x418>)
          FreddyLightOn = true; FreddyAttackLight = 0x00FF00;
 80a0dba:	601a      	str	r2, [r3, #0]
          FreddyJaw.write(40);
 80a0dbc:	f004 ffcd 	bl	80a5d5a <_ZN5Servo5writeEi>
 80a0dc0:	f003 f9c6 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
          FreddyAttackState++;
 80a0dc4:	6833      	ldr	r3, [r6, #0]
          whenToActivate = millis() + 1000;
 80a0dc6:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
          FreddyAttackState++;
 80a0dca:	3301      	adds	r3, #1
          whenToActivate = millis() + 1000;
 80a0dcc:	6038      	str	r0, [r7, #0]
          FreddyAttackState++;
 80a0dce:	6033      	str	r3, [r6, #0]
          break;
 80a0dd0:	e74e      	b.n	80a0c70 <loop+0x250>
          FreddyAttackState++;
 80a0dd2:	2307      	movs	r3, #7
          FreddyJaw.write(0);
 80a0dd4:	2100      	movs	r1, #0
 80a0dd6:	4818      	ldr	r0, [pc, #96]	; (80a0e38 <loop+0x418>)
          FreddyAttackState++;
 80a0dd8:	6033      	str	r3, [r6, #0]
          FreddyJaw.write(0);
 80a0dda:	f004 ffbe 	bl	80a5d5a <_ZN5Servo5writeEi>
          selectFile("static.wav");
 80a0dde:	4817      	ldr	r0, [pc, #92]	; (80a0e3c <loop+0x41c>)
 80a0de0:	f7ff fd50 	bl	80a0884 <_Z10selectFilePKc>
          FreddyLightOn = false;
 80a0de4:	2300      	movs	r3, #0
 80a0de6:	7023      	strb	r3, [r4, #0]
 80a0de8:	f003 f9b2 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
          whenToActivate = millis() + 10000;
 80a0dec:	f500 501c 	add.w	r0, r0, #9984	; 0x2700
 80a0df0:	3010      	adds	r0, #16
 80a0df2:	6038      	str	r0, [r7, #0]
          break;
 80a0df4:	e73c      	b.n	80a0c70 <loop+0x250>
          FreddyAttackState = 0;
 80a0df6:	2300      	movs	r3, #0
          FreddyAttackMode = false;
 80a0df8:	f888 3000 	strb.w	r3, [r8]
          FreddyAttackState = 0;
 80a0dfc:	6033      	str	r3, [r6, #0]
          FreddyLightOn = true; FreddyAttackLight = 0xFFFFFF;
 80a0dfe:	2301      	movs	r3, #1
 80a0e00:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 80a0e04:	7023      	strb	r3, [r4, #0]
 80a0e06:	4b0b      	ldr	r3, [pc, #44]	; (80a0e34 <loop+0x414>)
 80a0e08:	601a      	str	r2, [r3, #0]
 80a0e0a:	f003 f9a1 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
 80a0e0e:	4680      	mov	r8, r0
          whenToActivate = millis() + (rand() % 100000 + 5000);
 80a0e10:	f006 fd7e 	bl	80a7910 <rand>
 80a0e14:	4b0a      	ldr	r3, [pc, #40]	; (80a0e40 <loop+0x420>)
 80a0e16:	fb90 f2f3 	sdiv	r2, r0, r3
 80a0e1a:	fb02 0313 	mls	r3, r2, r3, r0
 80a0e1e:	f508 509c 	add.w	r0, r8, #4992	; 0x1380
 80a0e22:	3008      	adds	r0, #8
 80a0e24:	4418      	add	r0, r3
 80a0e26:	6038      	str	r0, [r7, #0]
          break;
 80a0e28:	e722      	b.n	80a0c70 <loop+0x250>
 80a0e2a:	bf00      	nop
 80a0e2c:	080a7d43 	.word	0x080a7d43
 80a0e30:	080a7d51 	.word	0x080a7d51
 80a0e34:	200000a0 	.word	0x200000a0
 80a0e38:	200000ac 	.word	0x200000ac
 80a0e3c:	080a7d5c 	.word	0x080a7d5c
 80a0e40:	000186a0 	.word	0x000186a0

080a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a0e44:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
 80a0e46:	2614      	movs	r6, #20
 80a0e48:	e9d0 5300 	ldrd	r5, r3, [r0]
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a0e4c:	4604      	mov	r4, r0
    destruct(data_, data_ + size_);
 80a0e4e:	fb06 5603 	mla	r6, r6, r3, r5
        for (; p != end; ++p) {
 80a0e52:	42ae      	cmp	r6, r5
 80a0e54:	d004      	beq.n	80a0e60 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev+0x1c>
class LogCategoryFilter {
 80a0e56:	4628      	mov	r0, r5
 80a0e58:	f005 f8a7 	bl	80a5faa <_ZN6StringD1Ev>
 80a0e5c:	3514      	adds	r5, #20
 80a0e5e:	e7f8      	b.n	80a0e52 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev+0xe>
    ::free(ptr);
 80a0e60:	6820      	ldr	r0, [r4, #0]
 80a0e62:	f003 fba3 	bl	80a45ac <free>
    AllocatorT::free(data_);
}
 80a0e66:	4620      	mov	r0, r4
 80a0e68:	bd70      	pop	{r4, r5, r6, pc}
	...

080a0e6c <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_>:
        static_assert(sizeof(T)==0, "\n\nIn Particle.variable(\"name\", myVar, STRING); myVar must be declared as char myVar[] not String myVar\n\n");
        return false;
    }

    template <typename T, class ... Types>
    static inline bool function(const T &name, Types ... args)
 80a0e6c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    _Function_base() : _M_manager(nullptr) { }
 80a0e6e:	2600      	movs	r6, #0
 80a0e70:	4605      	mov	r5, r0
 80a0e72:	9602      	str	r6, [sp, #8]
      function(_Functor __f)
      : _Function_base()
      {
	typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
 80a0e74:	b1d1      	cbz	r1, 80a0eac <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x40>
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a0e76:	4b12      	ldr	r3, [pc, #72]	; (80a0ec0 <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x54>)
    static bool _function(const char *funcKey, user_std_function_int_str_t func, void* reserved=NULL)
    {
        bool success = false;
        if (func) // if the call-wrapper has wrapped a callable object
        {
            auto wrapper = new user_std_function_int_str_t(func);
 80a0e78:	2010      	movs	r0, #16
 80a0e7a:	9303      	str	r3, [sp, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a0e7c:	4b11      	ldr	r3, [pc, #68]	; (80a0ec4 <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x58>)
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a0e7e:	9100      	str	r1, [sp, #0]
	    _M_manager = &_My_handler::_M_manager;
 80a0e80:	9302      	str	r3, [sp, #8]
 80a0e82:	f7ff f908 	bl	80a0096 <_Znwj>
 80a0e86:	4604      	mov	r4, r0
 80a0e88:	b180      	cbz	r0, 80a0eac <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x40>
      { return !_M_empty(); }
 80a0e8a:	9b02      	ldr	r3, [sp, #8]
    _Function_base() : _M_manager(nullptr) { }
 80a0e8c:	6086      	str	r6, [r0, #8]
      if (static_cast<bool>(__x))
 80a0e8e:	b133      	cbz	r3, 80a0e9e <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x32>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a0e90:	2202      	movs	r2, #2
 80a0e92:	4669      	mov	r1, sp
 80a0e94:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a0e96:	9b03      	ldr	r3, [sp, #12]
 80a0e98:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a0e9a:	9b02      	ldr	r3, [sp, #8]
 80a0e9c:	60a3      	str	r3, [r4, #8]
            if (wrapper) {
                success = register_function(call_std_user_function, wrapper, funcKey);
 80a0e9e:	4621      	mov	r1, r4
 80a0ea0:	462a      	mov	r2, r5
 80a0ea2:	4809      	ldr	r0, [pc, #36]	; (80a0ec8 <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x5c>)
 80a0ea4:	f003 fbd2 	bl	80a464c <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0ea8:	4604      	mov	r4, r0
 80a0eaa:	e000      	b.n	80a0eae <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x42>
        bool success = false;
 80a0eac:	2400      	movs	r4, #0
      if (_M_manager)
 80a0eae:	9b02      	ldr	r3, [sp, #8]
 80a0eb0:	b11b      	cbz	r3, 80a0eba <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_+0x4e>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a0eb2:	4669      	mov	r1, sp
 80a0eb4:	2203      	movs	r2, #3
 80a0eb6:	4608      	mov	r0, r1
 80a0eb8:	4798      	blx	r3
    }
 80a0eba:	4620      	mov	r0, r4
 80a0ebc:	b004      	add	sp, #16
 80a0ebe:	bd70      	pop	{r4, r5, r6, pc}
 80a0ec0:	080a053f 	.word	0x080a053f
 80a0ec4:	080a0545 	.word	0x080a0545
 80a0ec8:	080a4625 	.word	0x080a4625

080a0ecc <setup>:
void setup() {
 80a0ecc:	b570      	push	{r4, r5, r6, lr}
 80a0ece:	b086      	sub	sp, #24
  Serial.begin(9600);
 80a0ed0:	f005 fa16 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a0ed4:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0ed8:	f005 f9f4 	bl	80a62c4 <_ZN9USBSerial5beginEl>
  speaker.begin(audioFrequency);
 80a0edc:	f64a 4144 	movw	r1, #44100	; 0xac44
 80a0ee0:	4834      	ldr	r0, [pc, #208]	; (80a0fb4 <setup+0xe8>)
 80a0ee2:	f003 f8cb 	bl	80a407c <_ZN7Speaker5beginEt>
  Particle.function("playWav", selectFile);
 80a0ee6:	4934      	ldr	r1, [pc, #208]	; (80a0fb8 <setup+0xec>)
 80a0ee8:	4834      	ldr	r0, [pc, #208]	; (80a0fbc <setup+0xf0>)
 80a0eea:	f7ff ffbf 	bl	80a0e6c <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_>
  Particle.function("atkMode", attackMode);
 80a0eee:	4934      	ldr	r1, [pc, #208]	; (80a0fc0 <setup+0xf4>)
 80a0ef0:	4834      	ldr	r0, [pc, #208]	; (80a0fc4 <setup+0xf8>)
 80a0ef2:	f7ff ffbb 	bl	80a0e6c <_ZN10CloudClass8functionIA8_cJPFiPKcEEEEbRKT_DpT0_>
class SPISettings : public Printable {
 80a0ef6:	4b34      	ldr	r3, [pc, #208]	; (80a0fc8 <setup+0xfc>)
 80a0ef8:	2501      	movs	r5, #1
 80a0efa:	9302      	str	r3, [sp, #8]
 80a0efc:	2300      	movs	r3, #0
   * \param[in] csPin SD card chip select pin.
   * \param[in] spiSettings SPI speed, mode, and bit order.
   * \return true for success else false.
   */
  bool begin(uint8_t csPin = SS, SPISettings spiSettings = SPI_FULL_SPEED) {
    return m_card.begin(&m_spi, csPin, spiSettings) &&
 80a0efe:	4c33      	ldr	r4, [pc, #204]	; (80a0fcc <setup+0x100>)
 80a0f00:	f88d 300c 	strb.w	r3, [sp, #12]
 80a0f04:	4b32      	ldr	r3, [pc, #200]	; (80a0fd0 <setup+0x104>)
 80a0f06:	f504 668c 	add.w	r6, r4, #1120	; 0x460
 80a0f0a:	9304      	str	r3, [sp, #16]
 80a0f0c:	220c      	movs	r2, #12
 80a0f0e:	4630      	mov	r0, r6
 80a0f10:	ab02      	add	r3, sp, #8
 80a0f12:	f204 416c 	addw	r1, r4, #1132	; 0x46c
 80a0f16:	f8ad 5014 	strh.w	r5, [sp, #20]
 80a0f1a:	f001 fcbd 	bl	80a2898 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE>
 80a0f1e:	2800      	cmp	r0, #0
 80a0f20:	d042      	beq.n	80a0fa8 <setup+0xdc>
    vwd()->close();
 80a0f22:	f204 403c 	addw	r0, r4, #1084	; 0x43c
    m_blockDev = blockDev;
 80a0f26:	6026      	str	r6, [r4, #0]
    vwd()->close();
 80a0f28:	f000 fc1a 	bl	80a1760 <_ZN7FatFile5closeEv>
    return (part ? init(part) : init(1) || init(0))
 80a0f2c:	4629      	mov	r1, r5
 80a0f2e:	4620      	mov	r0, r4
 80a0f30:	f001 fb17 	bl	80a2562 <_ZN9FatVolume4initEh>
 80a0f34:	f204 453c 	addw	r5, r4, #1084	; 0x43c
 80a0f38:	4601      	mov	r1, r0
 80a0f3a:	b380      	cbz	r0, 80a0f9e <setup+0xd2>
            && vwd()->openRoot(this) && FatFile::setCwd(vwd());
 80a0f3c:	4923      	ldr	r1, [pc, #140]	; (80a0fcc <setup+0x100>)
 80a0f3e:	f201 403c 	addw	r0, r1, #1084	; 0x43c
 80a0f42:	f000 f9ef 	bl	80a1324 <_ZN7FatFile8openRootEP9FatVolume>
 80a0f46:	b378      	cbz	r0, 80a0fa8 <setup+0xdc>
    if (!dir->isDir()) {
 80a0f48:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
 80a0f4c:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a0f50:	d02a      	beq.n	80a0fa8 <setup+0xdc>
    m_cwd = dir;
 80a0f52:	4b20      	ldr	r3, [pc, #128]	; (80a0fd4 <setup+0x108>)
    Log.info("SD initialised");
 80a0f54:	4920      	ldr	r1, [pc, #128]	; (80a0fd8 <setup+0x10c>)
 80a0f56:	4821      	ldr	r0, [pc, #132]	; (80a0fdc <setup+0x110>)
 80a0f58:	601d      	str	r5, [r3, #0]
 80a0f5a:	f7ff fb97 	bl	80a068c <_ZNK5spark6Logger4infoEPKcz>
  strip.begin(); FreddyJaw.attach(D0);
 80a0f5e:	4820      	ldr	r0, [pc, #128]	; (80a0fe0 <setup+0x114>)
 80a0f60:	f001 feca 	bl	80a2cf8 <_ZN17Adafruit_NeoPixel5beginEv>
 80a0f64:	2100      	movs	r1, #0
 80a0f66:	23b4      	movs	r3, #180	; 0xb4
 80a0f68:	f44f 7208 	mov.w	r2, #544	; 0x220
 80a0f6c:	e9cd 1300 	strd	r1, r3, [sp]
 80a0f70:	481c      	ldr	r0, [pc, #112]	; (80a0fe4 <setup+0x118>)
 80a0f72:	f44f 6316 	mov.w	r3, #2400	; 0x960
 80a0f76:	f004 ff2d 	bl	80a5dd4 <_ZN5Servo6attachEtttss>
  pinMode(FREDDY_NOSE_PIN, INPUT_PULLDOWN);
 80a0f7a:	2103      	movs	r1, #3
 80a0f7c:	2005      	movs	r0, #5
 80a0f7e:	f005 fbc7 	bl	80a6710 <pinMode>
  whenToActivate = rand() % 100000 + 5000;
 80a0f82:	f006 fcc5 	bl	80a7910 <rand>
 80a0f86:	4b18      	ldr	r3, [pc, #96]	; (80a0fe8 <setup+0x11c>)
 80a0f88:	fb90 f2f3 	sdiv	r2, r0, r3
 80a0f8c:	fb02 0013 	mls	r0, r2, r3, r0
 80a0f90:	4b16      	ldr	r3, [pc, #88]	; (80a0fec <setup+0x120>)
 80a0f92:	f500 509c 	add.w	r0, r0, #4992	; 0x1380
 80a0f96:	3008      	adds	r0, #8
 80a0f98:	6018      	str	r0, [r3, #0]
}
 80a0f9a:	b006      	add	sp, #24
 80a0f9c:	bd70      	pop	{r4, r5, r6, pc}
    return (part ? init(part) : init(1) || init(0))
 80a0f9e:	4620      	mov	r0, r4
 80a0fa0:	f001 fadf 	bl	80a2562 <_ZN9FatVolume4initEh>
 80a0fa4:	2800      	cmp	r0, #0
 80a0fa6:	d1c9      	bne.n	80a0f3c <setup+0x70>
    Log.warn("failed to open card");
 80a0fa8:	4911      	ldr	r1, [pc, #68]	; (80a0ff0 <setup+0x124>)
 80a0faa:	480c      	ldr	r0, [pc, #48]	; (80a0fdc <setup+0x110>)
 80a0fac:	f7ff fb85 	bl	80a06ba <_ZNK5spark6Logger4warnEPKcz>
 80a0fb0:	e7d5      	b.n	80a0f5e <setup+0x92>
 80a0fb2:	bf00      	nop
 80a0fb4:	2000157c 	.word	0x2000157c
 80a0fb8:	080a0885 	.word	0x080a0885
 80a0fbc:	080a7d72 	.word	0x080a7d72
 80a0fc0:	080a09bd 	.word	0x080a09bd
 80a0fc4:	080a7d7a 	.word	0x080a7d7a
 80a0fc8:	080a7db4 	.word	0x080a7db4
 80a0fcc:	200010f4 	.word	0x200010f4
 80a0fd0:	02faf080 	.word	0x02faf080
 80a0fd4:	20001618 	.word	0x20001618
 80a0fd8:	080a7d82 	.word	0x080a7d82
 80a0fdc:	20001634 	.word	0x20001634
 80a0fe0:	2000158c 	.word	0x2000158c
 80a0fe4:	200000ac 	.word	0x200000ac
 80a0fe8:	000186a0 	.word	0x000186a0
 80a0fec:	20001610 	.word	0x20001610
 80a0ff0:	080a7d91 	.word	0x080a7d91

080a0ff4 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>:
    bool realloc(int n) {
 80a0ff4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        if (n > 0) {
 80a0ff8:	f1b1 0800 	subs.w	r8, r1, #0
    bool realloc(int n) {
 80a0ffc:	4607      	mov	r7, r0
        if (n > 0) {
 80a0ffe:	dd35      	ble.n	80a106c <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x78>
            d = (T*)AllocatorT::malloc(n * sizeof(T));
 80a1000:	f04f 0914 	mov.w	r9, #20
    return ::malloc(size);
 80a1004:	fb09 f008 	mul.w	r0, r9, r8
 80a1008:	f003 fac8 	bl	80a459c <malloc>
            if (!d) {
 80a100c:	4605      	mov	r5, r0
 80a100e:	b3a8      	cbz	r0, 80a107c <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x88>
            move(d, data_, data_ + size_);
 80a1010:	e9d7 4600 	ldrd	r4, r6, [r7]
        if (dest > p && dest < end) {
 80a1014:	4284      	cmp	r4, r0
            move(d, data_, data_ + size_);
 80a1016:	fb09 4606 	mla	r6, r9, r6, r4
        if (dest > p && dest < end) {
 80a101a:	d215      	bcs.n	80a1048 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x54>
 80a101c:	4286      	cmp	r6, r0
 80a101e:	d914      	bls.n	80a104a <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x56>
            --end;
 80a1020:	3e14      	subs	r6, #20
            dest += end - p - 1;
 80a1022:	f1a4 0914 	sub.w	r9, r4, #20
 80a1026:	1b34      	subs	r4, r6, r4
 80a1028:	4404      	add	r4, r0
            for (; end != p; --end, --dest) {
 80a102a:	45b1      	cmp	r9, r6
 80a102c:	d01f      	beq.n	80a106e <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x7a>
                new(dest) T(std::move(*end));
 80a102e:	b12c      	cbz	r4, 80a103c <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x48>
 80a1030:	4631      	mov	r1, r6
 80a1032:	4620      	mov	r0, r4
 80a1034:	f005 f833 	bl	80a609e <_ZN6StringC1EOS_>
 80a1038:	7c33      	ldrb	r3, [r6, #16]
 80a103a:	7423      	strb	r3, [r4, #16]
 80a103c:	4630      	mov	r0, r6
 80a103e:	f004 ffb4 	bl	80a5faa <_ZN6StringD1Ev>
            for (; end != p; --end, --dest) {
 80a1042:	3e14      	subs	r6, #20
 80a1044:	3c14      	subs	r4, #20
 80a1046:	e7f0      	b.n	80a102a <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x36>
        } else if (dest != p) {
 80a1048:	d011      	beq.n	80a106e <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x7a>
 80a104a:	46a9      	mov	r9, r5
            for (; p != end; ++p, ++dest) {
 80a104c:	42a6      	cmp	r6, r4
 80a104e:	d00e      	beq.n	80a106e <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x7a>
 80a1050:	4621      	mov	r1, r4
 80a1052:	4648      	mov	r0, r9
 80a1054:	f005 f823 	bl	80a609e <_ZN6StringC1EOS_>
 80a1058:	7c23      	ldrb	r3, [r4, #16]
 80a105a:	4620      	mov	r0, r4
 80a105c:	f889 3010 	strb.w	r3, [r9, #16]
 80a1060:	f004 ffa3 	bl	80a5faa <_ZN6StringD1Ev>
 80a1064:	3414      	adds	r4, #20
 80a1066:	f109 0914 	add.w	r9, r9, #20
 80a106a:	e7ef      	b.n	80a104c <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x58>
        T* d = nullptr;
 80a106c:	2500      	movs	r5, #0
    ::free(ptr);
 80a106e:	6838      	ldr	r0, [r7, #0]
 80a1070:	f003 fa9c 	bl	80a45ac <free>
        return true;
 80a1074:	2001      	movs	r0, #1
        data_ = d;
 80a1076:	603d      	str	r5, [r7, #0]
        capacity_ = n;
 80a1078:	f8c7 8008 	str.w	r8, [r7, #8]
    }
 80a107c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080a1080 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>:
        capacity_(0) {
 80a1080:	2300      	movs	r3, #0
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a1082:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        capacity_(0) {
 80a1086:	e9c0 3300 	strd	r3, r3, [r0]
 80a108a:	6083      	str	r3, [r0, #8]
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a108c:	460d      	mov	r5, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a108e:	6849      	ldr	r1, [r1, #4]
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a1090:	4604      	mov	r4, r0
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a1092:	4299      	cmp	r1, r3
 80a1094:	dd17      	ble.n	80a10c6 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x46>
 80a1096:	f7ff ffad 	bl	80a0ff4 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a109a:	b1a0      	cbz	r0, 80a10c6 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x46>
        copy(data_, vector.data_, vector.data_ + vector.size_);
 80a109c:	e9d5 6300 	ldrd	r6, r3, [r5]
 80a10a0:	f04f 0814 	mov.w	r8, #20
 80a10a4:	fb08 6803 	mla	r8, r8, r3, r6
 80a10a8:	6827      	ldr	r7, [r4, #0]
        for (; it != end; ++it, ++dest) {
 80a10aa:	45b0      	cmp	r8, r6
 80a10ac:	d009      	beq.n	80a10c2 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x42>
            new(dest) T(*it);
 80a10ae:	b12f      	cbz	r7, 80a10bc <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x3c>
 80a10b0:	4631      	mov	r1, r6
 80a10b2:	4638      	mov	r0, r7
 80a10b4:	f005 f80d 	bl	80a60d2 <_ZN6StringC1ERKS_>
 80a10b8:	7c33      	ldrb	r3, [r6, #16]
 80a10ba:	743b      	strb	r3, [r7, #16]
        for (; it != end; ++it, ++dest) {
 80a10bc:	3614      	adds	r6, #20
 80a10be:	3714      	adds	r7, #20
 80a10c0:	e7f3      	b.n	80a10aa <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x2a>
        size_ = vector.size_;
 80a10c2:	686b      	ldr	r3, [r5, #4]
 80a10c4:	6063      	str	r3, [r4, #4]
}
 80a10c6:	4620      	mov	r0, r4
 80a10c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a10cc <_GLOBAL__sub_I_logHandler>:
}
 80a10cc:	b530      	push	{r4, r5, lr}
 80a10ce:	b093      	sub	sp, #76	; 0x4c
        level_(level) {
 80a10d0:	493b      	ldr	r1, [pc, #236]	; (80a11c0 <_GLOBAL__sub_I_logHandler+0xf4>)
 80a10d2:	a80d      	add	r0, sp, #52	; 0x34
 80a10d4:	f004 ffb3 	bl	80a603e <_ZN6StringC1EPKc>
 80a10d8:	231e      	movs	r3, #30
 80a10da:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
        capacity_(0) {
 80a10de:	2300      	movs	r3, #0
    if (n > 0 && realloc(n)) {
 80a10e0:	2101      	movs	r1, #1
 80a10e2:	a801      	add	r0, sp, #4
        capacity_(0) {
 80a10e4:	e9cd 3301 	strd	r3, r3, [sp, #4]
 80a10e8:	9303      	str	r3, [sp, #12]
    if (n > 0 && realloc(n)) {
 80a10ea:	f7ff ff83 	bl	80a0ff4 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a10ee:	b150      	cbz	r0, 80a1106 <_GLOBAL__sub_I_logHandler+0x3a>
        copy(data_, values.begin(), values.end());
 80a10f0:	9c01      	ldr	r4, [sp, #4]
            new(dest) T(*p);
 80a10f2:	b134      	cbz	r4, 80a1102 <_GLOBAL__sub_I_logHandler+0x36>
class LogCategoryFilter {
 80a10f4:	4620      	mov	r0, r4
 80a10f6:	a90d      	add	r1, sp, #52	; 0x34
 80a10f8:	f004 ffeb 	bl	80a60d2 <_ZN6StringC1ERKS_>
 80a10fc:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
 80a1100:	7423      	strb	r3, [r4, #16]
        size_ = n;
 80a1102:	2301      	movs	r3, #1
 80a1104:	9302      	str	r3, [sp, #8]
            StreamLogHandler(Serial, level, filters) {
 80a1106:	f005 f8fb 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a110a:	4605      	mov	r5, r0
 80a110c:	a901      	add	r1, sp, #4
 80a110e:	a804      	add	r0, sp, #16
 80a1110:	f7ff ffb6 	bl	80a1080 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
        stream_(&stream) {
 80a1114:	a904      	add	r1, sp, #16
 80a1116:	a807      	add	r0, sp, #28
 80a1118:	f7ff ffb2 	bl	80a1080 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
        filter_(level, filters) {
 80a111c:	4c29      	ldr	r4, [pc, #164]	; (80a11c4 <_GLOBAL__sub_I_logHandler+0xf8>)
 80a111e:	4b2a      	ldr	r3, [pc, #168]	; (80a11c8 <_GLOBAL__sub_I_logHandler+0xfc>)
 80a1120:	a907      	add	r1, sp, #28
 80a1122:	6023      	str	r3, [r4, #0]
 80a1124:	a80a      	add	r0, sp, #40	; 0x28
 80a1126:	f7ff ffab 	bl	80a1080 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a112a:	aa0a      	add	r2, sp, #40	; 0x28
 80a112c:	2146      	movs	r1, #70	; 0x46
 80a112e:	1d20      	adds	r0, r4, #4
 80a1130:	f004 f9f8 	bl	80a5524 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a1134:	a80a      	add	r0, sp, #40	; 0x28
 80a1136:	f7ff fe85 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
        stream_(&stream) {
 80a113a:	a807      	add	r0, sp, #28
 80a113c:	f7ff fe82 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a1140:	4b22      	ldr	r3, [pc, #136]	; (80a11cc <_GLOBAL__sub_I_logHandler+0x100>)
 80a1142:	6225      	str	r5, [r4, #32]
 80a1144:	6023      	str	r3, [r4, #0]
 80a1146:	a804      	add	r0, sp, #16
 80a1148:	f7ff fe7c 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a114c:	4b20      	ldr	r3, [pc, #128]	; (80a11d0 <_GLOBAL__sub_I_logHandler+0x104>)
 80a114e:	6023      	str	r3, [r4, #0]
        Serial.begin();
 80a1150:	f005 f8d6 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a1154:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a1158:	f005 f8b4 	bl	80a62c4 <_ZN9USBSerial5beginEl>
        LogManager::instance()->addHandler(this);
 80a115c:	f003 fe7a 	bl	80a4e54 <_ZN5spark10LogManager8instanceEv>
 80a1160:	4621      	mov	r1, r4
 80a1162:	f004 f972 	bl	80a544a <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE>
}); 
 80a1166:	a801      	add	r0, sp, #4
 80a1168:	f7ff fe6c 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
class LogCategoryFilter {
 80a116c:	a80d      	add	r0, sp, #52	; 0x34
 80a116e:	f004 ff1c 	bl	80a5faa <_ZN6StringD1Ev>
SdFat        sd;
 80a1172:	4818      	ldr	r0, [pc, #96]	; (80a11d4 <_GLOBAL__sub_I_logHandler+0x108>)
 80a1174:	f7ff fae0 	bl	80a0738 <_ZN5SdFatC1Ev>
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
 80a1178:	2200      	movs	r2, #0
 80a117a:	4b17      	ldr	r3, [pc, #92]	; (80a11d8 <_GLOBAL__sub_I_logHandler+0x10c>)
Speaker speaker(data[0], data[1], BUFFERSIZE);
 80a117c:	4817      	ldr	r0, [pc, #92]	; (80a11dc <_GLOBAL__sub_I_logHandler+0x110>)
 80a117e:	821a      	strh	r2, [r3, #16]
    Print() : write_error(0) {}
 80a1180:	605a      	str	r2, [r3, #4]
    Stream() {_timeout=1000;}
 80a1182:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a1186:	609a      	str	r2, [r3, #8]
  File() {}
 80a1188:	4a15      	ldr	r2, [pc, #84]	; (80a11e0 <_GLOBAL__sub_I_logHandler+0x114>)
 80a118a:	601a      	str	r2, [r3, #0]
 80a118c:	4a15      	ldr	r2, [pc, #84]	; (80a11e4 <_GLOBAL__sub_I_logHandler+0x118>)
 80a118e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80a1192:	f5a2 6100 	sub.w	r1, r2, #2048	; 0x800
 80a1196:	f002 fee1 	bl	80a3f5c <_ZN7SpeakerC1EPtS0_t>
String testing;
 80a119a:	4913      	ldr	r1, [pc, #76]	; (80a11e8 <_GLOBAL__sub_I_logHandler+0x11c>)
 80a119c:	4813      	ldr	r0, [pc, #76]	; (80a11ec <_GLOBAL__sub_I_logHandler+0x120>)
 80a119e:	f004 ff4e 	bl	80a603e <_ZN6StringC1EPKc>
Adafruit_NeoPixel strip = Adafruit_NeoPixel(pixelNum, pixelPin, pixelModel);
 80a11a2:	4b13      	ldr	r3, [pc, #76]	; (80a11f0 <_GLOBAL__sub_I_logHandler+0x124>)
 80a11a4:	4a13      	ldr	r2, [pc, #76]	; (80a11f4 <_GLOBAL__sub_I_logHandler+0x128>)
 80a11a6:	4914      	ldr	r1, [pc, #80]	; (80a11f8 <_GLOBAL__sub_I_logHandler+0x12c>)
 80a11a8:	781b      	ldrb	r3, [r3, #0]
 80a11aa:	7812      	ldrb	r2, [r2, #0]
 80a11ac:	8809      	ldrh	r1, [r1, #0]
 80a11ae:	4813      	ldr	r0, [pc, #76]	; (80a11fc <_GLOBAL__sub_I_logHandler+0x130>)
 80a11b0:	f001 fdc7 	bl	80a2d42 <_ZN17Adafruit_NeoPixelC1Ethh>
Servo FreddyJaw;
 80a11b4:	4812      	ldr	r0, [pc, #72]	; (80a1200 <_GLOBAL__sub_I_logHandler+0x134>)
 80a11b6:	f004 fdf9 	bl	80a5dac <_ZN5ServoC1Ev>
}
 80a11ba:	b013      	add	sp, #76	; 0x4c
 80a11bc:	bd30      	pop	{r4, r5, pc}
 80a11be:	bf00      	nop
 80a11c0:	080a7da5 	.word	0x080a7da5
 80a11c4:	200010cc 	.word	0x200010cc
 80a11c8:	080a7dc8 	.word	0x080a7dc8
 80a11cc:	080a7f08 	.word	0x080a7f08
 80a11d0:	080a7de0 	.word	0x080a7de0
 80a11d4:	200010f4 	.word	0x200010f4
 80a11d8:	200015b0 	.word	0x200015b0
 80a11dc:	2000157c 	.word	0x2000157c
 80a11e0:	080a7df8 	.word	0x080a7df8
 80a11e4:	200008c8 	.word	0x200008c8
 80a11e8:	080a7ecd 	.word	0x080a7ecd
 80a11ec:	200015a0 	.word	0x200015a0
 80a11f0:	20000008 	.word	0x20000008
 80a11f4:	20000010 	.word	0x20000010
 80a11f8:	2000000c 	.word	0x2000000c
 80a11fc:	2000158c 	.word	0x2000158c
 80a1200:	200000ac 	.word	0x200000ac

080a1204 <_ZN9FatVolume9cacheSyncEv>:
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t blockNumber, uint8_t options) {
    return m_fatCache.read(blockNumber,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
 80a1204:	b510      	push	{r4, lr}
 80a1206:	4604      	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncBlocks();
 80a1208:	3024      	adds	r0, #36	; 0x24
 80a120a:	f001 f89d 	bl	80a2348 <_ZN8FatCache4syncEv>
 80a120e:	b128      	cbz	r0, 80a121c <_ZN9FatVolume9cacheSyncEv+0x18>
 80a1210:	f504 700c 	add.w	r0, r4, #560	; 0x230
  }
 80a1214:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return m_cache.sync() && m_fatCache.sync() && syncBlocks();
 80a1218:	f001 b896 	b.w	80a2348 <_ZN8FatCache4syncEv>
  }
 80a121c:	bd10      	pop	{r4, pc}

080a121e <_ZN7FatFile10addClusterEv>:
// Callback function for date/time.
void (*FatFile::m_dateTime)(uint16_t* date, uint16_t* time) = 0;
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
  m_flags |= F_FILE_DIR_DIRTY;
 80a121e:	7883      	ldrb	r3, [r0, #2]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
 80a1220:	6901      	ldr	r1, [r0, #16]
  m_flags |= F_FILE_DIR_DIRTY;
 80a1222:	f043 0304 	orr.w	r3, r3, #4
 80a1226:	7083      	strb	r3, [r0, #2]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
 80a1228:	f100 0210 	add.w	r2, r0, #16
 80a122c:	6880      	ldr	r0, [r0, #8]
 80a122e:	f001 b940 	b.w	80a24b2 <_ZN9FatVolume15allocateClusterEmPm>
	...

080a1234 <_ZN7FatFile13addDirClusterEv>:
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first block of cluster in the cache.
bool FatFile::addDirCluster() {
 80a1234:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t block;
  cache_t* pc;

  if (isRootFixed()) {
 80a1238:	7801      	ldrb	r1, [r0, #0]
bool FatFile::addDirCluster() {
 80a123a:	4604      	mov	r4, r0
  if (isRootFixed()) {
 80a123c:	f011 0520 	ands.w	r5, r1, #32
 80a1240:	d003      	beq.n	80a124a <_ZN7FatFile13addDirClusterEv+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += 512UL*m_vol->blocksPerCluster();
  return true;

fail:
  return false;
 80a1242:	2600      	movs	r6, #0
}
 80a1244:	4630      	mov	r0, r6
 80a1246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curPosition >= 512UL*4095) {
 80a124a:	6942      	ldr	r2, [r0, #20]
 80a124c:	4b17      	ldr	r3, [pc, #92]	; (80a12ac <_ZN7FatFile13addDirClusterEv+0x78>)
 80a124e:	429a      	cmp	r2, r3
 80a1250:	d2f7      	bcs.n	80a1242 <_ZN7FatFile13addDirClusterEv+0xe>
  if (!addCluster()) {
 80a1252:	f7ff ffe4 	bl	80a121e <_ZN7FatFile10addClusterEv>
 80a1256:	4606      	mov	r6, r0
 80a1258:	2800      	cmp	r0, #0
 80a125a:	d0f2      	beq.n	80a1242 <_ZN7FatFile13addDirClusterEv+0xe>
  block = m_vol->clusterFirstBlock(m_curCluster);
 80a125c:	6921      	ldr	r1, [r4, #16]
 80a125e:	68a0      	ldr	r0, [r4, #8]
 80a1260:	f001 f8bc 	bl	80a23dc <_ZNK9FatVolume17clusterFirstBlockEm>
 80a1264:	4607      	mov	r7, r0
  bool cacheSync() {
    return m_cache.sync() && syncBlocks();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
 80a1266:	68a0      	ldr	r0, [r4, #8]
 80a1268:	2205      	movs	r2, #5
 80a126a:	4639      	mov	r1, r7
 80a126c:	3024      	adds	r0, #36	; 0x24
 80a126e:	f001 f892 	bl	80a2396 <_ZN8FatCache4readEmh>
  if (!pc) {
 80a1272:	4680      	mov	r8, r0
 80a1274:	2800      	cmp	r0, #0
 80a1276:	d0e4      	beq.n	80a1242 <_ZN7FatFile13addDirClusterEv+0xe>
  memset(pc, 0, 512);
 80a1278:	4629      	mov	r1, r5
 80a127a:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a127e:	f006 fb1b 	bl	80a78b8 <memset>
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
 80a1282:	2501      	movs	r5, #1
 80a1284:	68a3      	ldr	r3, [r4, #8]
 80a1286:	791a      	ldrb	r2, [r3, #4]
 80a1288:	42aa      	cmp	r2, r5
 80a128a:	d909      	bls.n	80a12a0 <_ZN7FatFile13addDirClusterEv+0x6c>
    return m_blockDev->writeBlock(block, src);
 80a128c:	4642      	mov	r2, r8
 80a128e:	6818      	ldr	r0, [r3, #0]
 80a1290:	19e9      	adds	r1, r5, r7
 80a1292:	f001 fc34 	bl	80a2afe <_ZN9SdSpiCard10writeBlockEmPKh>
    if (!m_vol->writeBlock(block + i, pc->data)) {
 80a1296:	2800      	cmp	r0, #0
 80a1298:	d0d3      	beq.n	80a1242 <_ZN7FatFile13addDirClusterEv+0xe>
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
 80a129a:	3501      	adds	r5, #1
 80a129c:	b2ed      	uxtb	r5, r5
 80a129e:	e7f1      	b.n	80a1284 <_ZN7FatFile13addDirClusterEv+0x50>
  m_curPosition += 512UL*m_vol->blocksPerCluster();
 80a12a0:	6963      	ldr	r3, [r4, #20]
 80a12a2:	eb03 2342 	add.w	r3, r3, r2, lsl #9
 80a12a6:	6163      	str	r3, [r4, #20]
  return true;
 80a12a8:	e7cc      	b.n	80a1244 <_ZN7FatFile13addDirClusterEv+0x10>
 80a12aa:	bf00      	nop
 80a12ac:	001ffe00 	.word	0x001ffe00

080a12b0 <_ZN7FatFile13cacheDirEntryEh>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* FatFile::cacheDirEntry(uint8_t action) {
 80a12b0:	b510      	push	{r4, lr}
 80a12b2:	4604      	mov	r4, r0
    return m_cache.read(blockNumber, options);
 80a12b4:	6880      	ldr	r0, [r0, #8]
 80a12b6:	460a      	mov	r2, r1
 80a12b8:	3024      	adds	r0, #36	; 0x24
 80a12ba:	69a1      	ldr	r1, [r4, #24]
 80a12bc:	f001 f86b 	bl	80a2396 <_ZN8FatCache4readEmh>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirBlock, action);
  if (!pc) {
 80a12c0:	b120      	cbz	r0, 80a12cc <_ZN7FatFile13cacheDirEntryEh+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
 80a12c2:	88a3      	ldrh	r3, [r4, #4]
 80a12c4:	f003 030f 	and.w	r3, r3, #15
 80a12c8:	eb00 1043 	add.w	r0, r0, r3, lsl #5

fail:
  return 0;
}
 80a12cc:	bd10      	pop	{r4, pc}

080a12ce <_ZN7FatFile7dirNameEPK14directoryEntryPc>:
}
//------------------------------------------------------------------------------
uint8_t FatFile::dirName(const dir_t* dir, char* name) {
  uint8_t j = 0;
  uint8_t lcBit = DIR_NT_LC_BASE;
  for (uint8_t i = 0; i < 11; i++) {
 80a12ce:	2300      	movs	r3, #0
uint8_t FatFile::dirName(const dir_t* dir, char* name) {
 80a12d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a12d2:	4604      	mov	r4, r0
 80a12d4:	1e45      	subs	r5, r0, #1
  uint8_t lcBit = DIR_NT_LC_BASE;
 80a12d6:	2608      	movs	r6, #8
  uint8_t j = 0;
 80a12d8:	4618      	mov	r0, r3
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = DIR_NT_LC_EXT;
      name[j++] = '.';
 80a12da:	272e      	movs	r7, #46	; 0x2e
    if (dir->name[i] == ' ') {
 80a12dc:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 80a12e0:	2a20      	cmp	r2, #32
 80a12e2:	d018      	beq.n	80a1316 <_ZN7FatFile7dirNameEPK14directoryEntryPc+0x48>
    if (i == 8) {
 80a12e4:	2b08      	cmp	r3, #8
 80a12e6:	bf02      	ittt	eq
 80a12e8:	1c42      	addeq	r2, r0, #1
      name[j++] = '.';
 80a12ea:	540f      	strbeq	r7, [r1, r0]
 80a12ec:	b2d0      	uxtbeq	r0, r2
    }
    char c = dir->name[i];
 80a12ee:	782a      	ldrb	r2, [r5, #0]
      lcBit = DIR_NT_LC_EXT;
 80a12f0:	bf08      	it	eq
 80a12f2:	2610      	moveq	r6, #16
    if ('A' <= c && c <= 'Z' && (lcBit & dir->reservedNT)) {
 80a12f4:	f1a2 0c41 	sub.w	ip, r2, #65	; 0x41
 80a12f8:	f1bc 0f19 	cmp.w	ip, #25
 80a12fc:	d806      	bhi.n	80a130c <_ZN7FatFile7dirNameEPK14directoryEntryPc+0x3e>
 80a12fe:	f894 c00c 	ldrb.w	ip, [r4, #12]
 80a1302:	ea16 0f0c 	tst.w	r6, ip
      c += 'a' - 'A';
 80a1306:	bf1c      	itt	ne
 80a1308:	3220      	addne	r2, #32
 80a130a:	b2d2      	uxtbne	r2, r2
    }
    name[j++] = c;
 80a130c:	f100 0c01 	add.w	ip, r0, #1
 80a1310:	540a      	strb	r2, [r1, r0]
 80a1312:	fa5f f08c 	uxtb.w	r0, ip
  for (uint8_t i = 0; i < 11; i++) {
 80a1316:	3301      	adds	r3, #1
 80a1318:	b2db      	uxtb	r3, r3
 80a131a:	2b0b      	cmp	r3, #11
 80a131c:	d1de      	bne.n	80a12dc <_ZN7FatFile7dirNameEPK14directoryEntryPc+0xe>
  }
  name[j] = 0;
 80a131e:	2300      	movs	r3, #0
 80a1320:	540b      	strb	r3, [r1, r0]
  return j;
}
 80a1322:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a1324 <_ZN7FatFile8openRootEP9FatVolume>:
fail:
  return false;
}
#endif  // DOXYGEN_SHOULD_SKIP_THIS
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
 80a1324:	b570      	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
 80a1326:	7804      	ldrb	r4, [r0, #0]
bool FatFile::openRoot(FatVolume* vol) {
 80a1328:	4605      	mov	r5, r0
 80a132a:	460e      	mov	r6, r1
  if (isOpen()) {
 80a132c:	b94c      	cbnz	r4, 80a1342 <_ZN7FatFile8openRootEP9FatVolume+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
 80a132e:	2224      	movs	r2, #36	; 0x24
 80a1330:	4621      	mov	r1, r4
 80a1332:	f006 fac1 	bl	80a78b8 <memset>

  m_vol = vol;
 80a1336:	60ae      	str	r6, [r5, #8]
  switch (vol->fatType()) {
 80a1338:	79f3      	ldrb	r3, [r6, #7]
 80a133a:	2b10      	cmp	r3, #16
 80a133c:	d003      	beq.n	80a1346 <_ZN7FatFile8openRootEP9FatVolume+0x22>
 80a133e:	2b20      	cmp	r3, #32
 80a1340:	d007      	beq.n	80a1352 <_ZN7FatFile8openRootEP9FatVolume+0x2e>
  // read only
  m_flags = F_READ;
  return true;

fail:
  return false;
 80a1342:	2000      	movs	r0, #0
 80a1344:	e004      	b.n	80a1350 <_ZN7FatFile8openRootEP9FatVolume+0x2c>
    m_attr = FILE_ATTR_ROOT_FIXED;
 80a1346:	2320      	movs	r3, #32
  m_flags = F_READ;
 80a1348:	2401      	movs	r4, #1
  return true;
 80a134a:	4620      	mov	r0, r4
    m_attr = FILE_ATTR_ROOT32;
 80a134c:	702b      	strb	r3, [r5, #0]
  m_flags = F_READ;
 80a134e:	70ac      	strb	r4, [r5, #2]
}
 80a1350:	bd70      	pop	{r4, r5, r6, pc}
    m_attr = FILE_ATTR_ROOT32;
 80a1352:	2340      	movs	r3, #64	; 0x40
 80a1354:	e7f8      	b.n	80a1348 <_ZN7FatFile8openRootEP9FatVolume+0x24>

080a1356 <_ZN7FatFile4readEPvj>:
    setpos(&pos);
  }
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
 80a1356:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t block;  // raw device block number
  cache_t* pc;

  // error if not open for read
  if (!isOpen() || !(m_flags & F_READ)) {
 80a135a:	7803      	ldrb	r3, [r0, #0]
int FatFile::read(void* buf, size_t nbyte) {
 80a135c:	4604      	mov	r4, r0
 80a135e:	4688      	mov	r8, r1
 80a1360:	4615      	mov	r5, r2
  if (!isOpen() || !(m_flags & F_READ)) {
 80a1362:	2b00      	cmp	r3, #0
 80a1364:	d05d      	beq.n	80a1422 <_ZN7FatFile4readEPvj+0xcc>
 80a1366:	7882      	ldrb	r2, [r0, #2]
 80a1368:	07d1      	lsls	r1, r2, #31
 80a136a:	d55a      	bpl.n	80a1422 <_ZN7FatFile4readEPvj+0xcc>
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
 80a136c:	071a      	lsls	r2, r3, #28
 80a136e:	d52d      	bpl.n	80a13cc <_ZN7FatFile4readEPvj+0x76>
    uint32_t tmp32 = m_fileSize - m_curPosition;
 80a1370:	69c3      	ldr	r3, [r0, #28]
 80a1372:	6942      	ldr	r2, [r0, #20]
 80a1374:	1a9b      	subs	r3, r3, r2
 80a1376:	429d      	cmp	r5, r3
 80a1378:	bf28      	it	cs
 80a137a:	461d      	movcs	r5, r3
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
 80a137c:	462e      	mov	r6, r5
  uint8_t blockOfCluster = 0;
 80a137e:	f04f 0900 	mov.w	r9, #0
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
 80a1382:	f104 0b10 	add.w	fp, r4, #16
  while (toRead) {
 80a1386:	2e00      	cmp	r6, #0
 80a1388:	f000 808f 	beq.w	80a14aa <_ZN7FatFile4readEPvj+0x154>
    if (isRootFixed()) {
 80a138c:	7822      	ldrb	r2, [r4, #0]
    offset = m_curPosition & 0X1FF;  // offset in block
 80a138e:	6963      	ldr	r3, [r4, #20]
    if (isRootFixed()) {
 80a1390:	0697      	lsls	r7, r2, #26
 80a1392:	68a0      	ldr	r0, [r4, #8]
    offset = m_curPosition & 0X1FF;  // offset in block
 80a1394:	f3c3 0a08 	ubfx	sl, r3, #0, #9
    return m_attr & FILE_ATTR_ROOT_FIXED;
 80a1398:	ea4f 2153 	mov.w	r1, r3, lsr #9
    if (isRootFixed()) {
 80a139c:	d51f      	bpl.n	80a13de <_ZN7FatFile4readEPvj+0x88>
      block = m_vol->rootDirStart() + (m_curPosition >> 9);
 80a139e:	6a00      	ldr	r0, [r0, #32]
 80a13a0:	4401      	add	r1, r0
          }
        }
      }
      block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
    }
    if (offset != 0 || toRead < 512 || block == m_vol->cacheBlockNumber()) {
 80a13a2:	68a0      	ldr	r0, [r4, #8]
 80a13a4:	f1ba 0f00 	cmp.w	sl, #0
 80a13a8:	d142      	bne.n	80a1430 <_ZN7FatFile4readEPvj+0xda>
 80a13aa:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a13ae:	d33f      	bcc.n	80a1430 <_ZN7FatFile4readEPvj+0xda>
  }
  cache_t *cacheAddress() {
    return m_cache.block();
  }
  uint32_t cacheBlockNumber() {
    return m_cache.lbn();
 80a13b0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80a13b2:	4299      	cmp	r1, r3
 80a13b4:	d03c      	beq.n	80a1430 <_ZN7FatFile4readEPvj+0xda>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_BLOCK_IO
    } else if (toRead >= 1024) {
 80a13b6:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 80a13ba:	d252      	bcs.n	80a1462 <_ZN7FatFile4readEPvj+0x10c>
    return m_blockDev->readBlock(block, dst);
 80a13bc:	4642      	mov	r2, r8
 80a13be:	6800      	ldr	r0, [r0, #0]
 80a13c0:	f001 fb14 	bl	80a29ec <_ZN9SdSpiCard9readBlockEmPh>
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // read single block
      n = 512;
      if (!m_vol->readBlock(block, dst)) {
 80a13c4:	b368      	cbz	r0, 80a1422 <_ZN7FatFile4readEPvj+0xcc>
      n = 512;
 80a13c6:	f44f 7700 	mov.w	r7, #512	; 0x200
 80a13ca:	e044      	b.n	80a1456 <_ZN7FatFile4readEPvj+0x100>
  } else if (isRootFixed()) {
 80a13cc:	069b      	lsls	r3, r3, #26
 80a13ce:	d5d5      	bpl.n	80a137c <_ZN7FatFile4readEPvj+0x26>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
 80a13d0:	6883      	ldr	r3, [r0, #8]
 80a13d2:	891a      	ldrh	r2, [r3, #8]
 80a13d4:	6943      	ldr	r3, [r0, #20]
 80a13d6:	ebc3 1342 	rsb	r3, r3, r2, lsl #5
    if (nbyte > tmp16) {
 80a13da:	b29b      	uxth	r3, r3
 80a13dc:	e7cb      	b.n	80a1376 <_ZN7FatFile4readEPvj+0x20>
  }
//------------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t blockOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterBlockMask;
 80a13de:	f890 9005 	ldrb.w	r9, [r0, #5]
 80a13e2:	ea09 0901 	and.w	r9, r9, r1
      if (offset == 0 && blockOfCluster == 0) {
 80a13e6:	f1ba 0f00 	cmp.w	sl, #0
 80a13ea:	d108      	bne.n	80a13fe <_ZN7FatFile4readEPvj+0xa8>
 80a13ec:	f1b9 0f00 	cmp.w	r9, #0
 80a13f0:	d105      	bne.n	80a13fe <_ZN7FatFile4readEPvj+0xa8>
        if (m_curPosition == 0) {
 80a13f2:	b95b      	cbnz	r3, 80a140c <_ZN7FatFile4readEPvj+0xb6>
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
 80a13f4:	0651      	lsls	r1, r2, #25
 80a13f6:	bf4c      	ite	mi
 80a13f8:	6a03      	ldrmi	r3, [r0, #32]
 80a13fa:	6a23      	ldrpl	r3, [r4, #32]
 80a13fc:	6123      	str	r3, [r4, #16]
      block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
 80a13fe:	6921      	ldr	r1, [r4, #16]
 80a1400:	68a0      	ldr	r0, [r4, #8]
 80a1402:	f000 ffeb 	bl	80a23dc <_ZNK9FatVolume17clusterFirstBlockEm>
 80a1406:	eb09 0100 	add.w	r1, r9, r0
 80a140a:	e7ca      	b.n	80a13a2 <_ZN7FatFile4readEPvj+0x4c>
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
 80a140c:	465a      	mov	r2, fp
 80a140e:	6921      	ldr	r1, [r4, #16]
 80a1410:	f000 ffea 	bl	80a23e8 <_ZN9FatVolume6fatGetEmPm>
          if (fg < 0) {
 80a1414:	2800      	cmp	r0, #0
 80a1416:	db04      	blt.n	80a1422 <_ZN7FatFile4readEPvj+0xcc>
          if (fg == 0) {
 80a1418:	d1f1      	bne.n	80a13fe <_ZN7FatFile4readEPvj+0xa8>
            if (isDir()) {
 80a141a:	7823      	ldrb	r3, [r4, #0]
 80a141c:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a1420:	d143      	bne.n	80a14aa <_ZN7FatFile4readEPvj+0x154>
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
 80a1422:	7863      	ldrb	r3, [r4, #1]
  return -1;
 80a1424:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  m_error |= READ_ERROR;
 80a1428:	f043 0302 	orr.w	r3, r3, #2
 80a142c:	7063      	strb	r3, [r4, #1]
  return -1;
 80a142e:	e03d      	b.n	80a14ac <_ZN7FatFile4readEPvj+0x156>
      n = 512 - offset;
 80a1430:	f5ca 7700 	rsb	r7, sl, #512	; 0x200
      if (n > toRead) {
 80a1434:	42b7      	cmp	r7, r6
    return m_cache.read(blockNumber, options);
 80a1436:	f04f 0200 	mov.w	r2, #0
 80a143a:	f100 0024 	add.w	r0, r0, #36	; 0x24
 80a143e:	bf28      	it	cs
 80a1440:	4637      	movcs	r7, r6
 80a1442:	f000 ffa8 	bl	80a2396 <_ZN8FatCache4readEmh>
      if (!pc) {
 80a1446:	2800      	cmp	r0, #0
 80a1448:	d0eb      	beq.n	80a1422 <_ZN7FatFile4readEPvj+0xcc>
      memcpy(dst, src, n);
 80a144a:	eb00 010a 	add.w	r1, r0, sl
 80a144e:	463a      	mov	r2, r7
 80a1450:	4640      	mov	r0, r8
 80a1452:	f006 fa09 	bl	80a7868 <memcpy>
    m_curPosition += n;
 80a1456:	6963      	ldr	r3, [r4, #20]
    dst += n;
 80a1458:	44b8      	add	r8, r7
    m_curPosition += n;
 80a145a:	443b      	add	r3, r7
 80a145c:	6163      	str	r3, [r4, #20]
    toRead -= n;
 80a145e:	1bf6      	subs	r6, r6, r7
  while (toRead) {
 80a1460:	e791      	b.n	80a1386 <_ZN7FatFile4readEPvj+0x30>
      if (!isRootFixed()) {
 80a1462:	7822      	ldrb	r2, [r4, #0]
      size_t nb = toRead >> 9;
 80a1464:	ea4f 2a56 	mov.w	sl, r6, lsr #9
      if (!isRootFixed()) {
 80a1468:	0692      	lsls	r2, r2, #26
 80a146a:	d406      	bmi.n	80a147a <_ZN7FatFile4readEPvj+0x124>
        uint8_t mb = m_vol->blocksPerCluster() - blockOfCluster;
 80a146c:	7902      	ldrb	r2, [r0, #4]
 80a146e:	eba2 0209 	sub.w	r2, r2, r9
        if (mb < nb) {
 80a1472:	b2d2      	uxtb	r2, r2
 80a1474:	4592      	cmp	sl, r2
 80a1476:	bf28      	it	cs
 80a1478:	4692      	movcs	sl, r2
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a147a:	4299      	cmp	r1, r3
      n = 512*nb;
 80a147c:	ea4f 274a 	mov.w	r7, sl, lsl #9
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a1480:	d208      	bcs.n	80a1494 <_ZN7FatFile4readEPvj+0x13e>
    return m_blockDev->readBlocks(block, dst, nb);
 80a1482:	68a0      	ldr	r0, [r4, #8]
 80a1484:	4653      	mov	r3, sl
 80a1486:	4642      	mov	r2, r8
 80a1488:	6800      	ldr	r0, [r0, #0]
 80a148a:	f001 faf7 	bl	80a2a7c <_ZN9SdSpiCard10readBlocksEmPhj>
      if (!m_vol->readBlocks(block, dst, nb)) {
 80a148e:	2800      	cmp	r0, #0
 80a1490:	d1e1      	bne.n	80a1456 <_ZN7FatFile4readEPvj+0x100>
 80a1492:	e7c6      	b.n	80a1422 <_ZN7FatFile4readEPvj+0xcc>
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a1494:	4453      	add	r3, sl
 80a1496:	428b      	cmp	r3, r1
 80a1498:	d9f3      	bls.n	80a1482 <_ZN7FatFile4readEPvj+0x12c>
    return m_cache.sync();
 80a149a:	3024      	adds	r0, #36	; 0x24
 80a149c:	9101      	str	r1, [sp, #4]
 80a149e:	f000 ff53 	bl	80a2348 <_ZN8FatCache4syncEv>
        if (!m_vol->cacheSyncData()) {
 80a14a2:	9901      	ldr	r1, [sp, #4]
 80a14a4:	2800      	cmp	r0, #0
 80a14a6:	d1ec      	bne.n	80a1482 <_ZN7FatFile4readEPvj+0x12c>
 80a14a8:	e7bb      	b.n	80a1422 <_ZN7FatFile4readEPvj+0xcc>
  return nbyte - toRead;
 80a14aa:	1ba8      	subs	r0, r5, r6
}
 80a14ac:	b003      	add	sp, #12
 80a14ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a14b2 <_ZN7FatFile4peekEv>:
int FatFile::peek() {
 80a14b2:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return read(&b, 1) == 1 ? b : -1;
 80a14b4:	2201      	movs	r2, #1
  pos->cluster = m_curCluster;
 80a14b6:	e9d0 5604 	ldrd	r5, r6, [r0, #16]
 80a14ba:	f10d 0107 	add.w	r1, sp, #7
int FatFile::peek() {
 80a14be:	4604      	mov	r4, r0
 80a14c0:	f7ff ff49 	bl	80a1356 <_ZN7FatFile4readEPvj>
 80a14c4:	2801      	cmp	r0, #1
 80a14c6:	bf12      	itee	ne
 80a14c8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80a14cc:	f89d 0007 	ldrbeq.w	r0, [sp, #7]
  return false;
}
//------------------------------------------------------------------------------
void FatFile::setpos(FatPos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
 80a14d0:	e9c4 5604 	strdeq	r5, r6, [r4, #16]
}
 80a14d4:	b002      	add	sp, #8
 80a14d6:	bd70      	pop	{r4, r5, r6, pc}

080a14d8 <_ZN7FatFile12readDirCacheEb>:
dir_t* FatFile::readDirCache(bool skipReadOk) {
 80a14d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t i = (m_curPosition >> 5) & 0XF;
 80a14da:	6943      	ldr	r3, [r0, #20]
dir_t* FatFile::readDirCache(bool skipReadOk) {
 80a14dc:	4604      	mov	r4, r0
  if (i == 0 || !skipReadOk) {
 80a14de:	f413 7ff0 	tst.w	r3, #480	; 0x1e0
  uint8_t i = (m_curPosition >> 5) & 0XF;
 80a14e2:	f3c3 1543 	ubfx	r5, r3, #5, #4
  if (i == 0 || !skipReadOk) {
 80a14e6:	d000      	beq.n	80a14ea <_ZN7FatFile12readDirCacheEb+0x12>
 80a14e8:	b999      	cbnz	r1, 80a1512 <_ZN7FatFile12readDirCacheEb+0x3a>
    int8_t n = read(&n, 1);
 80a14ea:	2201      	movs	r2, #1
 80a14ec:	4620      	mov	r0, r4
 80a14ee:	f10d 0107 	add.w	r1, sp, #7
 80a14f2:	f7ff ff30 	bl	80a1356 <_ZN7FatFile4readEPvj>
    if  (n != 1) {
 80a14f6:	b240      	sxtb	r0, r0
 80a14f8:	2801      	cmp	r0, #1
 80a14fa:	d002      	beq.n	80a1502 <_ZN7FatFile12readDirCacheEb+0x2a>
  return 0;
 80a14fc:	2000      	movs	r0, #0
}
 80a14fe:	b003      	add	sp, #12
 80a1500:	bd30      	pop	{r4, r5, pc}
    m_curPosition += 31;
 80a1502:	6963      	ldr	r3, [r4, #20]
 80a1504:	331f      	adds	r3, #31
  return m_vol->cacheAddress()->dir + i;
 80a1506:	68a0      	ldr	r0, [r4, #8]
    m_curPosition += 32;
 80a1508:	6163      	str	r3, [r4, #20]
  return m_vol->cacheAddress()->dir + i;
 80a150a:	3030      	adds	r0, #48	; 0x30
 80a150c:	eb00 1045 	add.w	r0, r0, r5, lsl #5
 80a1510:	e7f5      	b.n	80a14fe <_ZN7FatFile12readDirCacheEb+0x26>
    m_curPosition += 32;
 80a1512:	3320      	adds	r3, #32
 80a1514:	e7f7      	b.n	80a1506 <_ZN7FatFile12readDirCacheEb+0x2e>

080a1516 <_ZN7FatFile7seekSetEm>:
bool FatFile::seekSet(uint32_t pos) {
 80a1516:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isOpen()) {
 80a151a:	7802      	ldrb	r2, [r0, #0]
bool FatFile::seekSet(uint32_t pos) {
 80a151c:	4604      	mov	r4, r0
 80a151e:	460d      	mov	r5, r1
  uint32_t tmp = m_curCluster;
 80a1520:	6907      	ldr	r7, [r0, #16]
  if (!isOpen()) {
 80a1522:	b162      	cbz	r2, 80a153e <_ZN7FatFile7seekSetEm+0x28>
  if (pos == m_curPosition) {
 80a1524:	6940      	ldr	r0, [r0, #20]
 80a1526:	4288      	cmp	r0, r1
 80a1528:	d002      	beq.n	80a1530 <_ZN7FatFile7seekSetEm+0x1a>
  if (pos == 0) {
 80a152a:	b919      	cbnz	r1, 80a1534 <_ZN7FatFile7seekSetEm+0x1e>
    m_curCluster = 0;
 80a152c:	6121      	str	r1, [r4, #16]
  m_curPosition = pos;
 80a152e:	6165      	str	r5, [r4, #20]
    return true;
 80a1530:	2001      	movs	r0, #1
 80a1532:	e006      	b.n	80a1542 <_ZN7FatFile7seekSetEm+0x2c>
  if (isFile()) {
 80a1534:	0716      	lsls	r6, r2, #28
 80a1536:	d506      	bpl.n	80a1546 <_ZN7FatFile7seekSetEm+0x30>
    if (pos > m_fileSize) {
 80a1538:	69e3      	ldr	r3, [r4, #28]
 80a153a:	428b      	cmp	r3, r1
 80a153c:	d20b      	bcs.n	80a1556 <_ZN7FatFile7seekSetEm+0x40>
  return false;
 80a153e:	2000      	movs	r0, #0
  m_curCluster = tmp;
 80a1540:	6127      	str	r7, [r4, #16]
}
 80a1542:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (isRootFixed()) {
 80a1546:	0691      	lsls	r1, r2, #26
 80a1548:	d505      	bpl.n	80a1556 <_ZN7FatFile7seekSetEm+0x40>
    if (pos <= 32*m_vol->rootDirEntryCount()) {
 80a154a:	68a3      	ldr	r3, [r4, #8]
 80a154c:	891b      	ldrh	r3, [r3, #8]
 80a154e:	ebb5 1f43 	cmp.w	r5, r3, lsl #5
 80a1552:	d9ec      	bls.n	80a152e <_ZN7FatFile7seekSetEm+0x18>
 80a1554:	e7f3      	b.n	80a153e <_ZN7FatFile7seekSetEm+0x28>
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1556:	f8d4 c008 	ldr.w	ip, [r4, #8]
 80a155a:	1e43      	subs	r3, r0, #1
 80a155c:	f89c 6006 	ldrb.w	r6, [ip, #6]
 80a1560:	f106 0109 	add.w	r1, r6, #9
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1564:	1e6e      	subs	r6, r5, #1
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1566:	40cb      	lsrs	r3, r1
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1568:	40ce      	lsrs	r6, r1
  if (nNew < nCur || m_curPosition == 0) {
 80a156a:	42b3      	cmp	r3, r6
 80a156c:	d800      	bhi.n	80a1570 <_ZN7FatFile7seekSetEm+0x5a>
 80a156e:	b998      	cbnz	r0, 80a1598 <_ZN7FatFile7seekSetEm+0x82>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
 80a1570:	0653      	lsls	r3, r2, #25
 80a1572:	bf4c      	ite	mi
 80a1574:	f8dc 3020 	ldrmi.w	r3, [ip, #32]
 80a1578:	6a23      	ldrpl	r3, [r4, #32]
 80a157a:	6123      	str	r3, [r4, #16]
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
 80a157c:	f104 0810 	add.w	r8, r4, #16
  while (nNew--) {
 80a1580:	2e00      	cmp	r6, #0
 80a1582:	d0d4      	beq.n	80a152e <_ZN7FatFile7seekSetEm+0x18>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
 80a1584:	4642      	mov	r2, r8
 80a1586:	6921      	ldr	r1, [r4, #16]
 80a1588:	68a0      	ldr	r0, [r4, #8]
 80a158a:	f000 ff2d 	bl	80a23e8 <_ZN9FatVolume6fatGetEmPm>
 80a158e:	2800      	cmp	r0, #0
 80a1590:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
 80a1594:	dcf4      	bgt.n	80a1580 <_ZN7FatFile7seekSetEm+0x6a>
 80a1596:	e7d2      	b.n	80a153e <_ZN7FatFile7seekSetEm+0x28>
    nNew -= nCur;
 80a1598:	1af6      	subs	r6, r6, r3
 80a159a:	e7ef      	b.n	80a157c <_ZN7FatFile7seekSetEm+0x66>

080a159c <_ZN7FatFile15openCachedEntryEPS_tih>:
                              oflag_t oflag, uint8_t lfnOrd) {
 80a159c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a159e:	460f      	mov	r7, r1
 80a15a0:	4604      	mov	r4, r0
 80a15a2:	4616      	mov	r6, r2
  memset(this, 0, sizeof(FatFile));
 80a15a4:	2100      	movs	r1, #0
 80a15a6:	2224      	movs	r2, #36	; 0x24
                              oflag_t oflag, uint8_t lfnOrd) {
 80a15a8:	461d      	mov	r5, r3
  memset(this, 0, sizeof(FatFile));
 80a15aa:	f006 f985 	bl	80a78b8 <memset>
  m_vol = dirFile->m_vol;
 80a15ae:	68b8      	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
 80a15b0:	80a6      	strh	r6, [r4, #4]
  m_vol = dirFile->m_vol;
 80a15b2:	60a0      	str	r0, [r4, #8]
  m_dirCluster = dirFile->m_firstCluster;
 80a15b4:	6a3b      	ldr	r3, [r7, #32]
 80a15b6:	f006 060f 	and.w	r6, r6, #15
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
 80a15ba:	f100 0230 	add.w	r2, r0, #48	; 0x30
  m_dirCluster = dirFile->m_firstCluster;
 80a15be:	60e3      	str	r3, [r4, #12]
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
 80a15c0:	0171      	lsls	r1, r6, #5
 80a15c2:	eb02 1646 	add.w	r6, r2, r6, lsl #5
  if (!DIR_IS_FILE_OR_SUBDIR(dir)) {
 80a15c6:	7af3      	ldrb	r3, [r6, #11]
 80a15c8:	071f      	lsls	r7, r3, #28
 80a15ca:	d446      	bmi.n	80a165a <_ZN7FatFile15openCachedEntryEPS_tih+0xbe>
  m_attr = dir->attributes & FILE_ATTR_COPY;
 80a15cc:	1843      	adds	r3, r0, r1
 80a15ce:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
 80a15d2:	f003 0317 	and.w	r3, r3, #23
 80a15d6:	7023      	strb	r3, [r4, #0]
  if (DIR_IS_FILE(dir)) {
 80a15d8:	7af2      	ldrb	r2, [r6, #11]
 80a15da:	f012 0f18 	tst.w	r2, #24
    m_attr |= FILE_ATTR_FILE;
 80a15de:	bf04      	itt	eq
 80a15e0:	f043 0308 	orreq.w	r3, r3, #8
 80a15e4:	7023      	strbeq	r3, [r4, #0]
  m_lfnOrd = lfnOrd;
 80a15e6:	f89d 3018 	ldrb.w	r3, [sp, #24]
 80a15ea:	70e3      	strb	r3, [r4, #3]
  switch (oflag & O_ACCMODE) {
 80a15ec:	f005 0303 	and.w	r3, r5, #3
 80a15f0:	2b01      	cmp	r3, #1
 80a15f2:	d02c      	beq.n	80a164e <_ZN7FatFile15openCachedEntryEPS_tih+0xb2>
 80a15f4:	2b02      	cmp	r3, #2
 80a15f6:	d028      	beq.n	80a164a <_ZN7FatFile15openCachedEntryEPS_tih+0xae>
 80a15f8:	bb7b      	cbnz	r3, 80a165a <_ZN7FatFile15openCachedEntryEPS_tih+0xbe>
      if (oflag & O_TRUNC) {
 80a15fa:	056a      	lsls	r2, r5, #21
 80a15fc:	d42d      	bmi.n	80a165a <_ZN7FatFile15openCachedEntryEPS_tih+0xbe>
      m_flags = F_READ;
 80a15fe:	2301      	movs	r3, #1
      m_flags = F_WRITE;
 80a1600:	70a3      	strb	r3, [r4, #2]
  if (m_flags & F_WRITE) {
 80a1602:	78a2      	ldrb	r2, [r4, #2]
 80a1604:	0793      	lsls	r3, r2, #30
 80a1606:	d504      	bpl.n	80a1612 <_ZN7FatFile15openCachedEntryEPS_tih+0x76>
    if (isSubDir() || isReadOnly()) {
 80a1608:	7823      	ldrb	r3, [r4, #0]
 80a160a:	06df      	lsls	r7, r3, #27
 80a160c:	d425      	bmi.n	80a165a <_ZN7FatFile15openCachedEntryEPS_tih+0xbe>
 80a160e:	07de      	lsls	r6, r3, #31
 80a1610:	d423      	bmi.n	80a165a <_ZN7FatFile15openCachedEntryEPS_tih+0xbe>
  m_flags |= (oflag & O_APPEND ? F_APPEND : 0) | (oflag & O_SYNC ? F_SYNC : 0);
 80a1612:	11ab      	asrs	r3, r5, #6
 80a1614:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80a1618:	f005 0608 	and.w	r6, r5, #8
 80a161c:	4333      	orrs	r3, r6
 80a161e:	4313      	orrs	r3, r2
 80a1620:	70a3      	strb	r3, [r4, #2]
    return m_cache.lbn();
 80a1622:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  m_dirBlock = m_vol->cacheBlockNumber();
 80a1624:	61a3      	str	r3, [r4, #24]
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
 80a1626:	1843      	adds	r3, r0, r1
 80a1628:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
                 | dir->firstClusterLow;
 80a162c:	f8b3 104a 	ldrh.w	r1, [r3, #74]	; 0x4a
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
 80a1630:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
  if (oflag & O_TRUNC) {
 80a1634:	056a      	lsls	r2, r5, #21
 80a1636:	d513      	bpl.n	80a1660 <_ZN7FatFile15openCachedEntryEPS_tih+0xc4>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
 80a1638:	b959      	cbnz	r1, 80a1652 <_ZN7FatFile15openCachedEntryEPS_tih+0xb6>
    m_flags |= F_FILE_DIR_DIRTY;
 80a163a:	78a3      	ldrb	r3, [r4, #2]
 80a163c:	f043 0304 	orr.w	r3, r3, #4
 80a1640:	70a3      	strb	r3, [r4, #2]
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
 80a1642:	046b      	lsls	r3, r5, #17
 80a1644:	d410      	bmi.n	80a1668 <_ZN7FatFile15openCachedEntryEPS_tih+0xcc>
  return true;
 80a1646:	2001      	movs	r0, #1
}
 80a1648:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      m_flags = F_READ | F_WRITE;
 80a164a:	2303      	movs	r3, #3
 80a164c:	e7d8      	b.n	80a1600 <_ZN7FatFile15openCachedEntryEPS_tih+0x64>
      m_flags = F_WRITE;
 80a164e:	2302      	movs	r3, #2
 80a1650:	e7d6      	b.n	80a1600 <_ZN7FatFile15openCachedEntryEPS_tih+0x64>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
 80a1652:	f000 ff69 	bl	80a2528 <_ZN9FatVolume9freeChainEm>
 80a1656:	2800      	cmp	r0, #0
 80a1658:	d1ef      	bne.n	80a163a <_ZN7FatFile15openCachedEntryEPS_tih+0x9e>
  m_attr = FILE_ATTR_CLOSED;
 80a165a:	2000      	movs	r0, #0
 80a165c:	7020      	strb	r0, [r4, #0]
  return false;
 80a165e:	e7f3      	b.n	80a1648 <_ZN7FatFile15openCachedEntryEPS_tih+0xac>
    m_firstCluster = firstCluster;
 80a1660:	6221      	str	r1, [r4, #32]
    m_fileSize = dir->fileSize;
 80a1662:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a1664:	61e3      	str	r3, [r4, #28]
 80a1666:	e7ec      	b.n	80a1642 <_ZN7FatFile15openCachedEntryEPS_tih+0xa6>
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
 80a1668:	4620      	mov	r0, r4
 80a166a:	69e1      	ldr	r1, [r4, #28]
 80a166c:	f7ff ff53 	bl	80a1516 <_ZN7FatFile7seekSetEm>
 80a1670:	2800      	cmp	r0, #0
 80a1672:	d1e8      	bne.n	80a1646 <_ZN7FatFile15openCachedEntryEPS_tih+0xaa>
 80a1674:	e7f1      	b.n	80a165a <_ZN7FatFile15openCachedEntryEPS_tih+0xbe>

080a1676 <_ZN7FatFile8openNextEPS_i>:
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
 80a1676:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
 80a167a:	7803      	ldrb	r3, [r0, #0]
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
 80a167c:	4606      	mov	r6, r0
 80a167e:	460d      	mov	r5, r1
 80a1680:	4617      	mov	r7, r2
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
 80a1682:	bb5b      	cbnz	r3, 80a16dc <_ZN7FatFile8openNextEPS_i+0x66>
 80a1684:	780b      	ldrb	r3, [r1, #0]
 80a1686:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a168a:	d027      	beq.n	80a16dc <_ZN7FatFile8openNextEPS_i+0x66>
 80a168c:	694c      	ldr	r4, [r1, #20]
 80a168e:	f014 041f 	ands.w	r4, r4, #31
 80a1692:	d123      	bne.n	80a16dc <_ZN7FatFile8openNextEPS_i+0x66>
 80a1694:	46a0      	mov	r8, r4
    dir_t* dir = dirFile->readDirCache();
 80a1696:	2100      	movs	r1, #0
 80a1698:	4628      	mov	r0, r5
    index = dirFile->curPosition()/32;
 80a169a:	f8d5 9014 	ldr.w	r9, [r5, #20]
    dir_t* dir = dirFile->readDirCache();
 80a169e:	f7ff ff1b 	bl	80a14d8 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
 80a16a2:	b1d8      	cbz	r0, 80a16dc <_ZN7FatFile8openNextEPS_i+0x66>
    if (dir->name[0] == DIR_NAME_FREE) {
 80a16a4:	7802      	ldrb	r2, [r0, #0]
 80a16a6:	b1ca      	cbz	r2, 80a16dc <_ZN7FatFile8openNextEPS_i+0x66>
    if (dir->name[0] == '.' || dir->name[0] == DIR_NAME_DELETED) {
 80a16a8:	2a2e      	cmp	r2, #46	; 0x2e
 80a16aa:	d011      	beq.n	80a16d0 <_ZN7FatFile8openNextEPS_i+0x5a>
 80a16ac:	2ae5      	cmp	r2, #229	; 0xe5
 80a16ae:	d00f      	beq.n	80a16d0 <_ZN7FatFile8openNextEPS_i+0x5a>
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
 80a16b0:	7ac1      	ldrb	r1, [r0, #11]
 80a16b2:	f011 0f08 	tst.w	r1, #8
 80a16b6:	d113      	bne.n	80a16e0 <_ZN7FatFile8openNextEPS_i+0x6a>
      if (lfnOrd && chksum != lfnChecksum(dir->name)) {
 80a16b8:	b964      	cbnz	r4, 80a16d4 <_ZN7FatFile8openNextEPS_i+0x5e>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
 80a16ba:	463b      	mov	r3, r7
 80a16bc:	4629      	mov	r1, r5
 80a16be:	4630      	mov	r0, r6
 80a16c0:	9400      	str	r4, [sp, #0]
 80a16c2:	f3c9 124f 	ubfx	r2, r9, #5, #16
 80a16c6:	f7ff ff69 	bl	80a159c <_ZN7FatFile15openCachedEntryEPS_tih>
}
 80a16ca:	b003      	add	sp, #12
 80a16cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      lfnOrd = 0;
 80a16d0:	2400      	movs	r4, #0
 80a16d2:	e7e0      	b.n	80a1696 <_ZN7FatFile8openNextEPS_i+0x20>
      if (lfnOrd && chksum != lfnChecksum(dir->name)) {
 80a16d4:	f000 f97a 	bl	80a19cc <_ZN7FatFile11lfnChecksumEPh>
 80a16d8:	4540      	cmp	r0, r8
 80a16da:	d0ee      	beq.n	80a16ba <_ZN7FatFile8openNextEPS_i+0x44>
  return false;
 80a16dc:	2000      	movs	r0, #0
 80a16de:	e7f4      	b.n	80a16ca <_ZN7FatFile8openNextEPS_i+0x54>
    } else if (DIR_IS_LONG_NAME(dir)) {
 80a16e0:	290f      	cmp	r1, #15
 80a16e2:	d1f5      	bne.n	80a16d0 <_ZN7FatFile8openNextEPS_i+0x5a>
      if (ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) {
 80a16e4:	0651      	lsls	r1, r2, #25
 80a16e6:	d5d6      	bpl.n	80a1696 <_ZN7FatFile8openNextEPS_i+0x20>
        chksum = ldir->chksum;
 80a16e8:	f890 800d 	ldrb.w	r8, [r0, #13]
        lfnOrd = ldir->ord & 0X1F;
 80a16ec:	f002 041f 	and.w	r4, r2, #31
        chksum = ldir->chksum;
 80a16f0:	e7d1      	b.n	80a1696 <_ZN7FatFile8openNextEPS_i+0x20>
	...

080a16f4 <_ZN7FatFile4syncEv>:
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
 80a16f4:	b538      	push	{r3, r4, r5, lr}
  if (!isOpen()) {
 80a16f6:	7803      	ldrb	r3, [r0, #0]
bool FatFile::sync() {
 80a16f8:	4604      	mov	r4, r0
  if (!isOpen()) {
 80a16fa:	b90b      	cbnz	r3, 80a1700 <_ZN7FatFile4syncEv+0xc>
    return true;
 80a16fc:	2001      	movs	r0, #1
  DBG_FAIL_MACRO;

fail:
  m_error |= WRITE_ERROR;
  return false;
}
 80a16fe:	bd38      	pop	{r3, r4, r5, pc}
  if (m_flags & F_FILE_DIR_DIRTY) {
 80a1700:	7883      	ldrb	r3, [r0, #2]
 80a1702:	075a      	lsls	r2, r3, #29
 80a1704:	d523      	bpl.n	80a174e <_ZN7FatFile4syncEv+0x5a>
    dir_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
 80a1706:	2101      	movs	r1, #1
 80a1708:	f7ff fdd2 	bl	80a12b0 <_ZN7FatFile13cacheDirEntryEh>
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
 80a170c:	4605      	mov	r5, r0
 80a170e:	b928      	cbnz	r0, 80a171c <_ZN7FatFile4syncEv+0x28>
  m_error |= WRITE_ERROR;
 80a1710:	7863      	ldrb	r3, [r4, #1]
  return false;
 80a1712:	2000      	movs	r0, #0
  m_error |= WRITE_ERROR;
 80a1714:	f043 0301 	orr.w	r3, r3, #1
 80a1718:	7063      	strb	r3, [r4, #1]
  return false;
 80a171a:	e7f0      	b.n	80a16fe <_ZN7FatFile4syncEv+0xa>
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
 80a171c:	7803      	ldrb	r3, [r0, #0]
 80a171e:	2be5      	cmp	r3, #229	; 0xe5
 80a1720:	d0f6      	beq.n	80a1710 <_ZN7FatFile4syncEv+0x1c>
    if (isFile()) {
 80a1722:	7823      	ldrb	r3, [r4, #0]
 80a1724:	071b      	lsls	r3, r3, #28
      dir->fileSize = m_fileSize;
 80a1726:	bf44      	itt	mi
 80a1728:	69e3      	ldrmi	r3, [r4, #28]
 80a172a:	61c3      	strmi	r3, [r0, #28]
    dir->firstClusterLow = m_firstCluster & 0XFFFF;
 80a172c:	8c23      	ldrh	r3, [r4, #32]
 80a172e:	8343      	strh	r3, [r0, #26]
    dir->firstClusterHigh = m_firstCluster >> 16;
 80a1730:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 80a1732:	8283      	strh	r3, [r0, #20]
    if (m_dateTime) {
 80a1734:	4b09      	ldr	r3, [pc, #36]	; (80a175c <_ZN7FatFile4syncEv+0x68>)
 80a1736:	681b      	ldr	r3, [r3, #0]
 80a1738:	b12b      	cbz	r3, 80a1746 <_ZN7FatFile4syncEv+0x52>
      m_dateTime(&dir->lastWriteDate, &dir->lastWriteTime);
 80a173a:	f100 0116 	add.w	r1, r0, #22
 80a173e:	3018      	adds	r0, #24
 80a1740:	4798      	blx	r3
      dir->lastAccessDate = dir->lastWriteDate;
 80a1742:	8b2b      	ldrh	r3, [r5, #24]
 80a1744:	826b      	strh	r3, [r5, #18]
    m_flags &= ~F_FILE_DIR_DIRTY;
 80a1746:	78a3      	ldrb	r3, [r4, #2]
 80a1748:	f023 0304 	bic.w	r3, r3, #4
 80a174c:	70a3      	strb	r3, [r4, #2]
  if (m_vol->cacheSync()) {
 80a174e:	68a0      	ldr	r0, [r4, #8]
 80a1750:	f7ff fd58 	bl	80a1204 <_ZN9FatVolume9cacheSyncEv>
 80a1754:	2800      	cmp	r0, #0
 80a1756:	d0db      	beq.n	80a1710 <_ZN7FatFile4syncEv+0x1c>
 80a1758:	e7d0      	b.n	80a16fc <_ZN7FatFile4syncEv+0x8>
 80a175a:	bf00      	nop
 80a175c:	20001614 	.word	0x20001614

080a1760 <_ZN7FatFile5closeEv>:
bool FatFile::close() {
 80a1760:	b510      	push	{r4, lr}
 80a1762:	4604      	mov	r4, r0
  bool rtn = sync();
 80a1764:	f7ff ffc6 	bl	80a16f4 <_ZN7FatFile4syncEv>
  m_attr = FILE_ATTR_CLOSED;
 80a1768:	2300      	movs	r3, #0
 80a176a:	7023      	strb	r3, [r4, #0]
}
 80a176c:	bd10      	pop	{r4, pc}

080a176e <_ZN7FatFile4openEPS_PKci>:
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
 80a176e:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a1770:	461f      	mov	r7, r3
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
 80a1772:	2300      	movs	r3, #0
 80a1774:	b093      	sub	sp, #76	; 0x4c
 80a1776:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
  if (isOpen() || !dirFile->isDir()) {
 80a177a:	7803      	ldrb	r3, [r0, #0]
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
 80a177c:	4606      	mov	r6, r0
 80a177e:	460c      	mov	r4, r1
 80a1780:	9201      	str	r2, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
 80a1782:	b113      	cbz	r3, 80a178a <_ZN7FatFile4openEPS_PKci+0x1c>
  return false;
 80a1784:	2000      	movs	r0, #0
}
 80a1786:	b013      	add	sp, #76	; 0x4c
 80a1788:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (isOpen() || !dirFile->isDir()) {
 80a178a:	780b      	ldrb	r3, [r1, #0]
 80a178c:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a1790:	d0f8      	beq.n	80a1784 <_ZN7FatFile4openEPS_PKci+0x16>
  if (isDirSeparator(*path)) {
 80a1792:	7813      	ldrb	r3, [r2, #0]
 80a1794:	2b2f      	cmp	r3, #47	; 0x2f
 80a1796:	d112      	bne.n	80a17be <_ZN7FatFile4openEPS_PKci+0x50>
    while (isDirSeparator(*path)) {
 80a1798:	9a01      	ldr	r2, [sp, #4]
 80a179a:	7813      	ldrb	r3, [r2, #0]
 80a179c:	2b2f      	cmp	r3, #47	; 0x2f
 80a179e:	d102      	bne.n	80a17a6 <_ZN7FatFile4openEPS_PKci+0x38>
      path++;
 80a17a0:	3201      	adds	r2, #1
 80a17a2:	9201      	str	r2, [sp, #4]
    while (isDirSeparator(*path)) {
 80a17a4:	e7f8      	b.n	80a1798 <_ZN7FatFile4openEPS_PKci+0x2a>
    if (*path == 0) {
 80a17a6:	68a1      	ldr	r1, [r4, #8]
 80a17a8:	b91b      	cbnz	r3, 80a17b2 <_ZN7FatFile4openEPS_PKci+0x44>
      return openRoot(dirFile->m_vol);
 80a17aa:	4630      	mov	r0, r6
 80a17ac:	f7ff fdba 	bl	80a1324 <_ZN7FatFile8openRootEP9FatVolume>
 80a17b0:	e7e9      	b.n	80a1786 <_ZN7FatFile4openEPS_PKci+0x18>
    if (!tmpDir.openRoot(dirFile->m_vol)) {
 80a17b2:	a809      	add	r0, sp, #36	; 0x24
 80a17b4:	f7ff fdb6 	bl	80a1324 <_ZN7FatFile8openRootEP9FatVolume>
 80a17b8:	2800      	cmp	r0, #0
 80a17ba:	d0e3      	beq.n	80a1784 <_ZN7FatFile4openEPS_PKci+0x16>
    dirFile = &tmpDir;
 80a17bc:	ac09      	add	r4, sp, #36	; 0x24
    if (!parsePathName(path, &fname, &path)) {
 80a17be:	9801      	ldr	r0, [sp, #4]
 80a17c0:	aa01      	add	r2, sp, #4
 80a17c2:	a903      	add	r1, sp, #12
 80a17c4:	f000 f928 	bl	80a1a18 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>
 80a17c8:	2800      	cmp	r0, #0
 80a17ca:	d0db      	beq.n	80a1784 <_ZN7FatFile4openEPS_PKci+0x16>
    if (*path == 0) {
 80a17cc:	9b01      	ldr	r3, [sp, #4]
 80a17ce:	781b      	ldrb	r3, [r3, #0]
 80a17d0:	b19b      	cbz	r3, 80a17fa <_ZN7FatFile4openEPS_PKci+0x8c>
    if (!open(dirFile, &fname, O_RDONLY)) {
 80a17d2:	2300      	movs	r3, #0
 80a17d4:	4621      	mov	r1, r4
 80a17d6:	4630      	mov	r0, r6
 80a17d8:	aa03      	add	r2, sp, #12
 80a17da:	f000 fab1 	bl	80a1d40 <_ZN7FatFile4openEPS_P7fname_ti>
 80a17de:	2800      	cmp	r0, #0
 80a17e0:	d0d0      	beq.n	80a1784 <_ZN7FatFile4openEPS_PKci+0x16>
    tmpDir = *this;
 80a17e2:	4635      	mov	r5, r6
 80a17e4:	ac09      	add	r4, sp, #36	; 0x24
 80a17e6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a17e8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a17ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a17ec:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a17ee:	682b      	ldr	r3, [r5, #0]
    close();
 80a17f0:	4630      	mov	r0, r6
    tmpDir = *this;
 80a17f2:	6023      	str	r3, [r4, #0]
    close();
 80a17f4:	f7ff ffb4 	bl	80a1760 <_ZN7FatFile5closeEv>
  while (1) {
 80a17f8:	e7e0      	b.n	80a17bc <_ZN7FatFile4openEPS_PKci+0x4e>
  return open(dirFile, &fname, oflag);
 80a17fa:	463b      	mov	r3, r7
 80a17fc:	4621      	mov	r1, r4
 80a17fe:	4630      	mov	r0, r6
 80a1800:	aa03      	add	r2, sp, #12
 80a1802:	f000 fa9d 	bl	80a1d40 <_ZN7FatFile4openEPS_P7fname_ti>
 80a1806:	e7be      	b.n	80a1786 <_ZN7FatFile4openEPS_PKci+0x18>

080a1808 <_ZN7FatFile8dirEntryEP14directoryEntry>:
bool FatFile::dirEntry(dir_t* dst) {
 80a1808:	b570      	push	{r4, r5, r6, lr}
 80a180a:	4606      	mov	r6, r0
 80a180c:	460c      	mov	r4, r1
  if (!sync()) {
 80a180e:	f7ff ff71 	bl	80a16f4 <_ZN7FatFile4syncEv>
 80a1812:	4605      	mov	r5, r0
 80a1814:	b910      	cbnz	r0, 80a181c <_ZN7FatFile8dirEntryEP14directoryEntry+0x14>
  return false;
 80a1816:	2500      	movs	r5, #0
}
 80a1818:	4628      	mov	r0, r5
 80a181a:	bd70      	pop	{r4, r5, r6, pc}
  dir = cacheDirEntry(FatCache::CACHE_FOR_READ);
 80a181c:	2100      	movs	r1, #0
 80a181e:	4630      	mov	r0, r6
 80a1820:	f7ff fd46 	bl	80a12b0 <_ZN7FatFile13cacheDirEntryEh>
  if (!dir) {
 80a1824:	4603      	mov	r3, r0
 80a1826:	2800      	cmp	r0, #0
 80a1828:	d0f5      	beq.n	80a1816 <_ZN7FatFile8dirEntryEP14directoryEntry+0xe>
  memcpy(dst, dir, sizeof(dir_t));
 80a182a:	4621      	mov	r1, r4
 80a182c:	f100 0220 	add.w	r2, r0, #32
 80a1830:	f853 0b04 	ldr.w	r0, [r3], #4
 80a1834:	4293      	cmp	r3, r2
 80a1836:	f841 0b04 	str.w	r0, [r1], #4
 80a183a:	d1f9      	bne.n	80a1830 <_ZN7FatFile8dirEntryEP14directoryEntry+0x28>
 80a183c:	e7ec      	b.n	80a1818 <_ZN7FatFile8dirEntryEP14directoryEntry+0x10>
	...

080a1840 <_ZN7FatFile5writeEPKvj>:

fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::write(const void* buf, size_t nbyte) {
 80a1840:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isFile() || !(m_flags & F_WRITE)) {
 80a1844:	7803      	ldrb	r3, [r0, #0]
int FatFile::write(const void* buf, size_t nbyte) {
 80a1846:	4689      	mov	r9, r1
  if (!isFile() || !(m_flags & F_WRITE)) {
 80a1848:	0719      	lsls	r1, r3, #28
int FatFile::write(const void* buf, size_t nbyte) {
 80a184a:	4604      	mov	r4, r0
 80a184c:	4617      	mov	r7, r2
  if (!isFile() || !(m_flags & F_WRITE)) {
 80a184e:	d55b      	bpl.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
 80a1850:	7883      	ldrb	r3, [r0, #2]
 80a1852:	079a      	lsls	r2, r3, #30
 80a1854:	d558      	bpl.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & F_APPEND)) {
 80a1856:	071b      	lsls	r3, r3, #28
 80a1858:	d451      	bmi.n	80a18fe <_ZN7FatFile5writeEPKvj+0xbe>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
 80a185a:	6963      	ldr	r3, [r4, #20]
 80a185c:	43db      	mvns	r3, r3
 80a185e:	42bb      	cmp	r3, r7
 80a1860:	d352      	bcc.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
 80a1862:	46b8      	mov	r8, r7
    uint8_t blockOfCluster = m_vol->blockOfCluster(m_curPosition);
    uint16_t blockOffset = m_curPosition & 0X1FF;
    if (blockOfCluster == 0 && blockOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
        int8_t fg = m_vol->fatGet(m_curCluster, &m_curCluster);
 80a1864:	f104 0a10 	add.w	sl, r4, #16
  while (nToWrite) {
 80a1868:	6966      	ldr	r6, [r4, #20]
 80a186a:	f1b8 0f00 	cmp.w	r8, #0
 80a186e:	f000 8091 	beq.w	80a1994 <_ZN7FatFile5writeEPKvj+0x154>
    uint8_t blockOfCluster = m_vol->blockOfCluster(m_curPosition);
 80a1872:	68a0      	ldr	r0, [r4, #8]
    uint16_t blockOffset = m_curPosition & 0X1FF;
 80a1874:	f3c6 0508 	ubfx	r5, r6, #0, #9
    return (position >> 9) & m_clusterBlockMask;
 80a1878:	7943      	ldrb	r3, [r0, #5]
    if (blockOfCluster == 0 && blockOffset == 0) {
 80a187a:	ea13 2656 	ands.w	r6, r3, r6, lsr #9
 80a187e:	d10e      	bne.n	80a189e <_ZN7FatFile5writeEPKvj+0x5e>
 80a1880:	b96d      	cbnz	r5, 80a189e <_ZN7FatFile5writeEPKvj+0x5e>
 80a1882:	6921      	ldr	r1, [r4, #16]
      if (m_curCluster != 0) {
 80a1884:	2900      	cmp	r1, #0
 80a1886:	d046      	beq.n	80a1916 <_ZN7FatFile5writeEPKvj+0xd6>
        int8_t fg = m_vol->fatGet(m_curCluster, &m_curCluster);
 80a1888:	4652      	mov	r2, sl
 80a188a:	f000 fdad 	bl	80a23e8 <_ZN9FatVolume6fatGetEmPm>
        if (fg < 0) {
 80a188e:	2800      	cmp	r0, #0
 80a1890:	db3a      	blt.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
 80a1892:	d104      	bne.n	80a189e <_ZN7FatFile5writeEPKvj+0x5e>
          // add cluster if at end of chain
          if (!addCluster()) {
 80a1894:	4620      	mov	r0, r4
 80a1896:	f7ff fcc2 	bl	80a121e <_ZN7FatFile10addClusterEv>
 80a189a:	2800      	cmp	r0, #0
 80a189c:	d034      	beq.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // block for data write
    uint32_t block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
 80a189e:	6921      	ldr	r1, [r4, #16]
 80a18a0:	68a0      	ldr	r0, [r4, #8]
 80a18a2:	f000 fd9b 	bl	80a23dc <_ZNK9FatVolume17clusterFirstBlockEm>
 80a18a6:	1831      	adds	r1, r6, r0

    if (blockOffset != 0 || nToWrite < 512) {
 80a18a8:	68a0      	ldr	r0, [r4, #8]
 80a18aa:	b915      	cbnz	r5, 80a18b2 <_ZN7FatFile5writeEPKvj+0x72>
 80a18ac:	f5b8 7f00 	cmp.w	r8, #512	; 0x200
 80a18b0:	d23f      	bcs.n	80a1932 <_ZN7FatFile5writeEPKvj+0xf2>
      // partial block - must use cache
      // max space in block
      n = 512 - blockOffset;
 80a18b2:	f5c5 7600 	rsb	r6, r5, #512	; 0x200
      // lesser of space and amount to write
      if (n > nToWrite) {
 80a18b6:	4546      	cmp	r6, r8
 80a18b8:	bf28      	it	cs
 80a18ba:	4646      	movcs	r6, r8
        n = nToWrite;
      }

      if (blockOffset == 0 && m_curPosition >= m_fileSize) {
 80a18bc:	2d00      	cmp	r5, #0
 80a18be:	d136      	bne.n	80a192e <_ZN7FatFile5writeEPKvj+0xee>
 80a18c0:	6962      	ldr	r2, [r4, #20]
 80a18c2:	69e3      	ldr	r3, [r4, #28]
        // start of new block don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
 80a18c4:	429a      	cmp	r2, r3
 80a18c6:	bf34      	ite	cc
 80a18c8:	2201      	movcc	r2, #1
 80a18ca:	2205      	movcs	r2, #5
    return m_cache.read(blockNumber, options);
 80a18cc:	3024      	adds	r0, #36	; 0x24
 80a18ce:	f000 fd62 	bl	80a2396 <_ZN8FatCache4readEmh>
      } else {
        // rewrite part of block
        cacheOption = FatCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(block, cacheOption);
      if (!pc) {
 80a18d2:	b1c8      	cbz	r0, 80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + blockOffset;
      memcpy(dst, src, n);
 80a18d4:	4428      	add	r0, r5
 80a18d6:	4632      	mov	r2, r6
 80a18d8:	4649      	mov	r1, r9
      if (512 == (n + blockOffset)) {
 80a18da:	4435      	add	r5, r6
      memcpy(dst, src, n);
 80a18dc:	f005 ffc4 	bl	80a7868 <memcpy>
      if (512 == (n + blockOffset)) {
 80a18e0:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 80a18e4:	d104      	bne.n	80a18f0 <_ZN7FatFile5writeEPKvj+0xb0>
    return m_cache.sync();
 80a18e6:	68a0      	ldr	r0, [r4, #8]
 80a18e8:	3024      	adds	r0, #36	; 0x24
 80a18ea:	f000 fd2d 	bl	80a2348 <_ZN8FatCache4syncEv>
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
        // invalidate cache if block is in cache
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeBlocks(block, src, nb)) {
 80a18ee:	b158      	cbz	r0, 80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
      if (!m_vol->writeBlock(block, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
 80a18f0:	6963      	ldr	r3, [r4, #20]
    src += n;
 80a18f2:	44b1      	add	r9, r6
    m_curPosition += n;
 80a18f4:	4433      	add	r3, r6
 80a18f6:	6163      	str	r3, [r4, #20]
    nToWrite -= n;
 80a18f8:	eba8 0806 	sub.w	r8, r8, r6
  while (nToWrite) {
 80a18fc:	e7b4      	b.n	80a1868 <_ZN7FatFile5writeEPKvj+0x28>
    if (!seekSet(m_fileSize)) {
 80a18fe:	69c1      	ldr	r1, [r0, #28]
 80a1900:	f7ff fe09 	bl	80a1516 <_ZN7FatFile7seekSetEm>
 80a1904:	2800      	cmp	r0, #0
 80a1906:	d1a8      	bne.n	80a185a <_ZN7FatFile5writeEPKvj+0x1a>
  }
  return nbyte;

fail:
  // return for write error
  m_error |= WRITE_ERROR;
 80a1908:	7863      	ldrb	r3, [r4, #1]
  return -1;
 80a190a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  m_error |= WRITE_ERROR;
 80a190e:	f043 0301 	orr.w	r3, r3, #1
 80a1912:	7063      	strb	r3, [r4, #1]
  return -1;
 80a1914:	e050      	b.n	80a19b8 <_ZN7FatFile5writeEPKvj+0x178>
        if (m_firstCluster == 0) {
 80a1916:	6a23      	ldr	r3, [r4, #32]
 80a1918:	b93b      	cbnz	r3, 80a192a <_ZN7FatFile5writeEPKvj+0xea>
          if (!addCluster()) {
 80a191a:	4620      	mov	r0, r4
 80a191c:	f7ff fc7f 	bl	80a121e <_ZN7FatFile10addClusterEv>
 80a1920:	2800      	cmp	r0, #0
 80a1922:	d0f1      	beq.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
          m_firstCluster = m_curCluster;
 80a1924:	6923      	ldr	r3, [r4, #16]
 80a1926:	6223      	str	r3, [r4, #32]
 80a1928:	e7b9      	b.n	80a189e <_ZN7FatFile5writeEPKvj+0x5e>
          m_curCluster = m_firstCluster;
 80a192a:	6123      	str	r3, [r4, #16]
 80a192c:	e7b7      	b.n	80a189e <_ZN7FatFile5writeEPKvj+0x5e>
        cacheOption = FatCache::CACHE_FOR_WRITE;
 80a192e:	2201      	movs	r2, #1
 80a1930:	e7cc      	b.n	80a18cc <_ZN7FatFile5writeEPKvj+0x8c>
    } else if (nToWrite >= 1024) {
 80a1932:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
 80a1936:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80a1938:	d31b      	bcc.n	80a1972 <_ZN7FatFile5writeEPKvj+0x132>
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
 80a193a:	f890 c004 	ldrb.w	ip, [r0, #4]
      size_t nb = nToWrite >> 9;
 80a193e:	ea4f 2e58 	mov.w	lr, r8, lsr #9
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
 80a1942:	ebac 0606 	sub.w	r6, ip, r6
      if (nb > maxBlocks) {
 80a1946:	b2f3      	uxtb	r3, r6
 80a1948:	4573      	cmp	r3, lr
 80a194a:	bf28      	it	cs
 80a194c:	4673      	movcs	r3, lr
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a194e:	4291      	cmp	r1, r2
      n = 512*nb;
 80a1950:	ea4f 2643 	mov.w	r6, r3, lsl #9
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a1954:	d307      	bcc.n	80a1966 <_ZN7FatFile5writeEPKvj+0x126>
 80a1956:	441a      	add	r2, r3
 80a1958:	428a      	cmp	r2, r1
    m_lbn = 0XFFFFFFFF;
 80a195a:	bf82      	ittt	hi
 80a195c:	f04f 32ff 	movhi.w	r2, #4294967295	; 0xffffffff
    m_status = 0;
 80a1960:	f880 5024 	strbhi.w	r5, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
 80a1964:	62c2      	strhi	r2, [r0, #44]	; 0x2c
      if (!m_vol->writeBlocks(block, src, nb)) {
 80a1966:	68a5      	ldr	r5, [r4, #8]
    return m_blockDev->writeBlocks(block, src, nb);
 80a1968:	464a      	mov	r2, r9
 80a196a:	6828      	ldr	r0, [r5, #0]
 80a196c:	f001 f93c 	bl	80a2be8 <_ZN9SdSpiCard11writeBlocksEmPKhj>
 80a1970:	e7bd      	b.n	80a18ee <_ZN7FatFile5writeEPKvj+0xae>
      if (m_vol->cacheBlockNumber() == block) {
 80a1972:	4291      	cmp	r1, r2
    m_lbn = 0XFFFFFFFF;
 80a1974:	bf02      	ittt	eq
 80a1976:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    m_status = 0;
 80a197a:	f880 5024 	strbeq.w	r5, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
 80a197e:	62c3      	streq	r3, [r0, #44]	; 0x2c
      if (!m_vol->writeBlock(block, src)) {
 80a1980:	68a3      	ldr	r3, [r4, #8]
    return m_blockDev->writeBlock(block, src);
 80a1982:	464a      	mov	r2, r9
 80a1984:	6818      	ldr	r0, [r3, #0]
 80a1986:	f001 f8ba 	bl	80a2afe <_ZN9SdSpiCard10writeBlockEmPKh>
 80a198a:	2800      	cmp	r0, #0
 80a198c:	d0bc      	beq.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
      n = 512;
 80a198e:	f44f 7600 	mov.w	r6, #512	; 0x200
 80a1992:	e7ad      	b.n	80a18f0 <_ZN7FatFile5writeEPKvj+0xb0>
  if (m_curPosition > m_fileSize) {
 80a1994:	69e2      	ldr	r2, [r4, #28]
 80a1996:	78a3      	ldrb	r3, [r4, #2]
 80a1998:	42b2      	cmp	r2, r6
 80a199a:	d204      	bcs.n	80a19a6 <_ZN7FatFile5writeEPKvj+0x166>
    m_fileSize = m_curPosition;
 80a199c:	61e6      	str	r6, [r4, #28]
    m_flags |= F_FILE_DIR_DIRTY;
 80a199e:	f043 0304 	orr.w	r3, r3, #4
 80a19a2:	70a3      	strb	r3, [r4, #2]
 80a19a4:	e003      	b.n	80a19ae <_ZN7FatFile5writeEPKvj+0x16e>
  } else if (m_dateTime) {
 80a19a6:	4a08      	ldr	r2, [pc, #32]	; (80a19c8 <_ZN7FatFile5writeEPKvj+0x188>)
 80a19a8:	6812      	ldr	r2, [r2, #0]
 80a19aa:	2a00      	cmp	r2, #0
 80a19ac:	d1f7      	bne.n	80a199e <_ZN7FatFile5writeEPKvj+0x15e>
  if (m_flags & F_SYNC) {
 80a19ae:	f994 3002 	ldrsb.w	r3, [r4, #2]
 80a19b2:	2b00      	cmp	r3, #0
 80a19b4:	db02      	blt.n	80a19bc <_ZN7FatFile5writeEPKvj+0x17c>
  return nbyte;
 80a19b6:	4638      	mov	r0, r7
}
 80a19b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!sync()) {
 80a19bc:	4620      	mov	r0, r4
 80a19be:	f7ff fe99 	bl	80a16f4 <_ZN7FatFile4syncEv>
 80a19c2:	2800      	cmp	r0, #0
 80a19c4:	d1f7      	bne.n	80a19b6 <_ZN7FatFile5writeEPKvj+0x176>
 80a19c6:	e79f      	b.n	80a1908 <_ZN7FatFile5writeEPKvj+0xc8>
 80a19c8:	20001614 	.word	0x20001614

080a19cc <_ZN7FatFile11lfnChecksumEPh>:
#include "FatFile.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
 80a19cc:	1e41      	subs	r1, r0, #1
 80a19ce:	f100 030a 	add.w	r3, r0, #10
  uint8_t sum = 0;
 80a19d2:	2000      	movs	r0, #0
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
 80a19d4:	0842      	lsrs	r2, r0, #1
 80a19d6:	ea42 10c0 	orr.w	r0, r2, r0, lsl #7
 80a19da:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 80a19de:	4410      	add	r0, r2
  for (uint8_t i = 0; i < 11; i++) {
 80a19e0:	428b      	cmp	r3, r1
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
 80a19e2:	f000 00ff 	and.w	r0, r0, #255	; 0xff
  for (uint8_t i = 0; i < 11; i++) {
 80a19e6:	d1f5      	bne.n	80a19d4 <_ZN7FatFile11lfnChecksumEPh+0x8>
  }
  return sum;
}
 80a19e8:	4770      	bx	lr

080a19ea <_ZN7FatFile11openClusterEPS_>:
fail:
  name[0] = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
 80a19ea:	b538      	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
 80a19ec:	68cb      	ldr	r3, [r1, #12]
bool FatFile::openCluster(FatFile* file) {
 80a19ee:	4604      	mov	r4, r0
 80a19f0:	460d      	mov	r5, r1
  if (file->m_dirCluster == 0) {
 80a19f2:	b923      	cbnz	r3, 80a19fe <_ZN7FatFile11openClusterEPS_+0x14>
  m_attr = FILE_ATTR_SUBDIR;
  m_flags = F_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
 80a19f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return openRoot(file->m_vol);
 80a19f8:	6889      	ldr	r1, [r1, #8]
 80a19fa:	f7ff bc93 	b.w	80a1324 <_ZN7FatFile8openRootEP9FatVolume>
  memset(this, 0, sizeof(FatFile));
 80a19fe:	2224      	movs	r2, #36	; 0x24
 80a1a00:	2100      	movs	r1, #0
 80a1a02:	f005 ff59 	bl	80a78b8 <memset>
  m_attr = FILE_ATTR_SUBDIR;
 80a1a06:	2310      	movs	r3, #16
  m_flags = F_READ;
 80a1a08:	2001      	movs	r0, #1
  m_attr = FILE_ATTR_SUBDIR;
 80a1a0a:	7023      	strb	r3, [r4, #0]
  m_flags = F_READ;
 80a1a0c:	70a0      	strb	r0, [r4, #2]
  m_vol = file->m_vol;
 80a1a0e:	68ab      	ldr	r3, [r5, #8]
 80a1a10:	60a3      	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
 80a1a12:	68eb      	ldr	r3, [r5, #12]
 80a1a14:	6223      	str	r3, [r4, #32]
}
 80a1a16:	bd38      	pop	{r3, r4, r5, pc}

080a1a18 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
 80a1a18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a1a1c:	4606      	mov	r6, r0
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
 80a1a1e:	f810 3b01 	ldrb.w	r3, [r0], #1
 80a1a22:	2b20      	cmp	r3, #32
 80a1a24:	d0fa      	beq.n	80a1a1c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
 80a1a26:	2400      	movs	r4, #0
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
 80a1a28:	4d6a      	ldr	r5, [pc, #424]	; (80a1bd4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1bc>)
  fname->lfn = path;
 80a1a2a:	608e      	str	r6, [r1, #8]
    c = path[len];
 80a1a2c:	5d33      	ldrb	r3, [r6, r4]
    if (c == 0 || isDirSeparator(c)) {
 80a1a2e:	b1c3      	cbz	r3, 80a1a62 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4a>
 80a1a30:	2b2f      	cmp	r3, #47	; 0x2f
 80a1a32:	d016      	beq.n	80a1a62 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4a>
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
 80a1a34:	2b5c      	cmp	r3, #92	; 0x5c
 80a1a36:	d102      	bne.n	80a1a3e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x26>
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
 80a1a38:	2000      	movs	r0, #0
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
 80a1a3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
 80a1a3e:	f1a3 0022 	sub.w	r0, r3, #34	; 0x22
 80a1a42:	b2c0      	uxtb	r0, r0
 80a1a44:	281d      	cmp	r0, #29
 80a1a46:	d803      	bhi.n	80a1a50 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x38>
 80a1a48:	fa25 f000 	lsr.w	r0, r5, r0
 80a1a4c:	07c0      	lsls	r0, r0, #31
 80a1a4e:	d4f3      	bmi.n	80a1a38 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
 80a1a50:	f003 00bf 	and.w	r0, r3, #191	; 0xbf
 80a1a54:	283c      	cmp	r0, #60	; 0x3c
 80a1a56:	d0ef      	beq.n	80a1a38 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
    if (!lfnLegalChar(c)) {
 80a1a58:	3b20      	subs	r3, #32
 80a1a5a:	2b5e      	cmp	r3, #94	; 0x5e
 80a1a5c:	d8ec      	bhi.n	80a1a38 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
  for (len = 0; ; len++) {
 80a1a5e:	3401      	adds	r4, #1
    c = path[len];
 80a1a60:	e7e4      	b.n	80a1a2c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x14>
 80a1a62:	1933      	adds	r3, r6, r4
  for (len = 0; ; len++) {
 80a1a64:	4618      	mov	r0, r3
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
 80a1a66:	4607      	mov	r7, r0
 80a1a68:	f810 5b01 	ldrb.w	r5, [r0], #1
 80a1a6c:	2d20      	cmp	r5, #32
 80a1a6e:	d0fa      	beq.n	80a1a66 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4e>
 80a1a70:	2d2f      	cmp	r5, #47	; 0x2f
 80a1a72:	d0f8      	beq.n	80a1a66 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4e>
  *ptr = &path[end];
 80a1a74:	6017      	str	r7, [r2, #0]
  while (len) {
 80a1a76:	b14c      	cbz	r4, 80a1a8c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x74>
    c = path[len - 1];
 80a1a78:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    if (c != '.' && c != ' ') {
 80a1a7c:	2a2e      	cmp	r2, #46	; 0x2e
 80a1a7e:	d001      	beq.n	80a1a84 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x6c>
 80a1a80:	2a20      	cmp	r2, #32
 80a1a82:	d101      	bne.n	80a1a88 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x70>
    len--;
 80a1a84:	3c01      	subs	r4, #1
  while (len) {
 80a1a86:	e7f6      	b.n	80a1a76 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x5e>
  if (len > 255) {
 80a1a88:	2cff      	cmp	r4, #255	; 0xff
 80a1a8a:	dcd5      	bgt.n	80a1a38 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
    fname->sfn[k] = ' ';
 80a1a8c:	2020      	movs	r0, #32
  fname->len = len;
 80a1a8e:	604c      	str	r4, [r1, #4]
  for (uint8_t k = 0; k < 11; k++) {
 80a1a90:	f101 030d 	add.w	r3, r1, #13
 80a1a94:	f101 0218 	add.w	r2, r1, #24
    fname->sfn[k] = ' ';
 80a1a98:	f803 0b01 	strb.w	r0, [r3], #1
  for (uint8_t k = 0; k < 11; k++) {
 80a1a9c:	4293      	cmp	r3, r2
 80a1a9e:	d1fb      	bne.n	80a1a98 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x80>
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
 80a1aa0:	f04f 0800 	mov.w	r8, #0
 80a1aa4:	f816 3008 	ldrb.w	r3, [r6, r8]
 80a1aa8:	2b2e      	cmp	r3, #46	; 0x2e
 80a1aaa:	d001      	beq.n	80a1ab0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x98>
 80a1aac:	2b20      	cmp	r3, #32
 80a1aae:	d102      	bne.n	80a1ab6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x9e>
 80a1ab0:	f108 0801 	add.w	r8, r8, #1
 80a1ab4:	e7f6      	b.n	80a1aa4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x8c>
  is83 = !si;
 80a1ab6:	fab8 f088 	clz	r0, r8
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
 80a1aba:	1e65      	subs	r5, r4, #1
  is83 = !si;
 80a1abc:	0940      	lsrs	r0, r0, #5
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
 80a1abe:	1c6b      	adds	r3, r5, #1
 80a1ac0:	d002      	beq.n	80a1ac8 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xb0>
 80a1ac2:	5d73      	ldrb	r3, [r6, r5]
 80a1ac4:	2b2e      	cmp	r3, #46	; 0x2e
 80a1ac6:	d114      	bne.n	80a1af2 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xda>
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
 80a1ac8:	f04f 0900 	mov.w	r9, #0
 80a1acc:	2707      	movs	r7, #7
 80a1ace:	464a      	mov	r2, r9
 80a1ad0:	46ca      	mov	sl, r9
 80a1ad2:	f04f 0e08 	mov.w	lr, #8
  for (; si < len; si++) {
 80a1ad6:	45a0      	cmp	r8, r4
 80a1ad8:	da69      	bge.n	80a1bae <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x196>
    c = path[si];
 80a1ada:	f816 3008 	ldrb.w	r3, [r6, r8]
    if (c == ' ' || (c == '.' && dot != si)) {
 80a1ade:	2b20      	cmp	r3, #32
 80a1ae0:	d003      	beq.n	80a1aea <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd2>
 80a1ae2:	2b2e      	cmp	r3, #46	; 0x2e
 80a1ae4:	d107      	bne.n	80a1af6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xde>
 80a1ae6:	45a8      	cmp	r8, r5
 80a1ae8:	d012      	beq.n	80a1b10 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf8>
      is83 = false;
 80a1aea:	2000      	movs	r0, #0
  for (; si < len; si++) {
 80a1aec:	f108 0801 	add.w	r8, r8, #1
 80a1af0:	e7f1      	b.n	80a1ad6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xbe>
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
 80a1af2:	3d01      	subs	r5, #1
 80a1af4:	e7e3      	b.n	80a1abe <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xa6>
    if (c == '"' || c == '|') {
 80a1af6:	2b22      	cmp	r3, #34	; 0x22
 80a1af8:	d008      	beq.n	80a1b0c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf4>
 80a1afa:	2b7c      	cmp	r3, #124	; 0x7c
 80a1afc:	d006      	beq.n	80a1b0c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf4>
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
 80a1afe:	f1a3 0c2a 	sub.w	ip, r3, #42	; 0x2a
 80a1b02:	f1bc 0f05 	cmp.w	ip, #5
 80a1b06:	d80b      	bhi.n	80a1b20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x108>
 80a1b08:	2b2d      	cmp	r3, #45	; 0x2d
 80a1b0a:	d013      	beq.n	80a1b34 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x11c>
    if (!legal83Char(c) && si != dot) {
 80a1b0c:	45a8      	cmp	r8, r5
 80a1b0e:	d15c      	bne.n	80a1bca <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1b2>
      if (in == 10) {
 80a1b10:	2f0a      	cmp	r7, #10
 80a1b12:	d04b      	beq.n	80a1bac <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x194>
 80a1b14:	46a8      	mov	r8, r5
      in = 10;  // Max index for full 8.3 name.
 80a1b16:	270a      	movs	r7, #10
      i = 8;    // Place for extension.
 80a1b18:	2208      	movs	r2, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
 80a1b1a:	f04f 0e10 	mov.w	lr, #16
 80a1b1e:	e7e5      	b.n	80a1aec <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd4>
    if (0X3A <= c && c <= 0X3F) {
 80a1b20:	f1a3 0c3a 	sub.w	ip, r3, #58	; 0x3a
 80a1b24:	f1bc 0f05 	cmp.w	ip, #5
 80a1b28:	d9f0      	bls.n	80a1b0c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf4>
    if (0X5B <= c && c <= 0X5D) {
 80a1b2a:	f1a3 0c5b 	sub.w	ip, r3, #91	; 0x5b
 80a1b2e:	f1bc 0f02 	cmp.w	ip, #2
 80a1b32:	d9eb      	bls.n	80a1b0c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf4>
    if (!legal83Char(c) && si != dot) {
 80a1b34:	f1a3 0c21 	sub.w	ip, r3, #33	; 0x21
 80a1b38:	f1bc 0f5d 	cmp.w	ip, #93	; 0x5d
 80a1b3c:	d8e6      	bhi.n	80a1b0c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf4>
    if (si == dot || i > in) {
 80a1b3e:	45a8      	cmp	r8, r5
 80a1b40:	d0e6      	beq.n	80a1b10 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf8>
 80a1b42:	42ba      	cmp	r2, r7
 80a1b44:	d830      	bhi.n	80a1ba8 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x190>
      if ('a' <= c && c <= 'z') {
 80a1b46:	f1a3 0c61 	sub.w	ip, r3, #97	; 0x61
 80a1b4a:	f1bc 0f19 	cmp.w	ip, #25
 80a1b4e:	d81a      	bhi.n	80a1b86 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x16e>
        c += 'A' - 'a';
 80a1b50:	3b20      	subs	r3, #32
        lc |= bit;
 80a1b52:	ea4e 0909 	orr.w	r9, lr, r9
        c += 'A' - 'a';
 80a1b56:	b2db      	uxtb	r3, r3
        lc |= bit;
 80a1b58:	fa5f f989 	uxtb.w	r9, r9
      fname->sfn[i++] = c;
 80a1b5c:	f102 0c01 	add.w	ip, r2, #1
 80a1b60:	fa5f fc8c 	uxtb.w	ip, ip
 80a1b64:	440a      	add	r2, r1
      if (i < 7) {
 80a1b66:	f1bc 0f06 	cmp.w	ip, #6
      fname->sfn[i++] = c;
 80a1b6a:	7353      	strb	r3, [r2, #13]
      if (i < 7) {
 80a1b6c:	d801      	bhi.n	80a1b72 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x15a>
        fname->seqPos = i;
 80a1b6e:	f881 c00c 	strb.w	ip, [r1, #12]
 80a1b72:	4662      	mov	r2, ip
 80a1b74:	e7ba      	b.n	80a1aec <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd4>
      if (si > dot) {
 80a1b76:	45a8      	cmp	r8, r5
 80a1b78:	dc18      	bgt.n	80a1bac <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x194>
 80a1b7a:	46a8      	mov	r8, r5
      in = 10;  // Max index for full 8.3 name.
 80a1b7c:	270a      	movs	r7, #10
      i = 8;    // Place for extension.
 80a1b7e:	2208      	movs	r2, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
 80a1b80:	f04f 0e10 	mov.w	lr, #16
 80a1b84:	e7b1      	b.n	80a1aea <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd2>
      } else if ('A' <= c && c <= 'Z') {
 80a1b86:	f1a3 0c41 	sub.w	ip, r3, #65	; 0x41
 80a1b8a:	f1bc 0f19 	cmp.w	ip, #25
        uc |= bit;
 80a1b8e:	bf98      	it	ls
 80a1b90:	ea4e 0a0a 	orrls.w	sl, lr, sl
 80a1b94:	e7e2      	b.n	80a1b5c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x144>
    fname->flags = FNAME_FLAG_LOST_CHARS;
 80a1b96:	2001      	movs	r0, #1
    fname->sfn[fname->seqPos] = '~';
 80a1b98:	7b0b      	ldrb	r3, [r1, #12]
    fname->flags = FNAME_FLAG_LOST_CHARS;
 80a1b9a:	7008      	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
 80a1b9c:	4419      	add	r1, r3
 80a1b9e:	237e      	movs	r3, #126	; 0x7e
 80a1ba0:	734b      	strb	r3, [r1, #13]
    fname->sfn[fname->seqPos + 1] = '1';
 80a1ba2:	2331      	movs	r3, #49	; 0x31
 80a1ba4:	738b      	strb	r3, [r1, #14]
 80a1ba6:	e748      	b.n	80a1a3a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x22>
      if (in == 10) {
 80a1ba8:	2f0a      	cmp	r7, #10
 80a1baa:	d1e4      	bne.n	80a1b76 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x15e>
        is83 = false;
 80a1bac:	2000      	movs	r0, #0
  if (fname->sfn[0] == ' ') {
 80a1bae:	7b4b      	ldrb	r3, [r1, #13]
 80a1bb0:	2b20      	cmp	r3, #32
 80a1bb2:	f43f af41 	beq.w	80a1a38 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
  if (is83) {
 80a1bb6:	2800      	cmp	r0, #0
 80a1bb8:	d0ed      	beq.n	80a1b96 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x17e>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
 80a1bba:	ea1a 0f09 	tst.w	sl, r9
 80a1bbe:	bf18      	it	ne
 80a1bc0:	f04f 0902 	movne.w	r9, #2
 80a1bc4:	f881 9000 	strb.w	r9, [r1]
 80a1bc8:	e737      	b.n	80a1a3a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x22>
    if (si == dot || i > in) {
 80a1bca:	42ba      	cmp	r2, r7
 80a1bcc:	d8ec      	bhi.n	80a1ba8 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x190>
      c = '_';
 80a1bce:	235f      	movs	r3, #95	; 0x5f
      is83 = false;
 80a1bd0:	2000      	movs	r0, #0
 80a1bd2:	e7c3      	b.n	80a1b5c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x144>
 80a1bd4:	31000101 	.word	0x31000101

080a1bd8 <_ZN7FatFile9printNameEP5Print>:

fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::printName(print_t* pr) {
 80a1bd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
 80a1bdc:	2400      	movs	r4, #0
  FatFile dirFile;
  uint16_t u;
  size_t n = 0;
  ldir_t* ldir;

  if (!isLFN()) {
 80a1bde:	78c3      	ldrb	r3, [r0, #3]
size_t FatFile::printName(print_t* pr) {
 80a1be0:	b08b      	sub	sp, #44	; 0x2c
 80a1be2:	4607      	mov	r7, r0
 80a1be4:	4689      	mov	r9, r1
 80a1be6:	f8ad 4004 	strh.w	r4, [sp, #4]
  if (!isLFN()) {
 80a1bea:	b933      	cbnz	r3, 80a1bfa <_ZN7FatFile9printNameEP5Print+0x22>
    return printSFN(pr);
 80a1bec:	f000 fb9b 	bl	80a2326 <_ZN7FatFile8printSFNEP5Print>
 80a1bf0:	4604      	mov	r4, r0
  // Fall into fail;
  DBG_FAIL_MACRO;

fail:
  return 0;
}
 80a1bf2:	4620      	mov	r0, r4
 80a1bf4:	b00b      	add	sp, #44	; 0x2c
 80a1bf6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (!dirFile.openCluster(this)) {
 80a1bfa:	4601      	mov	r1, r0
 80a1bfc:	a801      	add	r0, sp, #4
 80a1bfe:	f7ff fef4 	bl	80a19ea <_ZN7FatFile11openClusterEPS_>
 80a1c02:	2800      	cmp	r0, #0
 80a1c04:	d047      	beq.n	80a1c96 <_ZN7FatFile9printNameEP5Print+0xbe>
 80a1c06:	f04f 0801 	mov.w	r8, #1
  for (uint8_t ord = 1; ord <= m_lfnOrd; ord++) {
 80a1c0a:	78fb      	ldrb	r3, [r7, #3]
 80a1c0c:	fa5f f688 	uxtb.w	r6, r8
 80a1c10:	42b3      	cmp	r3, r6
 80a1c12:	d340      	bcc.n	80a1c96 <_ZN7FatFile9printNameEP5Print+0xbe>
    if (!dirFile.seekSet(32UL*(m_dirIndex - ord))) {
 80a1c14:	88b9      	ldrh	r1, [r7, #4]
 80a1c16:	a801      	add	r0, sp, #4
 80a1c18:	eba1 0108 	sub.w	r1, r1, r8
 80a1c1c:	0149      	lsls	r1, r1, #5
 80a1c1e:	f7ff fc7a 	bl	80a1516 <_ZN7FatFile7seekSetEm>
 80a1c22:	2800      	cmp	r0, #0
 80a1c24:	d037      	beq.n	80a1c96 <_ZN7FatFile9printNameEP5Print+0xbe>
    ldir = reinterpret_cast<ldir_t*>(dirFile.readDirCache());
 80a1c26:	2100      	movs	r1, #0
 80a1c28:	a801      	add	r0, sp, #4
 80a1c2a:	f7ff fc55 	bl	80a14d8 <_ZN7FatFile12readDirCacheEb>
    if (!ldir) {
 80a1c2e:	4605      	mov	r5, r0
 80a1c30:	b388      	cbz	r0, 80a1c96 <_ZN7FatFile9printNameEP5Print+0xbe>
    if (ldir->attr != DIR_ATT_LONG_NAME ||
 80a1c32:	7ac3      	ldrb	r3, [r0, #11]
 80a1c34:	2b0f      	cmp	r3, #15
 80a1c36:	d12e      	bne.n	80a1c96 <_ZN7FatFile9printNameEP5Print+0xbe>
 80a1c38:	7803      	ldrb	r3, [r0, #0]
 80a1c3a:	f003 031f 	and.w	r3, r3, #31
 80a1c3e:	42b3      	cmp	r3, r6
 80a1c40:	d129      	bne.n	80a1c96 <_ZN7FatFile9printNameEP5Print+0xbe>
 80a1c42:	2600      	movs	r6, #0
  if (i < LDIR_NAME1_DIM) {
 80a1c44:	2e04      	cmp	r6, #4
 80a1c46:	b2f3      	uxtb	r3, r6
 80a1c48:	d818      	bhi.n	80a1c7c <_ZN7FatFile9printNameEP5Print+0xa4>
    return ldir->name1[i];
 80a1c4a:	eb05 0346 	add.w	r3, r5, r6, lsl #1
 80a1c4e:	f8b3 1001 	ldrh.w	r1, [r3, #1]
      if (u == 0) {
 80a1c52:	b169      	cbz	r1, 80a1c70 <_ZN7FatFile9printNameEP5Print+0x98>
        u = '?';
 80a1c54:	297f      	cmp	r1, #127	; 0x7f
 80a1c56:	bf28      	it	cs
 80a1c58:	213f      	movcs	r1, #63	; 0x3f
      pr->write(static_cast<char>(u));
 80a1c5a:	f8d9 2000 	ldr.w	r2, [r9]
 80a1c5e:	4648      	mov	r0, r9
 80a1c60:	6892      	ldr	r2, [r2, #8]
 80a1c62:	b2c9      	uxtb	r1, r1
 80a1c64:	3601      	adds	r6, #1
 80a1c66:	4790      	blx	r2
    for (uint8_t i = 0; i < 13; i++) {
 80a1c68:	2e0d      	cmp	r6, #13
      n++;
 80a1c6a:	f104 0401 	add.w	r4, r4, #1
    for (uint8_t i = 0; i < 13; i++) {
 80a1c6e:	d1e9      	bne.n	80a1c44 <_ZN7FatFile9printNameEP5Print+0x6c>
    if (ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) {
 80a1c70:	782b      	ldrb	r3, [r5, #0]
 80a1c72:	f108 0801 	add.w	r8, r8, #1
 80a1c76:	065b      	lsls	r3, r3, #25
 80a1c78:	d5c7      	bpl.n	80a1c0a <_ZN7FatFile9printNameEP5Print+0x32>
 80a1c7a:	e7ba      	b.n	80a1bf2 <_ZN7FatFile9printNameEP5Print+0x1a>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
 80a1c7c:	2b0a      	cmp	r3, #10
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a1c7e:	bf95      	itete	ls
 80a1c80:	f106 33ff 	addls.w	r3, r6, #4294967295	; 0xffffffff
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a1c84:	1c73      	addhi	r3, r6, #1
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a1c86:	eb05 0343 	addls.w	r3, r5, r3, lsl #1
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a1c8a:	eb05 0343 	addhi.w	r3, r5, r3, lsl #1
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a1c8e:	bf94      	ite	ls
 80a1c90:	88d9      	ldrhls	r1, [r3, #6]
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a1c92:	8899      	ldrhhi	r1, [r3, #4]
 80a1c94:	e7dd      	b.n	80a1c52 <_ZN7FatFile9printNameEP5Print+0x7a>
  return 0;
 80a1c96:	2400      	movs	r4, #0
 80a1c98:	e7ab      	b.n	80a1bf2 <_ZN7FatFile9printNameEP5Print+0x1a>

080a1c9a <_ZN7FatFile12lfnUniqueSfnEP7fname_t>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
 80a1c9a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a1c9e:	4606      	mov	r6, r0
 80a1ca0:	460c      	mov	r4, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
 80a1ca2:	2502      	movs	r5, #2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
 80a1ca4:	277e      	movs	r7, #126	; 0x7e
  uint8_t pos = fname->seqPos;;
 80a1ca6:	f891 900c 	ldrb.w	r9, [r1, #12]
        goto fail;
      }
      if (dir->name[0] == DIR_NAME_FREE) {
        goto done;
      }
      if (DIR_IS_FILE_OR_SUBDIR(dir) && !memcmp(fname->sfn, dir->name, 11)) {
 80a1caa:	f101 080d 	add.w	r8, r1, #13
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
 80a1cae:	6861      	ldr	r1, [r4, #4]
 80a1cb0:	68a2      	ldr	r2, [r4, #8]
 80a1cb2:	186b      	adds	r3, r5, r1
 80a1cb4:	b29b      	uxth	r3, r3
  for (size_t i = 0; i < len; i++) {
 80a1cb6:	4411      	add	r1, r2
 80a1cb8:	4291      	cmp	r1, r2
 80a1cba:	d006      	beq.n	80a1cca <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x30>
    hash = ((hash << 5) + hash) ^ str[i];
 80a1cbc:	f812 0b01 	ldrb.w	r0, [r2], #1
 80a1cc0:	eb03 1343 	add.w	r3, r3, r3, lsl #5
 80a1cc4:	4043      	eors	r3, r0
 80a1cc6:	b29b      	uxth	r3, r3
  for (size_t i = 0; i < len; i++) {
 80a1cc8:	e7f6      	b.n	80a1cb8 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x1e>
      if (pos > 3) {
 80a1cca:	f1b9 0f03 	cmp.w	r9, #3
 80a1cce:	bf28      	it	cs
 80a1cd0:	f04f 0903 	movcs.w	r9, #3
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1cd4:	f109 0204 	add.w	r2, r9, #4
 80a1cd8:	b2d2      	uxtb	r2, r2
        uint8_t h = hex & 0XF;
 80a1cda:	f003 010f 	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1cde:	18a0      	adds	r0, r4, r2
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1ce0:	3a01      	subs	r2, #1
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1ce2:	2909      	cmp	r1, #9
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1ce4:	b2d2      	uxtb	r2, r2
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1ce6:	bf94      	ite	ls
 80a1ce8:	3130      	addls	r1, #48	; 0x30
 80a1cea:	3137      	addhi	r1, #55	; 0x37
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1cec:	4591      	cmp	r9, r2
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1cee:	7341      	strb	r1, [r0, #13]
        hex >>= 4;
 80a1cf0:	ea4f 1313 	mov.w	r3, r3, lsr #4
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1cf4:	d1f1      	bne.n	80a1cda <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x40>
    fname->sfn[pos] = '~';
 80a1cf6:	eb04 0309 	add.w	r3, r4, r9
    seekSet(0);
 80a1cfa:	2100      	movs	r1, #0
 80a1cfc:	4630      	mov	r0, r6
 80a1cfe:	735f      	strb	r7, [r3, #13]
 80a1d00:	f7ff fc09 	bl	80a1516 <_ZN7FatFile7seekSetEm>
      dir = readDirCache(true);
 80a1d04:	2101      	movs	r1, #1
 80a1d06:	4630      	mov	r0, r6
 80a1d08:	f7ff fbe6 	bl	80a14d8 <_ZN7FatFile12readDirCacheEb>
      if (!dir) {
 80a1d0c:	4601      	mov	r1, r0
 80a1d0e:	b928      	cbnz	r0, 80a1d1c <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x82>
        if (!getError()) {
 80a1d10:	7870      	ldrb	r0, [r6, #1]
 80a1d12:	fab0 f080 	clz	r0, r0
 80a1d16:	0940      	lsrs	r0, r0, #5
fail:
  return false;

done:
  return true;
}
 80a1d18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if (dir->name[0] == DIR_NAME_FREE) {
 80a1d1c:	7803      	ldrb	r3, [r0, #0]
 80a1d1e:	b16b      	cbz	r3, 80a1d3c <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0xa2>
      if (DIR_IS_FILE_OR_SUBDIR(dir) && !memcmp(fname->sfn, dir->name, 11)) {
 80a1d20:	7ac3      	ldrb	r3, [r0, #11]
 80a1d22:	071b      	lsls	r3, r3, #28
 80a1d24:	d4ee      	bmi.n	80a1d04 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x6a>
 80a1d26:	220b      	movs	r2, #11
 80a1d28:	4640      	mov	r0, r8
 80a1d2a:	f005 fd8f 	bl	80a784c <memcmp>
 80a1d2e:	2800      	cmp	r0, #0
 80a1d30:	d1e8      	bne.n	80a1d04 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x6a>
  for (uint8_t seq = 2; seq < 100; seq++) {
 80a1d32:	3501      	adds	r5, #1
 80a1d34:	b2ad      	uxth	r5, r5
 80a1d36:	2d64      	cmp	r5, #100	; 0x64
 80a1d38:	d1b9      	bne.n	80a1cae <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x14>
 80a1d3a:	e7ed      	b.n	80a1d18 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x7e>
  return true;
 80a1d3c:	2001      	movs	r0, #1
 80a1d3e:	e7eb      	b.n	80a1d18 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x7e>

080a1d40 <_ZN7FatFile4openEPS_P7fname_ti>:
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
 80a1d40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1d44:	b089      	sub	sp, #36	; 0x24
 80a1d46:	9304      	str	r3, [sp, #16]
  if (!dirFile->isDir() || isOpen()) {
 80a1d48:	780b      	ldrb	r3, [r1, #0]
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
 80a1d4a:	460d      	mov	r5, r1
  if (!dirFile->isDir() || isOpen()) {
 80a1d4c:	f013 0f70 	tst.w	r3, #112	; 0x70
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
 80a1d50:	4690      	mov	r8, r2
 80a1d52:	9005      	str	r0, [sp, #20]
  if (!dirFile->isDir() || isOpen()) {
 80a1d54:	d103      	bne.n	80a1d5e <_ZN7FatFile4openEPS_P7fname_ti+0x1e>
  return false;
 80a1d56:	2000      	movs	r0, #0
}
 80a1d58:	b009      	add	sp, #36	; 0x24
 80a1d5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!dirFile->isDir() || isOpen()) {
 80a1d5e:	9b05      	ldr	r3, [sp, #20]
 80a1d60:	781b      	ldrb	r3, [r3, #0]
 80a1d62:	2b00      	cmp	r3, #0
 80a1d64:	d1f7      	bne.n	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  size_t len = fname->len;
 80a1d66:	6853      	ldr	r3, [r2, #4]
 80a1d68:	4628      	mov	r0, r5
 80a1d6a:	9303      	str	r3, [sp, #12]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
 80a1d6c:	7813      	ldrb	r3, [r2, #0]
 80a1d6e:	0799      	lsls	r1, r3, #30
 80a1d70:	bf18      	it	ne
 80a1d72:	9b03      	ldrne	r3, [sp, #12]
 80a1d74:	f04f 0100 	mov.w	r1, #0
 80a1d78:	bf1f      	itttt	ne
 80a1d7a:	f103 070c 	addne.w	r7, r3, #12
 80a1d7e:	230d      	movne	r3, #13
 80a1d80:	fbb7 f7f3 	udivne	r7, r7, r3
 80a1d84:	3701      	addne	r7, #1
 80a1d86:	bf0c      	ite	eq
 80a1d88:	2701      	moveq	r7, #1
 80a1d8a:	b2ff      	uxtbne	r7, r7
 80a1d8c:	f7ff fbc3 	bl	80a1516 <_ZN7FatFile7seekSetEm>
  }
 80a1d90:	2300      	movs	r3, #0
 80a1d92:	469b      	mov	fp, r3
 80a1d94:	461c      	mov	r4, r3
 80a1d96:	461e      	mov	r6, r3
 80a1d98:	469a      	mov	sl, r3
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
 80a1d9a:	f108 020d 	add.w	r2, r8, #13
 80a1d9e:	9302      	str	r3, [sp, #8]
 80a1da0:	9207      	str	r2, [sp, #28]
    curIndex = dirFile->m_curPosition/32;
 80a1da2:	696a      	ldr	r2, [r5, #20]
    dir = dirFile->readDirCache(true);
 80a1da4:	2101      	movs	r1, #1
 80a1da6:	4628      	mov	r0, r5
 80a1da8:	9306      	str	r3, [sp, #24]
    curIndex = dirFile->m_curPosition/32;
 80a1daa:	f3c2 194f 	ubfx	r9, r2, #5, #16
    dir = dirFile->readDirCache(true);
 80a1dae:	f7ff fb93 	bl	80a14d8 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
 80a1db2:	9b06      	ldr	r3, [sp, #24]
 80a1db4:	2800      	cmp	r0, #0
 80a1db6:	d16f      	bne.n	80a1e98 <_ZN7FatFile4openEPS_P7fname_ti+0x158>
      if (dirFile->getError()) {
 80a1db8:	786b      	ldrb	r3, [r5, #1]
 80a1dba:	2b00      	cmp	r3, #0
 80a1dbc:	d1cb      	bne.n	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
 80a1dbe:	9b04      	ldr	r3, [sp, #16]
 80a1dc0:	059a      	lsls	r2, r3, #22
 80a1dc2:	d5c8      	bpl.n	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>

#define O_READ    O_RDONLY
#define O_WRITE   O_WRONLY

inline bool isWriteMode(oflag_t oflag) {
  oflag &= O_ACCMODE;
 80a1dc4:	f003 0303 	and.w	r3, r3, #3
  return oflag == O_WRONLY || oflag == O_RDWR;
 80a1dc8:	3b01      	subs	r3, #1
 80a1dca:	2b01      	cmp	r3, #1
 80a1dcc:	d8c3      	bhi.n	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  if (freeFound == 0) {
 80a1dce:	9b02      	ldr	r3, [sp, #8]
 80a1dd0:	2c00      	cmp	r4, #0
 80a1dd2:	bf08      	it	eq
 80a1dd4:	464b      	moveq	r3, r9
 80a1dd6:	9302      	str	r3, [sp, #8]
  while (freeFound < freeNeed) {
 80a1dd8:	42bc      	cmp	r4, r7
 80a1dda:	f0c0 8103 	bcc.w	80a1fe4 <_ZN7FatFile4openEPS_P7fname_ti+0x2a4>
  if (fnameFound) {
 80a1dde:	f1ba 0f00 	cmp.w	sl, #0
 80a1de2:	f040 811b 	bne.w	80a201c <_ZN7FatFile4openEPS_P7fname_ti+0x2dc>
  if (!dirFile->seekSet(32UL*freeIndex)) {
 80a1de6:	9b02      	ldr	r3, [sp, #8]
 80a1de8:	4628      	mov	r0, r5
 80a1dea:	0159      	lsls	r1, r3, #5
 80a1dec:	f7ff fb93 	bl	80a1516 <_ZN7FatFile7seekSetEm>
 80a1df0:	2800      	cmp	r0, #0
 80a1df2:	d0b0      	beq.n	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  lfnOrd = freeNeed - 1;
 80a1df4:	3f01      	subs	r7, #1
 80a1df6:	fa5f fa87 	uxtb.w	sl, r7
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
 80a1dfa:	4656      	mov	r6, sl
    ldir = reinterpret_cast<ldir_t*>(dirFile->readDirCache());
 80a1dfc:	f04f 0900 	mov.w	r9, #0
    ldir->attr = DIR_ATT_LONG_NAME;
 80a1e00:	270f      	movs	r7, #15
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
 80a1e02:	2e00      	cmp	r6, #0
 80a1e04:	f000 8121 	beq.w	80a204a <_ZN7FatFile4openEPS_P7fname_ti+0x30a>
    ldir = reinterpret_cast<ldir_t*>(dirFile->readDirCache());
 80a1e08:	2100      	movs	r1, #0
 80a1e0a:	4628      	mov	r0, r5
 80a1e0c:	f7ff fb64 	bl	80a14d8 <_ZN7FatFile12readDirCacheEb>
    if (!ldir) {
 80a1e10:	4604      	mov	r4, r0
 80a1e12:	2800      	cmp	r0, #0
 80a1e14:	d09f      	beq.n	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
 80a1e16:	4556      	cmp	r6, sl
 80a1e18:	bf18      	it	ne
 80a1e1a:	46b3      	movne	fp, r6
    dirFile->m_vol->cacheDirty();
 80a1e1c:	68aa      	ldr	r2, [r5, #8]
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
 80a1e1e:	bf08      	it	eq
 80a1e20:	f046 0b40 	orreq.w	fp, r6, #64	; 0x40
    m_status |= CACHE_STATUS_DIRTY;
 80a1e24:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 80a1e28:	f043 0301 	orr.w	r3, r3, #1
 80a1e2c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
 80a1e30:	f880 b000 	strb.w	fp, [r0]
    ldir->attr = DIR_ATT_LONG_NAME;
 80a1e34:	72c7      	strb	r7, [r0, #11]
    ldir->type = 0;
 80a1e36:	f880 900c 	strb.w	r9, [r0, #12]
    ldir->chksum = lfnChecksum(fname->sfn);
 80a1e3a:	f108 000d 	add.w	r0, r8, #13
 80a1e3e:	f7ff fdc5 	bl	80a19cc <_ZN7FatFile11lfnChecksumEPh>
  size_t k = 13*((ldir->ord & 0X1F) - 1);
 80a1e42:	220d      	movs	r2, #13
 80a1e44:	2300      	movs	r3, #0
 80a1e46:	f00b 0b1f 	and.w	fp, fp, #31
 80a1e4a:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 80a1e4e:	fb02 f20b 	mul.w	r2, r2, fp
    ldir->chksum = lfnChecksum(fname->sfn);
 80a1e52:	7360      	strb	r0, [r4, #13]
    ldir->mustBeZero = 0;
 80a1e54:	f884 901a 	strb.w	r9, [r4, #26]
 80a1e58:	f884 901b 	strb.w	r9, [r4, #27]
    lfnPutName(ldir, fname->lfn, len);
 80a1e5c:	f8d8 c008 	ldr.w	ip, [r8, #8]
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
 80a1e60:	9903      	ldr	r1, [sp, #12]
 80a1e62:	4291      	cmp	r1, r2
 80a1e64:	f240 80e2 	bls.w	80a202c <_ZN7FatFile4openEPS_P7fname_ti+0x2ec>
 80a1e68:	f81c 1002 	ldrb.w	r1, [ip, r2]
  if (i < LDIR_NAME1_DIM) {
 80a1e6c:	2b04      	cmp	r3, #4
 80a1e6e:	fa5f fe83 	uxtb.w	lr, r3
 80a1e72:	f103 0001 	add.w	r0, r3, #1
 80a1e76:	f200 80df 	bhi.w	80a2038 <_ZN7FatFile4openEPS_P7fname_ti+0x2f8>
    ldir->name1[i] = c;
 80a1e7a:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 80a1e7e:	f8a3 1001 	strh.w	r1, [r3, #1]
  for (uint8_t i = 0; i < 13; i++, k++) {
 80a1e82:	280d      	cmp	r0, #13
 80a1e84:	4603      	mov	r3, r0
 80a1e86:	f102 0201 	add.w	r2, r2, #1
 80a1e8a:	d1e9      	bne.n	80a1e60 <_ZN7FatFile4openEPS_P7fname_ti+0x120>
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
 80a1e8c:	3e01      	subs	r6, #1
 80a1e8e:	b2f6      	uxtb	r6, r6
 80a1e90:	e7b7      	b.n	80a1e02 <_ZN7FatFile4openEPS_P7fname_ti+0xc2>
        fnameFound = true;
 80a1e92:	f04f 0a01 	mov.w	sl, #1
 80a1e96:	e784      	b.n	80a1da2 <_ZN7FatFile4openEPS_P7fname_ti+0x62>
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == DIR_NAME_FREE) {
 80a1e98:	7802      	ldrb	r2, [r0, #0]
 80a1e9a:	2ae5      	cmp	r2, #229	; 0xe5
 80a1e9c:	d000      	beq.n	80a1ea0 <_ZN7FatFile4openEPS_P7fname_ti+0x160>
 80a1e9e:	b97a      	cbnz	r2, 80a1ec0 <_ZN7FatFile4openEPS_P7fname_ti+0x180>
    curIndex = dirFile->m_curPosition/32;
 80a1ea0:	9902      	ldr	r1, [sp, #8]
 80a1ea2:	2c00      	cmp	r4, #0
 80a1ea4:	bf08      	it	eq
 80a1ea6:	4649      	moveq	r1, r9
      if (freeFound < freeNeed) {
 80a1ea8:	42bc      	cmp	r4, r7
        freeFound++;
 80a1eaa:	bf38      	it	cc
 80a1eac:	3401      	addcc	r4, #1
    curIndex = dirFile->m_curPosition/32;
 80a1eae:	9102      	str	r1, [sp, #8]
        freeFound++;
 80a1eb0:	bf38      	it	cc
 80a1eb2:	b2e4      	uxtbcc	r4, r4
      if (dir->name[0] == DIR_NAME_FREE) {
 80a1eb4:	2a00      	cmp	r2, #0
 80a1eb6:	d082      	beq.n	80a1dbe <_ZN7FatFile4openEPS_P7fname_ti+0x7e>
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
 80a1eb8:	2ae5      	cmp	r2, #229	; 0xe5
 80a1eba:	d104      	bne.n	80a1ec6 <_ZN7FatFile4openEPS_P7fname_ti+0x186>
      lfnOrd = 0;
 80a1ebc:	2600      	movs	r6, #0
 80a1ebe:	e770      	b.n	80a1da2 <_ZN7FatFile4openEPS_P7fname_ti+0x62>
        freeFound = 0;
 80a1ec0:	42bc      	cmp	r4, r7
 80a1ec2:	bf38      	it	cc
 80a1ec4:	2400      	movcc	r4, #0
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
 80a1ec6:	2a2e      	cmp	r2, #46	; 0x2e
 80a1ec8:	d0f8      	beq.n	80a1ebc <_ZN7FatFile4openEPS_P7fname_ti+0x17c>
    } else if (DIR_IS_LONG_NAME(dir)) {
 80a1eca:	7ac1      	ldrb	r1, [r0, #11]
 80a1ecc:	290f      	cmp	r1, #15
 80a1ece:	d15d      	bne.n	80a1f8c <_ZN7FatFile4openEPS_P7fname_ti+0x24c>
      if (!lfnOrd) {
 80a1ed0:	bb3e      	cbnz	r6, 80a1f22 <_ZN7FatFile4openEPS_P7fname_ti+0x1e2>
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
 80a1ed2:	f012 0640 	ands.w	r6, r2, #64	; 0x40
 80a1ed6:	f43f af64 	beq.w	80a1da2 <_ZN7FatFile4openEPS_P7fname_ti+0x62>
        lfnOrd = ord = ldir->ord & 0X1F;
 80a1eda:	f002 061f 	and.w	r6, r2, #31
 80a1ede:	46b3      	mov	fp, r6
        chksum = ldir->chksum;
 80a1ee0:	7b43      	ldrb	r3, [r0, #13]
      size_t k = 13*(ord - 1);
 80a1ee2:	f04f 0e0d 	mov.w	lr, #13
 80a1ee6:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
 80a1eea:	fb0e fe02 	mul.w	lr, lr, r2
      if (k >= len) {
 80a1eee:	9a03      	ldr	r2, [sp, #12]
 80a1ef0:	4572      	cmp	r2, lr
 80a1ef2:	d9e3      	bls.n	80a1ebc <_ZN7FatFile4openEPS_P7fname_ti+0x17c>
 80a1ef4:	f04f 0c00 	mov.w	ip, #0
 80a1ef8:	eba2 020e 	sub.w	r2, r2, lr
 80a1efc:	9206      	str	r2, [sp, #24]
  if (i < LDIR_NAME1_DIM) {
 80a1efe:	f1bc 0f04 	cmp.w	ip, #4
 80a1f02:	eb0c 090e 	add.w	r9, ip, lr
 80a1f06:	fa5f f28c 	uxtb.w	r2, ip
 80a1f0a:	d814      	bhi.n	80a1f36 <_ZN7FatFile4openEPS_P7fname_ti+0x1f6>
    return ldir->name1[i];
 80a1f0c:	eb00 024c 	add.w	r2, r0, ip, lsl #1
 80a1f10:	f8b2 2001 	ldrh.w	r2, [r2, #1]
        if (k == len) {
 80a1f14:	9906      	ldr	r1, [sp, #24]
 80a1f16:	458c      	cmp	ip, r1
 80a1f18:	d11b      	bne.n	80a1f52 <_ZN7FatFile4openEPS_P7fname_ti+0x212>
            lfnOrd = 0;
 80a1f1a:	2a00      	cmp	r2, #0
 80a1f1c:	bf18      	it	ne
 80a1f1e:	2600      	movne	r6, #0
 80a1f20:	e73f      	b.n	80a1da2 <_ZN7FatFile4openEPS_P7fname_ti+0x62>
      } else if (ldir->ord != --ord || chksum != ldir->chksum) {
 80a1f22:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 80a1f26:	fa5f fb8b 	uxtb.w	fp, fp
 80a1f2a:	455a      	cmp	r2, fp
 80a1f2c:	d1c6      	bne.n	80a1ebc <_ZN7FatFile4openEPS_P7fname_ti+0x17c>
 80a1f2e:	7b42      	ldrb	r2, [r0, #13]
 80a1f30:	429a      	cmp	r2, r3
 80a1f32:	d0d6      	beq.n	80a1ee2 <_ZN7FatFile4openEPS_P7fname_ti+0x1a2>
 80a1f34:	e7c2      	b.n	80a1ebc <_ZN7FatFile4openEPS_P7fname_ti+0x17c>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
 80a1f36:	2a0a      	cmp	r2, #10
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a1f38:	bf95      	itete	ls
 80a1f3a:	f10c 32ff 	addls.w	r2, ip, #4294967295	; 0xffffffff
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a1f3e:	f10c 0201 	addhi.w	r2, ip, #1
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a1f42:	eb00 0242 	addls.w	r2, r0, r2, lsl #1
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a1f46:	eb00 0242 	addhi.w	r2, r0, r2, lsl #1
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a1f4a:	bf94      	ite	ls
 80a1f4c:	88d2      	ldrhls	r2, [r2, #6]
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a1f4e:	8892      	ldrhhi	r2, [r2, #4]
 80a1f50:	e7e0      	b.n	80a1f14 <_ZN7FatFile4openEPS_P7fname_ti+0x1d4>
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a1f52:	2aff      	cmp	r2, #255	; 0xff
 80a1f54:	d8b2      	bhi.n	80a1ebc <_ZN7FatFile4openEPS_P7fname_ti+0x17c>
 80a1f56:	b2d2      	uxtb	r2, r2
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
 80a1f58:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
 80a1f5c:	2919      	cmp	r1, #25
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a1f5e:	f8d8 1008 	ldr.w	r1, [r8, #8]
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
 80a1f62:	bf98      	it	ls
 80a1f64:	3220      	addls	r2, #32
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a1f66:	f811 1009 	ldrb.w	r1, [r1, r9]
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
 80a1f6a:	bf98      	it	ls
 80a1f6c:	b2d2      	uxtbls	r2, r2
 80a1f6e:	f1a1 0941 	sub.w	r9, r1, #65	; 0x41
 80a1f72:	f1b9 0f19 	cmp.w	r9, #25
 80a1f76:	bf9c      	itt	ls
 80a1f78:	3120      	addls	r1, #32
 80a1f7a:	b2c9      	uxtbls	r1, r1
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a1f7c:	4291      	cmp	r1, r2
 80a1f7e:	d19d      	bne.n	80a1ebc <_ZN7FatFile4openEPS_P7fname_ti+0x17c>
      for (uint8_t i = 0; i < 13; i++) {
 80a1f80:	f10c 0c01 	add.w	ip, ip, #1
 80a1f84:	f1bc 0f0d 	cmp.w	ip, #13
 80a1f88:	d1b9      	bne.n	80a1efe <_ZN7FatFile4openEPS_P7fname_ti+0x1be>
 80a1f8a:	e70a      	b.n	80a1da2 <_ZN7FatFile4openEPS_P7fname_ti+0x62>
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
 80a1f8c:	070a      	lsls	r2, r1, #28
 80a1f8e:	d495      	bmi.n	80a1ebc <_ZN7FatFile4openEPS_P7fname_ti+0x17c>
      if (lfnOrd) {
 80a1f90:	b166      	cbz	r6, 80a1fac <_ZN7FatFile4openEPS_P7fname_ti+0x26c>
        if (1 == ord && lfnChecksum(dir->name) == chksum) {
 80a1f92:	f1bb 0f01 	cmp.w	fp, #1
 80a1f96:	9302      	str	r3, [sp, #8]
 80a1f98:	f47f aedd 	bne.w	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
 80a1f9c:	f7ff fd16 	bl	80a19cc <_ZN7FatFile11lfnChecksumEPh>
 80a1fa0:	9b02      	ldr	r3, [sp, #8]
 80a1fa2:	4298      	cmp	r0, r3
 80a1fa4:	f47f aed7 	bne.w	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
 80a1fa8:	46b2      	mov	sl, r6
 80a1faa:	e00e      	b.n	80a1fca <_ZN7FatFile4openEPS_P7fname_ti+0x28a>
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
 80a1fac:	220b      	movs	r2, #11
 80a1fae:	9907      	ldr	r1, [sp, #28]
 80a1fb0:	9306      	str	r3, [sp, #24]
 80a1fb2:	f005 fc4b 	bl	80a784c <memcmp>
 80a1fb6:	9b06      	ldr	r3, [sp, #24]
 80a1fb8:	2800      	cmp	r0, #0
 80a1fba:	f47f aef2 	bne.w	80a1da2 <_ZN7FatFile4openEPS_P7fname_ti+0x62>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
 80a1fbe:	f898 a000 	ldrb.w	sl, [r8]
 80a1fc2:	f01a 0a01 	ands.w	sl, sl, #1
 80a1fc6:	f47f af64 	bne.w	80a1e92 <_ZN7FatFile4openEPS_P7fname_ti+0x152>
  if (oflag & O_EXCL) {
 80a1fca:	9b04      	ldr	r3, [sp, #16]
 80a1fcc:	0519      	lsls	r1, r3, #20
 80a1fce:	f53f aec2 	bmi.w	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
 80a1fd2:	464a      	mov	r2, r9
 80a1fd4:	4629      	mov	r1, r5
 80a1fd6:	9b04      	ldr	r3, [sp, #16]
 80a1fd8:	9805      	ldr	r0, [sp, #20]
 80a1fda:	f8cd a000 	str.w	sl, [sp]
 80a1fde:	f7ff fadd 	bl	80a159c <_ZN7FatFile15openCachedEntryEPS_tih>
 80a1fe2:	e6b9      	b.n	80a1d58 <_ZN7FatFile4openEPS_P7fname_ti+0x18>
    dir = dirFile->readDirCache();
 80a1fe4:	2100      	movs	r1, #0
 80a1fe6:	4628      	mov	r0, r5
 80a1fe8:	f7ff fa76 	bl	80a14d8 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
 80a1fec:	b998      	cbnz	r0, 80a2016 <_ZN7FatFile4openEPS_P7fname_ti+0x2d6>
      if (dirFile->getError()) {
 80a1fee:	786b      	ldrb	r3, [r5, #1]
 80a1ff0:	2b00      	cmp	r3, #0
 80a1ff2:	f47f aeb0 	bne.w	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
    if (!dirFile->addDirCluster()) {
 80a1ff6:	4628      	mov	r0, r5
 80a1ff8:	f7ff f91c 	bl	80a1234 <_ZN7FatFile13addDirClusterEv>
 80a1ffc:	2800      	cmp	r0, #0
 80a1ffe:	f43f aeaa 	beq.w	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
    if (dirFile->m_vol->blocksPerCluster() > 1) {
 80a2002:	68ab      	ldr	r3, [r5, #8]
 80a2004:	791b      	ldrb	r3, [r3, #4]
 80a2006:	2b01      	cmp	r3, #1
 80a2008:	f63f aee9 	bhi.w	80a1dde <_ZN7FatFile4openEPS_P7fname_ti+0x9e>
    freeFound += 16;
 80a200c:	3410      	adds	r4, #16
 80a200e:	b2e4      	uxtb	r4, r4
  while (freeFound < freeNeed) {
 80a2010:	42a7      	cmp	r7, r4
 80a2012:	d8f0      	bhi.n	80a1ff6 <_ZN7FatFile4openEPS_P7fname_ti+0x2b6>
 80a2014:	e6e3      	b.n	80a1dde <_ZN7FatFile4openEPS_P7fname_ti+0x9e>
    freeFound++;
 80a2016:	3401      	adds	r4, #1
 80a2018:	b2e4      	uxtb	r4, r4
  while (freeFound < freeNeed) {
 80a201a:	e6dd      	b.n	80a1dd8 <_ZN7FatFile4openEPS_P7fname_ti+0x98>
    if (!dirFile->lfnUniqueSfn(fname)) {
 80a201c:	4641      	mov	r1, r8
 80a201e:	4628      	mov	r0, r5
 80a2020:	f7ff fe3b 	bl	80a1c9a <_ZN7FatFile12lfnUniqueSfnEP7fname_t>
 80a2024:	2800      	cmp	r0, #0
 80a2026:	f47f aede 	bne.w	80a1de6 <_ZN7FatFile4openEPS_P7fname_ti+0xa6>
 80a202a:	e694      	b.n	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
 80a202c:	bf14      	ite	ne
 80a202e:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80a2032:	2100      	moveq	r1, #0
 80a2034:	b289      	uxth	r1, r1
 80a2036:	e719      	b.n	80a1e6c <_ZN7FatFile4openEPS_P7fname_ti+0x12c>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
 80a2038:	f1be 0f0a 	cmp.w	lr, #10
    ldir->name2[i - LDIR_NAME1_DIM] = c;
 80a203c:	bf94      	ite	ls
 80a203e:	eb04 0343 	addls.w	r3, r4, r3, lsl #1
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
 80a2042:	eb04 0340 	addhi.w	r3, r4, r0, lsl #1
 80a2046:	8099      	strh	r1, [r3, #4]
 80a2048:	e71b      	b.n	80a1e82 <_ZN7FatFile4openEPS_P7fname_ti+0x142>
  dir = dirFile->readDirCache();
 80a204a:	4631      	mov	r1, r6
 80a204c:	4628      	mov	r0, r5
  curIndex = dirFile->m_curPosition/32;
 80a204e:	696f      	ldr	r7, [r5, #20]
  dir = dirFile->readDirCache();
 80a2050:	f7ff fa42 	bl	80a14d8 <_ZN7FatFile12readDirCacheEb>
  if (!dir) {
 80a2054:	4604      	mov	r4, r0
 80a2056:	2800      	cmp	r0, #0
 80a2058:	f43f ae7d 	beq.w	80a1d56 <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  memset(dir, 0, sizeof(dir_t));
 80a205c:	2220      	movs	r2, #32
 80a205e:	4631      	mov	r1, r6
 80a2060:	f005 fc2a 	bl	80a78b8 <memset>
  memcpy(dir->name, fname->sfn, 11);
 80a2064:	4643      	mov	r3, r8
 80a2066:	f853 2f0d 	ldr.w	r2, [r3, #13]!
 80a206a:	6022      	str	r2, [r4, #0]
 80a206c:	685a      	ldr	r2, [r3, #4]
 80a206e:	6062      	str	r2, [r4, #4]
 80a2070:	891a      	ldrh	r2, [r3, #8]
 80a2072:	8122      	strh	r2, [r4, #8]
 80a2074:	7a9b      	ldrb	r3, [r3, #10]
 80a2076:	72a3      	strb	r3, [r4, #10]
  dir->reservedNT =  (DIR_NT_LC_BASE | DIR_NT_LC_EXT) & fname->flags;
 80a2078:	f898 3000 	ldrb.w	r3, [r8]
 80a207c:	f003 0318 	and.w	r3, r3, #24
 80a2080:	7323      	strb	r3, [r4, #12]
  if (m_dateTime) {
 80a2082:	4b0f      	ldr	r3, [pc, #60]	; (80a20c0 <_ZN7FatFile4openEPS_P7fname_ti+0x380>)
 80a2084:	681b      	ldr	r3, [r3, #0]
 80a2086:	b19b      	cbz	r3, 80a20b0 <_ZN7FatFile4openEPS_P7fname_ti+0x370>
    m_dateTime(&dir->creationDate, &dir->creationTime);
 80a2088:	f104 010e 	add.w	r1, r4, #14
 80a208c:	f104 0010 	add.w	r0, r4, #16
 80a2090:	4798      	blx	r3
  dir->lastAccessDate = dir->creationDate;
 80a2092:	8a23      	ldrh	r3, [r4, #16]
  curIndex = dirFile->m_curPosition/32;
 80a2094:	f3c7 194f 	ubfx	r9, r7, #5, #16
  dir->lastAccessDate = dir->creationDate;
 80a2098:	8263      	strh	r3, [r4, #18]
  dir->lastWriteDate = dir->creationDate;
 80a209a:	8323      	strh	r3, [r4, #24]
  dir->lastWriteTime = dir->creationTime;
 80a209c:	89e3      	ldrh	r3, [r4, #14]
 80a209e:	82e3      	strh	r3, [r4, #22]
  dirFile->m_vol->cacheDirty();
 80a20a0:	68aa      	ldr	r2, [r5, #8]
 80a20a2:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 80a20a6:	f043 0301 	orr.w	r3, r3, #1
 80a20aa:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
  }
 80a20ae:	e790      	b.n	80a1fd2 <_ZN7FatFile4openEPS_P7fname_ti+0x292>
    dir->creationDate = FAT_DEFAULT_DATE;
 80a20b0:	2321      	movs	r3, #33	; 0x21
 80a20b2:	7423      	strb	r3, [r4, #16]
 80a20b4:	2328      	movs	r3, #40	; 0x28
 80a20b6:	7463      	strb	r3, [r4, #17]
    dir->creationTime = FAT_DEFAULT_TIME;
 80a20b8:	2308      	movs	r3, #8
 80a20ba:	73a6      	strb	r6, [r4, #14]
 80a20bc:	73e3      	strb	r3, [r4, #15]
 80a20be:	e7e8      	b.n	80a2092 <_ZN7FatFile4openEPS_P7fname_ti+0x352>
 80a20c0:	20001614 	.word	0x20001614

080a20c4 <_ZL7print2uP5Printh>:
// print uint8_t with width 2
static void print2u(print_t* pr, uint8_t v) {
  char c0 = '?';
  char c1 = '?';
  if (v < 100) {
    c1 = v/10;
 80a20c4:	230a      	movs	r3, #10
 80a20c6:	fbb1 f3f3 	udiv	r3, r1, r3
static void print2u(print_t* pr, uint8_t v) {
 80a20ca:	b570      	push	{r4, r5, r6, lr}
 80a20cc:	4605      	mov	r5, r0
    c0 = v - 10*c1 + '0';
 80a20ce:	ebc3 1443 	rsb	r4, r3, r3, lsl #5
 80a20d2:	ebc3 0284 	rsb	r2, r3, r4, lsl #2
 80a20d6:	f101 0430 	add.w	r4, r1, #48	; 0x30
    c1 += '0';
 80a20da:	f103 0130 	add.w	r1, r3, #48	; 0x30
  }
  pr->write(c1);
 80a20de:	6803      	ldr	r3, [r0, #0]
 80a20e0:	b2c9      	uxtb	r1, r1
 80a20e2:	689b      	ldr	r3, [r3, #8]
    c0 = v - 10*c1 + '0';
 80a20e4:	eb04 0442 	add.w	r4, r4, r2, lsl #1
  pr->write(c1);
 80a20e8:	4798      	blx	r3
  pr->write(c0);
 80a20ea:	682b      	ldr	r3, [r5, #0]
    c0 = v - 10*c1 + '0';
 80a20ec:	b2e4      	uxtb	r4, r4
  pr->write(c0);
 80a20ee:	4621      	mov	r1, r4
 80a20f0:	4628      	mov	r0, r5
}
 80a20f2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  pr->write(c0);
 80a20f6:	689b      	ldr	r3, [r3, #8]
 80a20f8:	4718      	bx	r3

080a20fa <_ZN5Print5writeEPKc>:
    size_t write(const char *str) {
 80a20fa:	b570      	push	{r4, r5, r6, lr}
 80a20fc:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a20fe:	460c      	mov	r4, r1
    }
 80a2100:	4608      	mov	r0, r1
      if (str == NULL) return 0;
 80a2102:	b149      	cbz	r1, 80a2118 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a2104:	f005 fc61 	bl	80a79ca <strlen>
 80a2108:	682b      	ldr	r3, [r5, #0]
 80a210a:	4602      	mov	r2, r0
 80a210c:	4621      	mov	r1, r4
 80a210e:	4628      	mov	r0, r5
    }
 80a2110:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return write((const uint8_t *)str, strlen(str));
 80a2114:	68db      	ldr	r3, [r3, #12]
 80a2116:	4718      	bx	r3
    }
 80a2118:	bd70      	pop	{r4, r5, r6, pc}

080a211a <_ZN7FatFile12printFatDateEP5Printt>:
//------------------------------------------------------------------------------
static void printU32(print_t* pr, uint32_t v) {
  char buf[11];
  char* ptr = buf + sizeof(buf);
  *--ptr = 0;
 80a211a:	2300      	movs	r3, #0

fail:
  return false;
}
//------------------------------------------------------------------------------
void FatFile::printFatDate(print_t* pr, uint16_t fatDate) {
 80a211c:	b530      	push	{r4, r5, lr}
 80a211e:	4604      	mov	r4, r0
 80a2120:	b085      	sub	sp, #20
 * \param[in] fatDate Date in packed dir format.
 *
 * \return Extracted year [1980,2107]
 */
static inline uint16_t FAT_YEAR(uint16_t fatDate) {
  return 1980 + (fatDate >> 9);
 80a2122:	1248      	asrs	r0, r1, #9
 80a2124:	460d      	mov	r5, r1
  pr->write(fmtDec(v, ptr));
 80a2126:	f200 70bc 	addw	r0, r0, #1980	; 0x7bc
 80a212a:	f10d 010e 	add.w	r1, sp, #14
  *--ptr = 0;
 80a212e:	f88d 300e 	strb.w	r3, [sp, #14]
  pr->write(fmtDec(v, ptr));
 80a2132:	f000 fac1 	bl	80a26b8 <_Z6fmtDecmPc>
 80a2136:	4601      	mov	r1, r0
 80a2138:	4620      	mov	r0, r4
 80a213a:	f7ff ffde 	bl	80a20fa <_ZN5Print5writeEPKc>
  printU32(pr, FAT_YEAR(fatDate));
  pr->write('-');
 80a213e:	6823      	ldr	r3, [r4, #0]
 80a2140:	212d      	movs	r1, #45	; 0x2d
 80a2142:	689b      	ldr	r3, [r3, #8]
 80a2144:	4620      	mov	r0, r4
 80a2146:	4798      	blx	r3
  print2u(pr, FAT_MONTH(fatDate));
 80a2148:	4620      	mov	r0, r4
 80a214a:	f3c5 1143 	ubfx	r1, r5, #5, #4
 80a214e:	f7ff ffb9 	bl	80a20c4 <_ZL7print2uP5Printh>
  pr->write('-');
 80a2152:	6823      	ldr	r3, [r4, #0]
 80a2154:	212d      	movs	r1, #45	; 0x2d
 80a2156:	689b      	ldr	r3, [r3, #8]
 80a2158:	4620      	mov	r0, r4
 80a215a:	4798      	blx	r3
  print2u(pr, FAT_DAY(fatDate));
 80a215c:	4620      	mov	r0, r4
 80a215e:	f005 011f 	and.w	r1, r5, #31
 80a2162:	f7ff ffaf 	bl	80a20c4 <_ZL7print2uP5Printh>
}
 80a2166:	b005      	add	sp, #20
 80a2168:	bd30      	pop	{r4, r5, pc}

080a216a <_ZN7FatFile12printFatTimeEP5Printt>:
//------------------------------------------------------------------------------
void FatFile::printFatTime(print_t* pr, uint16_t fatTime) {
 80a216a:	b538      	push	{r3, r4, r5, lr}
 80a216c:	4604      	mov	r4, r0
 80a216e:	460d      	mov	r5, r1
  print2u(pr, FAT_HOUR(fatTime));
 80a2170:	0ac9      	lsrs	r1, r1, #11
 80a2172:	f7ff ffa7 	bl	80a20c4 <_ZL7print2uP5Printh>
  pr->write(':');
 80a2176:	6823      	ldr	r3, [r4, #0]
 80a2178:	213a      	movs	r1, #58	; 0x3a
 80a217a:	689b      	ldr	r3, [r3, #8]
 80a217c:	4620      	mov	r0, r4
 80a217e:	4798      	blx	r3
  print2u(pr, FAT_MINUTE(fatTime));
 80a2180:	4620      	mov	r0, r4
 80a2182:	f3c5 1145 	ubfx	r1, r5, #5, #6
 80a2186:	f7ff ff9d 	bl	80a20c4 <_ZL7print2uP5Printh>
  pr->write(':');
 80a218a:	6823      	ldr	r3, [r4, #0]
 80a218c:	213a      	movs	r1, #58	; 0x3a
 80a218e:	4620      	mov	r0, r4
 80a2190:	689b      	ldr	r3, [r3, #8]
 80a2192:	4798      	blx	r3
 * \param[in] fatTime Time in packed dir format.
 *
 * \return Extracted second [0,58]
 */
static inline uint8_t FAT_SECOND(uint16_t fatTime) {
  return 2*(fatTime & 0X1F);
 80a2194:	f005 011f 	and.w	r1, r5, #31
  print2u(pr, FAT_SECOND(fatTime));
 80a2198:	4620      	mov	r0, r4
}
 80a219a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  print2u(pr, FAT_SECOND(fatTime));
 80a219e:	0049      	lsls	r1, r1, #1
 80a21a0:	f7ff bf90 	b.w	80a20c4 <_ZL7print2uP5Printh>

080a21a4 <_ZN7FatFile19printModifyDateTimeEP5Print>:
    value = -value;
  }
  return printFieldT(this, sign, (uint32_t)value, term);
}
//------------------------------------------------------------------------------
bool FatFile::printModifyDateTime(print_t* pr) {
 80a21a4:	b530      	push	{r4, r5, lr}
 80a21a6:	b089      	sub	sp, #36	; 0x24
 80a21a8:	460c      	mov	r4, r1
  dir_t dir;
  if (!dirEntry(&dir)) {
 80a21aa:	4669      	mov	r1, sp
 80a21ac:	f7ff fb2c 	bl	80a1808 <_ZN7FatFile8dirEntryEP14directoryEntry>
 80a21b0:	4605      	mov	r5, r0
 80a21b2:	b170      	cbz	r0, 80a21d2 <_ZN7FatFile19printModifyDateTimeEP5Print+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  printFatDate(pr, dir.lastWriteDate);
 80a21b4:	4620      	mov	r0, r4
 80a21b6:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 80a21ba:	f7ff ffae 	bl	80a211a <_ZN7FatFile12printFatDateEP5Printt>
  pr->write(' ');
 80a21be:	6823      	ldr	r3, [r4, #0]
 80a21c0:	2120      	movs	r1, #32
 80a21c2:	4620      	mov	r0, r4
 80a21c4:	689b      	ldr	r3, [r3, #8]
 80a21c6:	4798      	blx	r3
  printFatTime(pr, dir.lastWriteTime);
 80a21c8:	4620      	mov	r0, r4
 80a21ca:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 80a21ce:	f7ff ffcc 	bl	80a216a <_ZN7FatFile12printFatTimeEP5Printt>
  return true;

fail:
  return false;
}
 80a21d2:	4628      	mov	r0, r5
 80a21d4:	b009      	add	sp, #36	; 0x24
 80a21d6:	bd30      	pop	{r4, r5, pc}

080a21d8 <_ZN7FatFile13printFileSizeEP5Print>:
//------------------------------------------------------------------------------
size_t FatFile::printFileSize(print_t* pr) {
 80a21d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  char buf[11];
  char *ptr = buf + sizeof(buf);
  *--ptr = 0;
 80a21da:	2300      	movs	r3, #0
size_t FatFile::printFileSize(print_t* pr) {
 80a21dc:	460c      	mov	r4, r1
  ptr = fmtDec(fileSize(), ptr);
 80a21de:	69c0      	ldr	r0, [r0, #28]
 80a21e0:	f10d 010e 	add.w	r1, sp, #14
  *--ptr = 0;
 80a21e4:	f88d 300e 	strb.w	r3, [sp, #14]
  ptr = fmtDec(fileSize(), ptr);
 80a21e8:	f000 fa66 	bl	80a26b8 <_Z6fmtDecmPc>
  while (ptr > buf) {
    *--ptr = ' ';
 80a21ec:	2320      	movs	r3, #32
  while (ptr > buf) {
 80a21ee:	a901      	add	r1, sp, #4
 80a21f0:	4288      	cmp	r0, r1
 80a21f2:	d902      	bls.n	80a21fa <_ZN7FatFile13printFileSizeEP5Print+0x22>
    *--ptr = ' ';
 80a21f4:	f800 3d01 	strb.w	r3, [r0, #-1]!
  while (ptr > buf) {
 80a21f8:	e7fa      	b.n	80a21f0 <_ZN7FatFile13printFileSizeEP5Print+0x18>
  }
  return pr->write(buf);
 80a21fa:	4620      	mov	r0, r4
 80a21fc:	f7ff ff7d 	bl	80a20fa <_ZN5Print5writeEPKc>
}
 80a2200:	b004      	add	sp, #16
 80a2202:	bd10      	pop	{r4, pc}

080a2204 <_ZN7FatFile2lsEP5Printhh>:
bool FatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
 80a2204:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a2208:	461f      	mov	r7, r3
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
 80a220a:	2300      	movs	r3, #0
 80a220c:	b08b      	sub	sp, #44	; 0x2c
 80a220e:	f8ad 3004 	strh.w	r3, [sp, #4]
  if (!isDir() || getError()) {
 80a2212:	7803      	ldrb	r3, [r0, #0]
bool FatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
 80a2214:	4606      	mov	r6, r0
  if (!isDir() || getError()) {
 80a2216:	f013 0f70 	tst.w	r3, #112	; 0x70
bool FatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
 80a221a:	460c      	mov	r4, r1
 80a221c:	4615      	mov	r5, r2
  if (!isDir() || getError()) {
 80a221e:	d103      	bne.n	80a2228 <_ZN7FatFile2lsEP5Printhh+0x24>
  return false;
 80a2220:	2000      	movs	r0, #0
}
 80a2222:	b00b      	add	sp, #44	; 0x2c
 80a2224:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (!isDir() || getError()) {
 80a2228:	7841      	ldrb	r1, [r0, #1]
 80a222a:	2900      	cmp	r1, #0
 80a222c:	d1f8      	bne.n	80a2220 <_ZN7FatFile2lsEP5Printhh+0x1c>
    seekSet(0);
 80a222e:	f7ff f972 	bl	80a1516 <_ZN7FatFile7seekSetEm>
      if (flags & LS_DATE) {
 80a2232:	f005 0902 	and.w	r9, r5, #2
  while (file.openNext(this, O_RDONLY)) {
 80a2236:	2200      	movs	r2, #0
 80a2238:	4631      	mov	r1, r6
 80a223a:	a801      	add	r0, sp, #4
 80a223c:	f7ff fa1b 	bl	80a1676 <_ZN7FatFile8openNextEPS_i>
 80a2240:	2800      	cmp	r0, #0
 80a2242:	d054      	beq.n	80a22ee <_ZN7FatFile2lsEP5Printhh+0xea>
    if (!file.isHidden() || (flags & LS_A)) {
 80a2244:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80a2248:	0798      	lsls	r0, r3, #30
 80a224a:	d501      	bpl.n	80a2250 <_ZN7FatFile2lsEP5Printhh+0x4c>
 80a224c:	07e9      	lsls	r1, r5, #31
 80a224e:	d54a      	bpl.n	80a22e6 <_ZN7FatFile2lsEP5Printhh+0xe2>
bool FatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
 80a2250:	f04f 0800 	mov.w	r8, #0
      for (uint8_t i = 0; i < indent; i++) {
 80a2254:	45b8      	cmp	r8, r7
 80a2256:	d007      	beq.n	80a2268 <_ZN7FatFile2lsEP5Printhh+0x64>
        pr->write(' ');
 80a2258:	6823      	ldr	r3, [r4, #0]
 80a225a:	2120      	movs	r1, #32
 80a225c:	4620      	mov	r0, r4
 80a225e:	689b      	ldr	r3, [r3, #8]
 80a2260:	4798      	blx	r3
      for (uint8_t i = 0; i < indent; i++) {
 80a2262:	f108 0801 	add.w	r8, r8, #1
 80a2266:	e7f5      	b.n	80a2254 <_ZN7FatFile2lsEP5Printhh+0x50>
      if (flags & LS_DATE) {
 80a2268:	f1b9 0f00 	cmp.w	r9, #0
 80a226c:	d008      	beq.n	80a2280 <_ZN7FatFile2lsEP5Printhh+0x7c>
        file.printModifyDateTime(pr);
 80a226e:	4621      	mov	r1, r4
 80a2270:	a801      	add	r0, sp, #4
 80a2272:	f7ff ff97 	bl	80a21a4 <_ZN7FatFile19printModifyDateTimeEP5Print>
        pr->write(' ');
 80a2276:	6823      	ldr	r3, [r4, #0]
 80a2278:	2120      	movs	r1, #32
 80a227a:	4620      	mov	r0, r4
 80a227c:	689b      	ldr	r3, [r3, #8]
 80a227e:	4798      	blx	r3
      if (flags & LS_SIZE) {
 80a2280:	076a      	lsls	r2, r5, #29
 80a2282:	d508      	bpl.n	80a2296 <_ZN7FatFile2lsEP5Printhh+0x92>
        file.printFileSize(pr);
 80a2284:	4621      	mov	r1, r4
 80a2286:	a801      	add	r0, sp, #4
 80a2288:	f7ff ffa6 	bl	80a21d8 <_ZN7FatFile13printFileSizeEP5Print>
        pr->write(' ');
 80a228c:	6823      	ldr	r3, [r4, #0]
 80a228e:	2120      	movs	r1, #32
 80a2290:	4620      	mov	r0, r4
 80a2292:	689b      	ldr	r3, [r3, #8]
 80a2294:	4798      	blx	r3
      file.printName(pr);
 80a2296:	4621      	mov	r1, r4
 80a2298:	a801      	add	r0, sp, #4
 80a229a:	f7ff fc9d 	bl	80a1bd8 <_ZN7FatFile9printNameEP5Print>
      if (file.isDir()) {
 80a229e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80a22a2:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a22a6:	d004      	beq.n	80a22b2 <_ZN7FatFile2lsEP5Printhh+0xae>
        pr->write('/');
 80a22a8:	6823      	ldr	r3, [r4, #0]
 80a22aa:	212f      	movs	r1, #47	; 0x2f
 80a22ac:	4620      	mov	r0, r4
 80a22ae:	689b      	ldr	r3, [r3, #8]
 80a22b0:	4798      	blx	r3
      pr->write('\r');
 80a22b2:	6823      	ldr	r3, [r4, #0]
 80a22b4:	210d      	movs	r1, #13
 80a22b6:	689b      	ldr	r3, [r3, #8]
 80a22b8:	4620      	mov	r0, r4
 80a22ba:	4798      	blx	r3
      pr->write('\n');
 80a22bc:	6823      	ldr	r3, [r4, #0]
 80a22be:	210a      	movs	r1, #10
 80a22c0:	689b      	ldr	r3, [r3, #8]
 80a22c2:	4620      	mov	r0, r4
 80a22c4:	4798      	blx	r3
      if ((flags & LS_R) && file.isDir()) {
 80a22c6:	072b      	lsls	r3, r5, #28
 80a22c8:	d50d      	bpl.n	80a22e6 <_ZN7FatFile2lsEP5Printhh+0xe2>
 80a22ca:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80a22ce:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a22d2:	d008      	beq.n	80a22e6 <_ZN7FatFile2lsEP5Printhh+0xe2>
        if (!file.ls(pr, flags, indent + 2)) {
 80a22d4:	1cbb      	adds	r3, r7, #2
 80a22d6:	462a      	mov	r2, r5
 80a22d8:	4621      	mov	r1, r4
 80a22da:	b2db      	uxtb	r3, r3
 80a22dc:	a801      	add	r0, sp, #4
 80a22de:	f7ff ff91 	bl	80a2204 <_ZN7FatFile2lsEP5Printhh>
 80a22e2:	2800      	cmp	r0, #0
 80a22e4:	d09c      	beq.n	80a2220 <_ZN7FatFile2lsEP5Printhh+0x1c>
    file.close();
 80a22e6:	a801      	add	r0, sp, #4
 80a22e8:	f7ff fa3a 	bl	80a1760 <_ZN7FatFile5closeEv>
  while (file.openNext(this, O_RDONLY)) {
 80a22ec:	e7a3      	b.n	80a2236 <_ZN7FatFile2lsEP5Printhh+0x32>
  if (getError()) {
 80a22ee:	7870      	ldrb	r0, [r6, #1]
 80a22f0:	fab0 f080 	clz	r0, r0
 80a22f4:	0940      	lsrs	r0, r0, #5
 80a22f6:	e794      	b.n	80a2222 <_ZN7FatFile2lsEP5Printhh+0x1e>

080a22f8 <_ZN7FatFile6getSFNEPc>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FatFile.h"
#include "FatFileSystem.h"
//------------------------------------------------------------------------------
bool FatFile::getSFN(char* name) {
 80a22f8:	b510      	push	{r4, lr}
 80a22fa:	460c      	mov	r4, r1
  dir_t* dir;
  if (!isOpen()) {
 80a22fc:	7801      	ldrb	r1, [r0, #0]
 80a22fe:	b909      	cbnz	r1, 80a2304 <_ZN7FatFile6getSFNEPc+0xc>
  // format name
  dirName(dir, name);
  return true;

fail:
  return false;
 80a2300:	2000      	movs	r0, #0
}
 80a2302:	bd10      	pop	{r4, pc}
  if (isRoot()) {
 80a2304:	f011 0160 	ands.w	r1, r1, #96	; 0x60
 80a2308:	d005      	beq.n	80a2316 <_ZN7FatFile6getSFNEPc+0x1e>
    name[0] = '/';
 80a230a:	232f      	movs	r3, #47	; 0x2f
 80a230c:	7023      	strb	r3, [r4, #0]
    name[1] = '\0';
 80a230e:	2300      	movs	r3, #0
 80a2310:	7063      	strb	r3, [r4, #1]
  return true;
 80a2312:	2001      	movs	r0, #1
 80a2314:	e7f5      	b.n	80a2302 <_ZN7FatFile6getSFNEPc+0xa>
  dir = cacheDirEntry(FatCache::CACHE_FOR_READ);
 80a2316:	f7fe ffcb 	bl	80a12b0 <_ZN7FatFile13cacheDirEntryEh>
  if (!dir) {
 80a231a:	2800      	cmp	r0, #0
 80a231c:	d0f0      	beq.n	80a2300 <_ZN7FatFile6getSFNEPc+0x8>
  dirName(dir, name);
 80a231e:	4621      	mov	r1, r4
 80a2320:	f7fe ffd5 	bl	80a12ce <_ZN7FatFile7dirNameEPK14directoryEntryPc>
 80a2324:	e7f5      	b.n	80a2312 <_ZN7FatFile6getSFNEPc+0x1a>

080a2326 <_ZN7FatFile8printSFNEP5Print>:
//------------------------------------------------------------------------------
size_t FatFile::printSFN(print_t* pr) {
 80a2326:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80a2328:	460c      	mov	r4, r1
  char name[13];
  if (!getSFN(name)) {
 80a232a:	4669      	mov	r1, sp
 80a232c:	f7ff ffe4 	bl	80a22f8 <_ZN7FatFile6getSFNEPc>
 80a2330:	b140      	cbz	r0, 80a2344 <_ZN7FatFile8printSFNEP5Print+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a2332:	4668      	mov	r0, sp
 80a2334:	f005 fb49 	bl	80a79ca <strlen>
 80a2338:	6823      	ldr	r3, [r4, #0]
 80a233a:	4602      	mov	r2, r0
 80a233c:	4669      	mov	r1, sp
 80a233e:	4620      	mov	r0, r4
 80a2340:	68db      	ldr	r3, [r3, #12]
 80a2342:	4798      	blx	r3
  }
  return pr->write(name);

fail:
  return 0;
}
 80a2344:	b004      	add	sp, #16
 80a2346:	bd10      	pop	{r4, pc}

080a2348 <_ZN8FatCache4syncEv>:
fail:

  return 0;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
 80a2348:	b570      	push	{r4, r5, r6, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
 80a234a:	7803      	ldrb	r3, [r0, #0]
bool FatCache::sync() {
 80a234c:	4604      	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
 80a234e:	07da      	lsls	r2, r3, #31
 80a2350:	d51f      	bpl.n	80a2392 <_ZN8FatCache4syncEv+0x4a>
    if (!m_vol->writeBlock(m_lbn, m_block.data)) {
 80a2352:	6843      	ldr	r3, [r0, #4]
 80a2354:	f100 060c 	add.w	r6, r0, #12
    return m_blockDev->writeBlock(block, src);
 80a2358:	6881      	ldr	r1, [r0, #8]
 80a235a:	4632      	mov	r2, r6
 80a235c:	6818      	ldr	r0, [r3, #0]
 80a235e:	f000 fbce 	bl	80a2afe <_ZN9SdSpiCard10writeBlockEmPKh>
 80a2362:	4605      	mov	r5, r0
 80a2364:	b910      	cbnz	r0, 80a236c <_ZN8FatCache4syncEv+0x24>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

fail:
  return false;
 80a2366:	2500      	movs	r5, #0
}
 80a2368:	4628      	mov	r0, r5
 80a236a:	bd70      	pop	{r4, r5, r6, pc}
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
 80a236c:	7823      	ldrb	r3, [r4, #0]
 80a236e:	079b      	lsls	r3, r3, #30
 80a2370:	d404      	bmi.n	80a237c <_ZN8FatCache4syncEv+0x34>
    m_status &= ~CACHE_STATUS_DIRTY;
 80a2372:	7823      	ldrb	r3, [r4, #0]
 80a2374:	f023 0301 	bic.w	r3, r3, #1
 80a2378:	7023      	strb	r3, [r4, #0]
 80a237a:	e7f5      	b.n	80a2368 <_ZN8FatCache4syncEv+0x20>
      uint32_t lbn = m_lbn + m_vol->blocksPerFat();
 80a237c:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
 80a2380:	6919      	ldr	r1, [r3, #16]
 80a2382:	4632      	mov	r2, r6
 80a2384:	4401      	add	r1, r0
 80a2386:	6818      	ldr	r0, [r3, #0]
 80a2388:	f000 fbb9 	bl	80a2afe <_ZN9SdSpiCard10writeBlockEmPKh>
      if (!m_vol->writeBlock(lbn, m_block.data)) {
 80a238c:	2800      	cmp	r0, #0
 80a238e:	d1f0      	bne.n	80a2372 <_ZN8FatCache4syncEv+0x2a>
 80a2390:	e7e9      	b.n	80a2366 <_ZN8FatCache4syncEv+0x1e>
  return true;
 80a2392:	2501      	movs	r5, #1
 80a2394:	e7e8      	b.n	80a2368 <_ZN8FatCache4syncEv+0x20>

080a2396 <_ZN8FatCache4readEmh>:
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
 80a2396:	b570      	push	{r4, r5, r6, lr}
  if (m_lbn != lbn) {
 80a2398:	6883      	ldr	r3, [r0, #8]
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
 80a239a:	4604      	mov	r4, r0
  if (m_lbn != lbn) {
 80a239c:	428b      	cmp	r3, r1
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
 80a239e:	460e      	mov	r6, r1
 80a23a0:	4615      	mov	r5, r2
  if (m_lbn != lbn) {
 80a23a2:	d009      	beq.n	80a23b8 <_ZN8FatCache4readEmh+0x22>
    if (!sync()) {
 80a23a4:	f7ff ffd0 	bl	80a2348 <_ZN8FatCache4syncEv>
 80a23a8:	b908      	cbnz	r0, 80a23ae <_ZN8FatCache4readEmh+0x18>
  return 0;
 80a23aa:	2000      	movs	r0, #0
}
 80a23ac:	bd70      	pop	{r4, r5, r6, pc}
    if (!(option & CACHE_OPTION_NO_READ)) {
 80a23ae:	076b      	lsls	r3, r5, #29
 80a23b0:	d50a      	bpl.n	80a23c8 <_ZN8FatCache4readEmh+0x32>
    m_status = 0;
 80a23b2:	2300      	movs	r3, #0
    m_lbn = lbn;
 80a23b4:	60a6      	str	r6, [r4, #8]
    m_status = 0;
 80a23b6:	7023      	strb	r3, [r4, #0]
  m_status |= option & CACHE_STATUS_MASK;
 80a23b8:	4620      	mov	r0, r4
 80a23ba:	7822      	ldrb	r2, [r4, #0]
 80a23bc:	f005 0503 	and.w	r5, r5, #3
 80a23c0:	4315      	orrs	r5, r2
 80a23c2:	f800 5b0c 	strb.w	r5, [r0], #12
  return &m_block;
 80a23c6:	e7f1      	b.n	80a23ac <_ZN8FatCache4readEmh+0x16>
      if (!m_vol->readBlock(lbn, m_block.data)) {
 80a23c8:	6863      	ldr	r3, [r4, #4]
    return m_blockDev->readBlock(block, dst);
 80a23ca:	4631      	mov	r1, r6
 80a23cc:	6818      	ldr	r0, [r3, #0]
 80a23ce:	f104 020c 	add.w	r2, r4, #12
 80a23d2:	f000 fb0b 	bl	80a29ec <_ZN9SdSpiCard9readBlockEmPh>
 80a23d6:	2800      	cmp	r0, #0
 80a23d8:	d1eb      	bne.n	80a23b2 <_ZN8FatCache4readEmh+0x1c>
 80a23da:	e7e6      	b.n	80a23aa <_ZN8FatCache4readEmh+0x14>

080a23dc <_ZNK9FatVolume17clusterFirstBlockEm>:
fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t FatVolume::clusterFirstBlock(uint32_t cluster) const {
  return m_dataStartBlock + ((cluster - 2) << m_clusterSizeShift);
 80a23dc:	7983      	ldrb	r3, [r0, #6]
 80a23de:	3902      	subs	r1, #2
 80a23e0:	6940      	ldr	r0, [r0, #20]
 80a23e2:	4099      	lsls	r1, r3
}
 80a23e4:	4408      	add	r0, r1
 80a23e6:	4770      	bx	lr

080a23e8 <_ZN9FatVolume6fatGetEmPm>:
  uint32_t lba;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a23e8:	2901      	cmp	r1, #1
int8_t FatVolume::fatGet(uint32_t cluster, uint32_t* value) {
 80a23ea:	b570      	push	{r4, r5, r6, lr}
 80a23ec:	4605      	mov	r5, r0
 80a23ee:	460c      	mov	r4, r1
 80a23f0:	4616      	mov	r6, r2
  if (cluster < 2 || cluster > m_lastCluster) {
 80a23f2:	d802      	bhi.n	80a23fa <_ZN9FatVolume6fatGetEmPm+0x12>
  }
  *value = next;
  return 1;

fail:
  return -1;
 80a23f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a23f8:	bd70      	pop	{r4, r5, r6, pc}
  if (cluster < 2 || cluster > m_lastCluster) {
 80a23fa:	69c3      	ldr	r3, [r0, #28]
 80a23fc:	428b      	cmp	r3, r1
 80a23fe:	d3f9      	bcc.n	80a23f4 <_ZN9FatVolume6fatGetEmPm+0xc>
  if (fatType() == 32) {
 80a2400:	79c3      	ldrb	r3, [r0, #7]
 80a2402:	2b20      	cmp	r3, #32
 80a2404:	d116      	bne.n	80a2434 <_ZN9FatVolume6fatGetEmPm+0x4c>
    lba = m_fatStartBlock + (cluster >> 7);
 80a2406:	6981      	ldr	r1, [r0, #24]
    return m_fatCache.read(blockNumber,
 80a2408:	2202      	movs	r2, #2
 80a240a:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 80a240e:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a2412:	f7ff ffc0 	bl	80a2396 <_ZN8FatCache4readEmh>
    if (!pc) {
 80a2416:	2800      	cmp	r0, #0
 80a2418:	d0ec      	beq.n	80a23f4 <_ZN9FatVolume6fatGetEmPm+0xc>
    next = pc->fat32[cluster & 0X7F] & FAT32MASK;
 80a241a:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 80a241e:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
 80a2422:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
  if (isEOC(next)) {
 80a2426:	69ea      	ldr	r2, [r5, #28]
 80a2428:	429a      	cmp	r2, r3
  return 1;
 80a242a:	bf2a      	itet	cs
 80a242c:	2001      	movcs	r0, #1
    return 0;
 80a242e:	2000      	movcc	r0, #0
  *value = next;
 80a2430:	6033      	strcs	r3, [r6, #0]
  return 1;
 80a2432:	e7e1      	b.n	80a23f8 <_ZN9FatVolume6fatGetEmPm+0x10>
  if (fatType() == 16) {
 80a2434:	2b10      	cmp	r3, #16
 80a2436:	d1dd      	bne.n	80a23f4 <_ZN9FatVolume6fatGetEmPm+0xc>
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
 80a2438:	6983      	ldr	r3, [r0, #24]
 80a243a:	f3c1 2107 	ubfx	r1, r1, #8, #8
 80a243e:	2202      	movs	r2, #2
 80a2440:	4419      	add	r1, r3
 80a2442:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a2446:	f7ff ffa6 	bl	80a2396 <_ZN8FatCache4readEmh>
    if (!pc) {
 80a244a:	2800      	cmp	r0, #0
 80a244c:	d0d2      	beq.n	80a23f4 <_ZN9FatVolume6fatGetEmPm+0xc>
    next = pc->fat16[cluster & 0XFF];
 80a244e:	b2e4      	uxtb	r4, r4
 80a2450:	f830 3014 	ldrh.w	r3, [r0, r4, lsl #1]
    goto done;
 80a2454:	e7e7      	b.n	80a2426 <_ZN9FatVolume6fatGetEmPm+0x3e>

080a2456 <_ZN9FatVolume6fatPutEmm>:
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t lba;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a2456:	2901      	cmp	r1, #1
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
 80a2458:	b538      	push	{r3, r4, r5, lr}
 80a245a:	460c      	mov	r4, r1
 80a245c:	4615      	mov	r5, r2
  if (cluster < 2 || cluster > m_lastCluster) {
 80a245e:	d801      	bhi.n	80a2464 <_ZN9FatVolume6fatPutEmm+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

fail:
  return false;
 80a2460:	2000      	movs	r0, #0
}
 80a2462:	bd38      	pop	{r3, r4, r5, pc}
  if (cluster < 2 || cluster > m_lastCluster) {
 80a2464:	69c3      	ldr	r3, [r0, #28]
 80a2466:	428b      	cmp	r3, r1
 80a2468:	d3fa      	bcc.n	80a2460 <_ZN9FatVolume6fatPutEmm+0xa>
  if (fatType() == 32) {
 80a246a:	79c3      	ldrb	r3, [r0, #7]
 80a246c:	2b20      	cmp	r3, #32
 80a246e:	d10f      	bne.n	80a2490 <_ZN9FatVolume6fatPutEmm+0x3a>
    lba = m_fatStartBlock + (cluster >> 7);
 80a2470:	6981      	ldr	r1, [r0, #24]
 80a2472:	2203      	movs	r2, #3
 80a2474:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 80a2478:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a247c:	f7ff ff8b 	bl	80a2396 <_ZN8FatCache4readEmh>
    if (!pc) {
 80a2480:	2800      	cmp	r0, #0
 80a2482:	d0ed      	beq.n	80a2460 <_ZN9FatVolume6fatPutEmm+0xa>
    pc->fat32[cluster & 0X7F] = value;
 80a2484:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 80a2488:	f840 5024 	str.w	r5, [r0, r4, lsl #2]
    return true;
 80a248c:	2001      	movs	r0, #1
 80a248e:	e7e8      	b.n	80a2462 <_ZN9FatVolume6fatPutEmm+0xc>
  if (fatType() == 16) {
 80a2490:	2b10      	cmp	r3, #16
 80a2492:	d1e5      	bne.n	80a2460 <_ZN9FatVolume6fatPutEmm+0xa>
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
 80a2494:	6983      	ldr	r3, [r0, #24]
 80a2496:	f3c1 2107 	ubfx	r1, r1, #8, #8
 80a249a:	2203      	movs	r2, #3
 80a249c:	4419      	add	r1, r3
 80a249e:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a24a2:	f7ff ff78 	bl	80a2396 <_ZN8FatCache4readEmh>
    if (!pc) {
 80a24a6:	2800      	cmp	r0, #0
 80a24a8:	d0da      	beq.n	80a2460 <_ZN9FatVolume6fatPutEmm+0xa>
    pc->fat16[cluster & 0XFF] = value;
 80a24aa:	b2e4      	uxtb	r4, r4
 80a24ac:	f820 5014 	strh.w	r5, [r0, r4, lsl #1]
 80a24b0:	e7ec      	b.n	80a248c <_ZN9FatVolume6fatPutEmm+0x36>

080a24b2 <_ZN9FatVolume15allocateClusterEmPm>:
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
 80a24b2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if (m_allocSearchStart < current) {
 80a24b6:	68c4      	ldr	r4, [r0, #12]
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
 80a24b8:	4605      	mov	r5, r0
  if (m_allocSearchStart < current) {
 80a24ba:	428c      	cmp	r4, r1
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
 80a24bc:	460e      	mov	r6, r1
 80a24be:	4690      	mov	r8, r2
  if (m_allocSearchStart < current) {
 80a24c0:	d301      	bcc.n	80a24c6 <_ZN9FatVolume15allocateClusterEmPm+0x14>
      setStart = true;
 80a24c2:	2701      	movs	r7, #1
 80a24c4:	e001      	b.n	80a24ca <_ZN9FatVolume15allocateClusterEmPm+0x18>
 80a24c6:	460c      	mov	r4, r1
    setStart = false;
 80a24c8:	2700      	movs	r7, #0
    if (find > m_lastCluster) {
 80a24ca:	69eb      	ldr	r3, [r5, #28]
    find++;
 80a24cc:	3401      	adds	r4, #1
    if (find > m_lastCluster) {
 80a24ce:	42a3      	cmp	r3, r4
 80a24d0:	d202      	bcs.n	80a24d8 <_ZN9FatVolume15allocateClusterEmPm+0x26>
      if (setStart) {
 80a24d2:	b9c7      	cbnz	r7, 80a2506 <_ZN9FatVolume15allocateClusterEmPm+0x54>
      find = m_allocSearchStart;
 80a24d4:	68ec      	ldr	r4, [r5, #12]
 80a24d6:	e7f4      	b.n	80a24c2 <_ZN9FatVolume15allocateClusterEmPm+0x10>
    if (find == current) {
 80a24d8:	42a6      	cmp	r6, r4
 80a24da:	d014      	beq.n	80a2506 <_ZN9FatVolume15allocateClusterEmPm+0x54>
    int8_t fg = fatGet(find, &f);
 80a24dc:	4621      	mov	r1, r4
 80a24de:	4628      	mov	r0, r5
 80a24e0:	aa01      	add	r2, sp, #4
 80a24e2:	f7ff ff81 	bl	80a23e8 <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
 80a24e6:	2800      	cmp	r0, #0
 80a24e8:	db0d      	blt.n	80a2506 <_ZN9FatVolume15allocateClusterEmPm+0x54>
    if (fg && f == 0) {
 80a24ea:	d0ee      	beq.n	80a24ca <_ZN9FatVolume15allocateClusterEmPm+0x18>
 80a24ec:	9b01      	ldr	r3, [sp, #4]
 80a24ee:	2b00      	cmp	r3, #0
 80a24f0:	d1eb      	bne.n	80a24ca <_ZN9FatVolume15allocateClusterEmPm+0x18>
  if (setStart) {
 80a24f2:	b107      	cbz	r7, 80a24f6 <_ZN9FatVolume15allocateClusterEmPm+0x44>
    m_allocSearchStart = find;
 80a24f4:	60ec      	str	r4, [r5, #12]
  }
  uint32_t clusterFirstBlock(uint32_t cluster) const;
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
 80a24f6:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 80a24fa:	4621      	mov	r1, r4
 80a24fc:	4628      	mov	r0, r5
 80a24fe:	f7ff ffaa 	bl	80a2456 <_ZN9FatVolume6fatPutEmm>
  if (!fatPutEOC(find)) {
 80a2502:	4607      	mov	r7, r0
 80a2504:	b920      	cbnz	r0, 80a2510 <_ZN9FatVolume15allocateClusterEmPm+0x5e>
  return false;
 80a2506:	2700      	movs	r7, #0
}
 80a2508:	4638      	mov	r0, r7
 80a250a:	b002      	add	sp, #8
 80a250c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (current) {
 80a2510:	b916      	cbnz	r6, 80a2518 <_ZN9FatVolume15allocateClusterEmPm+0x66>
  *next = find;
 80a2512:	f8c8 4000 	str.w	r4, [r8]
  return true;
 80a2516:	e7f7      	b.n	80a2508 <_ZN9FatVolume15allocateClusterEmPm+0x56>
    if (!fatPut(current, find)) {
 80a2518:	4622      	mov	r2, r4
 80a251a:	4631      	mov	r1, r6
 80a251c:	4628      	mov	r0, r5
 80a251e:	f7ff ff9a 	bl	80a2456 <_ZN9FatVolume6fatPutEmm>
 80a2522:	2800      	cmp	r0, #0
 80a2524:	d1f5      	bne.n	80a2512 <_ZN9FatVolume15allocateClusterEmPm+0x60>
 80a2526:	e7ee      	b.n	80a2506 <_ZN9FatVolume15allocateClusterEmPm+0x54>

080a2528 <_ZN9FatVolume9freeChainEm>:
//------------------------------------------------------------------------------
// free a cluster chain
bool FatVolume::freeChain(uint32_t cluster) {
 80a2528:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a252a:	4605      	mov	r5, r0
 80a252c:	460c      	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
 80a252e:	4621      	mov	r1, r4
 80a2530:	4628      	mov	r0, r5
 80a2532:	aa01      	add	r2, sp, #4
 80a2534:	f7ff ff58 	bl	80a23e8 <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
 80a2538:	1e06      	subs	r6, r0, #0
 80a253a:	db10      	blt.n	80a255e <_ZN9FatVolume9freeChainEm+0x36>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
 80a253c:	2200      	movs	r2, #0
 80a253e:	4621      	mov	r1, r4
 80a2540:	4628      	mov	r0, r5
 80a2542:	f7ff ff88 	bl	80a2456 <_ZN9FatVolume6fatPutEmm>
 80a2546:	b150      	cbz	r0, 80a255e <_ZN9FatVolume9freeChainEm+0x36>
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);

    if (cluster <= m_allocSearchStart) {
 80a2548:	68eb      	ldr	r3, [r5, #12]
 80a254a:	42a3      	cmp	r3, r4
      m_allocSearchStart = cluster - 1;
 80a254c:	bf24      	itt	cs
 80a254e:	f104 34ff 	addcs.w	r4, r4, #4294967295	; 0xffffffff
 80a2552:	60ec      	strcs	r4, [r5, #12]
    }
    cluster = next;
 80a2554:	9c01      	ldr	r4, [sp, #4]
  } while (fg);
 80a2556:	2e00      	cmp	r6, #0
 80a2558:	d1e9      	bne.n	80a252e <_ZN9FatVolume9freeChainEm+0x6>

  return true;

fail:
  return false;
}
 80a255a:	b002      	add	sp, #8
 80a255c:	bd70      	pop	{r4, r5, r6, pc}
  return false;
 80a255e:	2000      	movs	r0, #0
 80a2560:	e7fb      	b.n	80a255a <_ZN9FatVolume9freeChainEm+0x32>

080a2562 <_ZN9FatVolume4initEh>:
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
  m_allocSearchStart = 1;
 80a2562:	2301      	movs	r3, #1
bool FatVolume::init(uint8_t part) {
 80a2564:	b570      	push	{r4, r5, r6, lr}
  m_fatType = 0;
 80a2566:	2200      	movs	r2, #0
  m_allocSearchStart = 1;
 80a2568:	60c3      	str	r3, [r0, #12]
    m_lbn = 0XFFFFFFFF;
 80a256a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
bool FatVolume::init(uint8_t part) {
 80a256e:	4604      	mov	r4, r0
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(this);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
 80a2570:	460d      	mov	r5, r1
  m_fatType = 0;
 80a2572:	71c2      	strb	r2, [r0, #7]
  m_cache.init(this);
 80a2574:	f100 0624 	add.w	r6, r0, #36	; 0x24
    m_vol = vol;
 80a2578:	6280      	str	r0, [r0, #40]	; 0x28
    m_status = 0;
 80a257a:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
 80a257e:	62c3      	str	r3, [r0, #44]	; 0x2c
    m_vol = vol;
 80a2580:	f8c0 0234 	str.w	r0, [r0, #564]	; 0x234
    m_status = 0;
 80a2584:	f880 2230 	strb.w	r2, [r0, #560]	; 0x230
    m_lbn = 0XFFFFFFFF;
 80a2588:	f8c0 3238 	str.w	r3, [r0, #568]	; 0x238
  if (part) {
 80a258c:	b1b9      	cbz	r1, 80a25be <_ZN9FatVolume4initEh+0x5c>
    if (part > 4) {
 80a258e:	2904      	cmp	r1, #4
 80a2590:	d901      	bls.n	80a2596 <_ZN9FatVolume4initEh+0x34>
    m_fatType = 32;
  }
  return true;

fail:
  return false;
 80a2592:	2000      	movs	r0, #0
}
 80a2594:	bd70      	pop	{r4, r5, r6, pc}
    return m_cache.read(blockNumber, options);
 80a2596:	4611      	mov	r1, r2
 80a2598:	4630      	mov	r0, r6
 80a259a:	f7ff fefc 	bl	80a2396 <_ZN8FatCache4readEmh>
    if (!pc) {
 80a259e:	2800      	cmp	r0, #0
 80a25a0:	d0f7      	beq.n	80a2592 <_ZN9FatVolume4initEh+0x30>
    if ((p->boot & 0X7F) != 0 || p->firstSector == 0) {
 80a25a2:	eb00 1305 	add.w	r3, r0, r5, lsl #4
 80a25a6:	f893 31ae 	ldrb.w	r3, [r3, #430]	; 0x1ae
 80a25aa:	065b      	lsls	r3, r3, #25
 80a25ac:	d1f1      	bne.n	80a2592 <_ZN9FatVolume4initEh+0x30>
 80a25ae:	f105 011b 	add.w	r1, r5, #27
 80a25b2:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 80a25b6:	f8d1 5006 	ldr.w	r5, [r1, #6]
 80a25ba:	2d00      	cmp	r5, #0
 80a25bc:	d0e9      	beq.n	80a2592 <_ZN9FatVolume4initEh+0x30>
 80a25be:	2200      	movs	r2, #0
 80a25c0:	4629      	mov	r1, r5
 80a25c2:	4630      	mov	r0, r6
 80a25c4:	f7ff fee7 	bl	80a2396 <_ZN8FatCache4readEmh>
  if (!pc) {
 80a25c8:	2800      	cmp	r0, #0
 80a25ca:	d0e2      	beq.n	80a2592 <_ZN9FatVolume4initEh+0x30>
  if (fbs->bytesPerSector != 512 ||
 80a25cc:	f8b0 300b 	ldrh.w	r3, [r0, #11]
 80a25d0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80a25d4:	d1dd      	bne.n	80a2592 <_ZN9FatVolume4initEh+0x30>
 80a25d6:	7c03      	ldrb	r3, [r0, #16]
 80a25d8:	2b02      	cmp	r3, #2
 80a25da:	d1da      	bne.n	80a2592 <_ZN9FatVolume4initEh+0x30>
      fbs->fatCount != 2 ||
 80a25dc:	89c3      	ldrh	r3, [r0, #14]
 80a25de:	2b00      	cmp	r3, #0
 80a25e0:	d0d7      	beq.n	80a2592 <_ZN9FatVolume4initEh+0x30>
  m_blocksPerCluster = fbs->sectorsPerCluster;
 80a25e2:	7b41      	ldrb	r1, [r0, #13]
  m_clusterSizeShift = 0;
 80a25e4:	2609      	movs	r6, #9
  m_clusterBlockMask = m_blocksPerCluster - 1;
 80a25e6:	1e4b      	subs	r3, r1, #1
 80a25e8:	7163      	strb	r3, [r4, #5]
  m_clusterSizeShift = 0;
 80a25ea:	2300      	movs	r3, #0
 80a25ec:	71a3      	strb	r3, [r4, #6]
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
 80a25ee:	2301      	movs	r3, #1
  m_blocksPerCluster = fbs->sectorsPerCluster;
 80a25f0:	7121      	strb	r1, [r4, #4]
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
 80a25f2:	4299      	cmp	r1, r3
 80a25f4:	d007      	beq.n	80a2606 <_ZN9FatVolume4initEh+0xa4>
    if (tmp == 0) {
 80a25f6:	3e01      	subs	r6, #1
 80a25f8:	d0cb      	beq.n	80a2592 <_ZN9FatVolume4initEh+0x30>
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
 80a25fa:	79a2      	ldrb	r2, [r4, #6]
 80a25fc:	005b      	lsls	r3, r3, #1
 80a25fe:	3201      	adds	r2, #1
 80a2600:	b2db      	uxtb	r3, r3
 80a2602:	71a2      	strb	r2, [r4, #6]
 80a2604:	e7f5      	b.n	80a25f2 <_ZN9FatVolume4initEh+0x90>
  m_blocksPerFat = fbs->sectorsPerFat16 ?
 80a2606:	8ac1      	ldrh	r1, [r0, #22]
 80a2608:	b901      	cbnz	r1, 80a260c <_ZN9FatVolume4initEh+0xaa>
 80a260a:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80a260c:	6121      	str	r1, [r4, #16]
  m_fatStartBlock = volumeStartBlock + fbs->reservedSectorCount;
 80a260e:	89c3      	ldrh	r3, [r0, #14]
 80a2610:	442b      	add	r3, r5
 80a2612:	61a3      	str	r3, [r4, #24]
  m_rootDirEntryCount = fbs->rootDirEntryCount;
 80a2614:	f8b0 2011 	ldrh.w	r2, [r0, #17]
  m_rootDirStart = m_fatStartBlock + 2 * m_blocksPerFat;
 80a2618:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 80a261c:	6223      	str	r3, [r4, #32]
  m_rootDirEntryCount = fbs->rootDirEntryCount;
 80a261e:	8122      	strh	r2, [r4, #8]
  m_dataStartBlock = m_rootDirStart + ((32 * fbs->rootDirEntryCount + 511)/512);
 80a2620:	f8b0 1011 	ldrh.w	r1, [r0, #17]
 80a2624:	0149      	lsls	r1, r1, #5
 80a2626:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
 80a262a:	eb03 2351 	add.w	r3, r3, r1, lsr #9
 80a262e:	6163      	str	r3, [r4, #20]
  totalBlocks = fbs->totalSectors16 ?
 80a2630:	f8b0 2013 	ldrh.w	r2, [r0, #19]
 80a2634:	b902      	cbnz	r2, 80a2638 <_ZN9FatVolume4initEh+0xd6>
 80a2636:	6a02      	ldr	r2, [r0, #32]
  clusterCount = totalBlocks - (m_dataStartBlock - volumeStartBlock);
 80a2638:	1ae9      	subs	r1, r5, r3
  clusterCount >>= m_clusterSizeShift;
 80a263a:	79a3      	ldrb	r3, [r4, #6]
  clusterCount = totalBlocks - (m_dataStartBlock - volumeStartBlock);
 80a263c:	4411      	add	r1, r2
  clusterCount >>= m_clusterSizeShift;
 80a263e:	40d9      	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
 80a2640:	1c4b      	adds	r3, r1, #1
 80a2642:	61e3      	str	r3, [r4, #28]
  if (clusterCount < 4085) {
 80a2644:	f640 73f4 	movw	r3, #4084	; 0xff4
 80a2648:	4299      	cmp	r1, r3
 80a264a:	d802      	bhi.n	80a2652 <_ZN9FatVolume4initEh+0xf0>
    m_fatType = 12;
 80a264c:	230c      	movs	r3, #12
 80a264e:	71e3      	strb	r3, [r4, #7]
 80a2650:	e79f      	b.n	80a2592 <_ZN9FatVolume4initEh+0x30>
  } else if (clusterCount < 65525) {
 80a2652:	f64f 73f4 	movw	r3, #65524	; 0xfff4
 80a2656:	4299      	cmp	r1, r3
    m_rootDirStart = fbs->fat32RootCluster;
 80a2658:	bf89      	itett	hi
 80a265a:	6ac3      	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
 80a265c:	2310      	movls	r3, #16
    m_rootDirStart = fbs->fat32RootCluster;
 80a265e:	6223      	strhi	r3, [r4, #32]
    m_fatType = 32;
 80a2660:	2320      	movhi	r3, #32
  return true;
 80a2662:	2001      	movs	r0, #1
    m_fatType = 32;
 80a2664:	71e3      	strb	r3, [r4, #7]
 80a2666:	e795      	b.n	80a2594 <_ZN9FatVolume4initEh+0x32>

080a2668 <_Z6fmtDectPc>:
  }
  return v;
}
//------------------------------------------------------------------------------
// Format 16-bit unsigned
char* fmtDec(uint16_t n, char* p) {
 80a2668:	b510      	push	{r4, lr}
 80a266a:	4604      	mov	r4, r0
  while (n > 9) {
 80a266c:	2c09      	cmp	r4, #9
 80a266e:	b2e3      	uxtb	r3, r4
 80a2670:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
 80a2674:	d91c      	bls.n	80a26b0 <_Z6fmtDectPc+0x48>
#ifdef USE_STIMMER
    uint8_t tmp8, r;
    divmod10_asm16(n, r, tmp8);
#else  // USE_STIMMER
    uint16_t t = n;
    n = (n >> 1) + (n >> 2);
 80a2676:	10a2      	asrs	r2, r4, #2
 80a2678:	eb02 0454 	add.w	r4, r2, r4, lsr #1
    n = n + (n >> 4);
 80a267c:	f3c4 120f 	ubfx	r2, r4, #4, #16
 80a2680:	4422      	add	r2, r4
    n = n + (n >> 8);
 80a2682:	f3c2 2107 	ubfx	r1, r2, #8, #8
 80a2686:	440a      	add	r2, r1
    // n = n + (n >> 16);  // no code for 16-bit n
    n = n >> 3;
 80a2688:	f3c2 04cc 	ubfx	r4, r2, #3, #13
    uint8_t r = t - (((n << 2) + n) << 1);
 80a268c:	f3c2 02c7 	ubfx	r2, r2, #3, #8
 80a2690:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80a2694:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
 80a2698:	b2db      	uxtb	r3, r3
    if (r > 9) {
 80a269a:	2b09      	cmp	r3, #9
      n++;
      r -= 10;
 80a269c:	bf84      	itt	hi
 80a269e:	3b0a      	subhi	r3, #10
 80a26a0:	b2db      	uxtbhi	r3, r3
    }
#endif  // USE_STIMMER
    *--p = r + '0';
 80a26a2:	f103 0330 	add.w	r3, r3, #48	; 0x30
 80a26a6:	4601      	mov	r1, r0
      n++;
 80a26a8:	bf88      	it	hi
 80a26aa:	3401      	addhi	r4, #1
    *--p = r + '0';
 80a26ac:	7003      	strb	r3, [r0, #0]
  while (n > 9) {
 80a26ae:	e7dd      	b.n	80a266c <_Z6fmtDectPc+0x4>
  }
  *--p = n + '0';
 80a26b0:	3330      	adds	r3, #48	; 0x30
 80a26b2:	f801 3c01 	strb.w	r3, [r1, #-1]
  return p;
}
 80a26b6:	bd10      	pop	{r4, pc}

080a26b8 <_Z6fmtDecmPc>:
//------------------------------------------------------------------------------
// format 32-bit unsigned
char* fmtDec(uint32_t n, char* p) {
  while (n >> 16) {
 80a26b8:	0c03      	lsrs	r3, r0, #16
 80a26ba:	d01c      	beq.n	80a26f6 <_Z6fmtDecmPc+0x3e>
#ifdef USE_STIMMER
    uint8_t tmp8, r;
    divmod10_asm32(n, r, tmp8);
#else  //  USE_STIMMER
    uint32_t t = n;
    n = (n >> 1) + (n >> 2);
 80a26bc:	0883      	lsrs	r3, r0, #2
 80a26be:	eb03 0350 	add.w	r3, r3, r0, lsr #1
    n = n + (n >> 4);
 80a26c2:	eb03 1313 	add.w	r3, r3, r3, lsr #4
    n = n + (n >> 8);
 80a26c6:	eb03 2313 	add.w	r3, r3, r3, lsr #8
    n = n + (n >> 16);
 80a26ca:	eb03 4313 	add.w	r3, r3, r3, lsr #16
    n = n >> 3;
 80a26ce:	08da      	lsrs	r2, r3, #3
    uint8_t r = t - (((n << 2) + n) << 1);
 80a26d0:	f3c3 03c7 	ubfx	r3, r3, #3, #8
 80a26d4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80a26d8:	eba0 0043 	sub.w	r0, r0, r3, lsl #1
 80a26dc:	b2c0      	uxtb	r0, r0
    if (r > 9) {
 80a26de:	2809      	cmp	r0, #9
      n++;
      r -= 10;
 80a26e0:	bf84      	itt	hi
 80a26e2:	380a      	subhi	r0, #10
 80a26e4:	b2c0      	uxtbhi	r0, r0
    }
#endif  // USE_STIMMER
    *--p = r + '0';
 80a26e6:	f100 0030 	add.w	r0, r0, #48	; 0x30
      n++;
 80a26ea:	bf88      	it	hi
 80a26ec:	3201      	addhi	r2, #1
    *--p = r + '0';
 80a26ee:	f801 0d01 	strb.w	r0, [r1, #-1]!
  while (n >> 16) {
 80a26f2:	4610      	mov	r0, r2
 80a26f4:	e7e0      	b.n	80a26b8 <_Z6fmtDecmPc>
  }
  return fmtDec((uint16_t)n, p);
 80a26f6:	b280      	uxth	r0, r0
 80a26f8:	f7ff bfb6 	b.w	80a2668 <_Z6fmtDectPc>

080a26fc <_ZN9SdSpiCard10isTimedOutEtt>:
    spiStop();
  }
  return rtn;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isTimedOut(uint16_t startMS, uint16_t timeoutMS) {
 80a26fc:	b570      	push	{r4, r5, r6, lr}
 80a26fe:	460d      	mov	r5, r1
 80a2700:	4614      	mov	r4, r2
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a2702:	f001 fd1d 	bl	80a4140 <HAL_Timer_Get_Micro_Seconds>
#if WDT_YIELD_TIME_MICROS
  static uint32_t last;
  if ((micros() - last) > WDT_YIELD_TIME_MICROS) {
 80a2706:	4e0c      	ldr	r6, [pc, #48]	; (80a2738 <_ZN9SdSpiCard10isTimedOutEtt+0x3c>)
 80a2708:	6833      	ldr	r3, [r6, #0]
 80a270a:	1ac0      	subs	r0, r0, r3
 80a270c:	4b0b      	ldr	r3, [pc, #44]	; (80a273c <_ZN9SdSpiCard10isTimedOutEtt+0x40>)
 80a270e:	4298      	cmp	r0, r3
 80a2710:	d908      	bls.n	80a2724 <_ZN9SdSpiCard10isTimedOutEtt+0x28>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a2712:	f001 fd1d 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a2716:	4b0a      	ldr	r3, [pc, #40]	; (80a2740 <_ZN9SdSpiCard10isTimedOutEtt+0x44>)
 80a2718:	6018      	str	r0, [r3, #0]
        spark_cloud_flag_connect();
    }
    static void disconnect(const CloudDisconnectOptions& options = CloudDisconnectOptions());
    static void process(void) {
    		application_checkin();
    		spark_process();
 80a271a:	f001 fecf 	bl	80a44bc <spark_process>
 80a271e:	f001 fd0f 	bl	80a4140 <HAL_Timer_Get_Micro_Seconds>
    SysCall::yield();
    last = micros();
 80a2722:	6030      	str	r0, [r6, #0]
inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a2724:	f001 fd14 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
  }
#endif  // WDT_YIELD_TIME_MICROS
  return (curTimeMS() - startMS) > timeoutMS;
 80a2728:	b280      	uxth	r0, r0
 80a272a:	1b40      	subs	r0, r0, r5
}
 80a272c:	42a0      	cmp	r0, r4
 80a272e:	bfd4      	ite	le
 80a2730:	2000      	movle	r0, #0
 80a2732:	2001      	movgt	r0, #1
 80a2734:	bd70      	pop	{r4, r5, r6, pc}
 80a2736:	bf00      	nop
 80a2738:	2000161c 	.word	0x2000161c
 80a273c:	000186a0 	.word	0x000186a0
 80a2740:	20001af0 	.word	0x20001af0

080a2744 <_ZN9SdSpiCard8spiStartEv>:
fail:
  spiStop();
  return false;
}
//-----------------------------------------------------------------------------
void SdSpiCard::spiStart() {
 80a2744:	b538      	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
 80a2746:	7a05      	ldrb	r5, [r0, #8]
void SdSpiCard::spiStart() {
 80a2748:	4604      	mov	r4, r0
  if (!m_spiActive) {
 80a274a:	b94d      	cbnz	r5, 80a2760 <_ZN9SdSpiCard8spiStartEv+0x1c>
  bool writeData(uint8_t token, const uint8_t* src);

  //---------------------------------------------------------------------------
  // functions defined in SdSpiDriver.h
  void spiActivate() {
    m_spiDriver->activate();
 80a274c:	6840      	ldr	r0, [r0, #4]
 80a274e:	f000 fa6d 	bl	80a2c2c <_ZN14SdSpiAltDriver8activateEv>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriver->send(buf, n);
  }
  void spiSelect() {
    m_spiDriver->select();
 80a2752:	6863      	ldr	r3, [r4, #4]
     digitalWrite(m_csPin, LOW);
 80a2754:	4629      	mov	r1, r5
 80a2756:	7d18      	ldrb	r0, [r3, #20]
 80a2758:	f003 ffeb 	bl	80a6732 <digitalWrite>
    spiActivate();
    spiSelect();
    m_spiActive = true;
 80a275c:	2301      	movs	r3, #1
 80a275e:	7223      	strb	r3, [r4, #8]
  }
}
 80a2760:	bd38      	pop	{r3, r4, r5, pc}

080a2762 <_ZN9SdSpiCard7spiStopEv>:
//-----------------------------------------------------------------------------
void SdSpiCard::spiStop() {
 80a2762:	b510      	push	{r4, lr}
  if (m_spiActive) {
 80a2764:	7a03      	ldrb	r3, [r0, #8]
void SdSpiCard::spiStop() {
 80a2766:	4604      	mov	r4, r0
  if (m_spiActive) {
 80a2768:	b16b      	cbz	r3, 80a2786 <_ZN9SdSpiCard7spiStopEv+0x24>
  }
  void spiUnselect() {
    m_spiDriver->unselect();
 80a276a:	6843      	ldr	r3, [r0, #4]
    digitalWrite(m_csPin, HIGH);
 80a276c:	2101      	movs	r1, #1
 80a276e:	7d18      	ldrb	r0, [r3, #20]
 80a2770:	f003 ffdf 	bl	80a6732 <digitalWrite>
     m_spiDriver->send(data);
 80a2774:	21ff      	movs	r1, #255	; 0xff
 80a2776:	6860      	ldr	r0, [r4, #4]
 80a2778:	f000 fa8a 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
    m_spiDriver->deactivate();
 80a277c:	6860      	ldr	r0, [r4, #4]
 80a277e:	f000 fa69 	bl	80a2c54 <_ZN14SdSpiAltDriver10deactivateEv>
    spiUnselect();
    spiSend(0XFF);
    spiDeactivate();
    m_spiActive = false;
 80a2782:	2300      	movs	r3, #0
 80a2784:	7223      	strb	r3, [r4, #8]
  }
}
 80a2786:	bd10      	pop	{r4, pc}

080a2788 <_ZN9SdSpiCard8readDataEPhj>:
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
 80a2788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a278a:	4604      	mov	r4, r0
 80a278c:	460d      	mov	r5, r1
 80a278e:	4616      	mov	r6, r2
 80a2790:	f001 fcde 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline uint16_t curTimeMS() {
  return millis();
 80a2794:	b287      	uxth	r7, r0
    return m_spiDriver->receive();
 80a2796:	6860      	ldr	r0, [r4, #4]
 80a2798:	f000 fa5f 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
  while ((m_status = spiReceive()) == 0XFF) {
 80a279c:	28ff      	cmp	r0, #255	; 0xff
 80a279e:	7260      	strb	r0, [r4, #9]
 80a27a0:	d10e      	bne.n	80a27c0 <_ZN9SdSpiCard8readDataEPhj+0x38>
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
 80a27a2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a27a6:	4639      	mov	r1, r7
 80a27a8:	4620      	mov	r0, r4
 80a27aa:	f7ff ffa7 	bl	80a26fc <_ZN9SdSpiCard10isTimedOutEtt>
 80a27ae:	2800      	cmp	r0, #0
 80a27b0:	d0f1      	beq.n	80a2796 <_ZN9SdSpiCard8readDataEPhj+0xe>
    m_errorCode = code;
 80a27b2:	2355      	movs	r3, #85	; 0x55
  spiStop();
 80a27b4:	4620      	mov	r0, r4
 80a27b6:	7023      	strb	r3, [r4, #0]
 80a27b8:	f7ff ffd3 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a27bc:	2000      	movs	r0, #0
}
 80a27be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (m_status != DATA_START_BLOCK) {
 80a27c0:	28fe      	cmp	r0, #254	; 0xfe
 80a27c2:	d001      	beq.n	80a27c8 <_ZN9SdSpiCard8readDataEPhj+0x40>
 80a27c4:	2350      	movs	r3, #80	; 0x50
 80a27c6:	e7f5      	b.n	80a27b4 <_ZN9SdSpiCard8readDataEPhj+0x2c>
    return  m_spiDriver->receive(buf, n);
 80a27c8:	4632      	mov	r2, r6
 80a27ca:	4629      	mov	r1, r5
 80a27cc:	6860      	ldr	r0, [r4, #4]
 80a27ce:	f000 fa49 	bl	80a2c64 <_ZN14SdSpiAltDriver7receiveEPhj>
  if ((m_status = spiReceive(dst, count))) {
 80a27d2:	7260      	strb	r0, [r4, #9]
 80a27d4:	b108      	cbz	r0, 80a27da <_ZN9SdSpiCard8readDataEPhj+0x52>
    m_errorCode = code;
 80a27d6:	2360      	movs	r3, #96	; 0x60
 80a27d8:	e7ec      	b.n	80a27b4 <_ZN9SdSpiCard8readDataEPhj+0x2c>
    return m_spiDriver->receive();
 80a27da:	6860      	ldr	r0, [r4, #4]
 80a27dc:	f000 fa3d 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
 80a27e0:	6860      	ldr	r0, [r4, #4]
 80a27e2:	f000 fa3a 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
 80a27e6:	2001      	movs	r0, #1
 80a27e8:	e7e9      	b.n	80a27be <_ZN9SdSpiCard8readDataEPhj+0x36>

080a27ea <_ZN9SdSpiCard11waitNotBusyEt>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(uint16_t timeoutMS) {
 80a27ea:	b570      	push	{r4, r5, r6, lr}
 80a27ec:	4604      	mov	r4, r0
 80a27ee:	460e      	mov	r6, r1
 80a27f0:	f001 fcae 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
 80a27f4:	b285      	uxth	r5, r0
  uint16_t t0 = curTimeMS();
#if WDT_YIELD_TIME_MICROS
  // Call isTimedOut first to insure yield is called.
  while (!isTimedOut(t0, timeoutMS)) {
 80a27f6:	4632      	mov	r2, r6
 80a27f8:	4629      	mov	r1, r5
 80a27fa:	4620      	mov	r0, r4
 80a27fc:	f7ff ff7e 	bl	80a26fc <_ZN9SdSpiCard10isTimedOutEtt>
 80a2800:	b930      	cbnz	r0, 80a2810 <_ZN9SdSpiCard11waitNotBusyEt+0x26>
 80a2802:	6860      	ldr	r0, [r4, #4]
 80a2804:	f000 fa29 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
    if (spiReceive() == 0XFF) {
 80a2808:	28ff      	cmp	r0, #255	; 0xff
 80a280a:	d1f4      	bne.n	80a27f6 <_ZN9SdSpiCard11waitNotBusyEt+0xc>
      return true;
 80a280c:	2001      	movs	r0, #1
      return false;
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MICROS
}
 80a280e:	bd70      	pop	{r4, r5, r6, pc}
  return false;
 80a2810:	2000      	movs	r0, #0
 80a2812:	e7fc      	b.n	80a280e <_ZN9SdSpiCard11waitNotBusyEt+0x24>

080a2814 <_ZN9SdSpiCard11cardCommandEhm>:
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
 80a2814:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (!m_spiActive) {
 80a2816:	7a03      	ldrb	r3, [r0, #8]
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
 80a2818:	4604      	mov	r4, r0
 80a281a:	460d      	mov	r5, r1
 80a281c:	9201      	str	r2, [sp, #4]
  if (!m_spiActive) {
 80a281e:	b90b      	cbnz	r3, 80a2824 <_ZN9SdSpiCard11cardCommandEhm+0x10>
    spiStart();
 80a2820:	f7ff ff90 	bl	80a2744 <_ZN9SdSpiCard8spiStartEv>
  if (cmd != CMD0) {
 80a2824:	b125      	cbz	r5, 80a2830 <_ZN9SdSpiCard11cardCommandEhm+0x1c>
    waitNotBusy(SD_CMD_TIMEOUT);
 80a2826:	f44f 7196 	mov.w	r1, #300	; 0x12c
 80a282a:	4620      	mov	r0, r4
 80a282c:	f7ff ffdd 	bl	80a27ea <_ZN9SdSpiCard11waitNotBusyEt>
     m_spiDriver->send(data);
 80a2830:	6860      	ldr	r0, [r4, #4]
 80a2832:	f045 0140 	orr.w	r1, r5, #64	; 0x40
 80a2836:	f000 fa2b 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
 80a283a:	2603      	movs	r6, #3
    spiSend(pa[i]);
 80a283c:	af01      	add	r7, sp, #4
 80a283e:	5db9      	ldrb	r1, [r7, r6]
 80a2840:	6860      	ldr	r0, [r4, #4]
 80a2842:	f000 fa25 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
  for (int8_t i = 3; i >= 0; i--) {
 80a2846:	3e01      	subs	r6, #1
 80a2848:	d2f9      	bcs.n	80a283e <_ZN9SdSpiCard11cardCommandEhm+0x2a>
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
 80a284a:	2d00      	cmp	r5, #0
 80a284c:	bf0c      	ite	eq
 80a284e:	2195      	moveq	r1, #149	; 0x95
 80a2850:	2187      	movne	r1, #135	; 0x87
 80a2852:	6860      	ldr	r0, [r4, #4]
 80a2854:	f000 fa1c 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
    return m_spiDriver->receive();
 80a2858:	6860      	ldr	r0, [r4, #4]
 80a285a:	f000 f9fe 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
 80a285e:	250b      	movs	r5, #11
 80a2860:	6860      	ldr	r0, [r4, #4]
 80a2862:	f000 f9fa 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
 80a2866:	0603      	lsls	r3, r0, #24
 80a2868:	7260      	strb	r0, [r4, #9]
 80a286a:	d503      	bpl.n	80a2874 <_ZN9SdSpiCard11cardCommandEhm+0x60>
 80a286c:	3d01      	subs	r5, #1
 80a286e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 80a2872:	d1f5      	bne.n	80a2860 <_ZN9SdSpiCard11cardCommandEhm+0x4c>
}
 80a2874:	b003      	add	sp, #12
 80a2876:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a2878 <_ZN9SdSpiCard8cardAcmdEhm>:
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
 80a2878:	b570      	push	{r4, r5, r6, lr}
 80a287a:	4604      	mov	r4, r0
 80a287c:	460d      	mov	r5, r1
 80a287e:	4616      	mov	r6, r2
    cardCommand(CMD55, 0);
 80a2880:	2137      	movs	r1, #55	; 0x37
 80a2882:	2200      	movs	r2, #0
 80a2884:	f7ff ffc6 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
    return cardCommand(cmd, arg);
 80a2888:	4632      	mov	r2, r6
 80a288a:	4629      	mov	r1, r5
 80a288c:	4620      	mov	r0, r4
  }
 80a288e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return cardCommand(cmd, arg);
 80a2892:	f7ff bfbf 	b.w	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
	...

080a2898 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE>:
bool SdSpiCard::begin(SdSpiDriver* spi, uint8_t csPin, SPISettings settings) {
 80a2898:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_spiActive = false;
 80a289c:	2500      	movs	r5, #0
  m_spiDriver = spi;
 80a289e:	6041      	str	r1, [r0, #4]
  m_spiActive = false;
 80a28a0:	7205      	strb	r5, [r0, #8]
  m_errorCode = SD_CARD_ERROR_NONE;
 80a28a2:	7005      	strb	r5, [r0, #0]
  m_type = 0;
 80a28a4:	7285      	strb	r5, [r0, #10]
bool SdSpiCard::begin(SdSpiDriver* spi, uint8_t csPin, SPISettings settings) {
 80a28a6:	4604      	mov	r4, r0
 80a28a8:	4690      	mov	r8, r2
 80a28aa:	461e      	mov	r6, r3
 80a28ac:	f001 fc50 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
  m_spiDriver->begin(csPin);
 80a28b0:	4641      	mov	r1, r8
 80a28b2:	4607      	mov	r7, r0
 80a28b4:	6860      	ldr	r0, [r4, #4]
 80a28b6:	f000 f9bd 	bl	80a2c34 <_ZN14SdSpiAltDriver5beginEh>
  m_spiDriver->setSpiSettings(SD_SCK_HZ(250000));
 80a28ba:	6863      	ldr	r3, [r4, #4]
 80a28bc:	4a4a      	ldr	r2, [pc, #296]	; (80a29e8 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x150>)
 80a28be:	721d      	strb	r5, [r3, #8]
 80a28c0:	2501      	movs	r5, #1
 80a28c2:	60da      	str	r2, [r3, #12]
 80a28c4:	821d      	strh	r5, [r3, #16]
  spiStart();
 80a28c6:	4620      	mov	r0, r4
 80a28c8:	f7ff ff3c 	bl	80a2744 <_ZN9SdSpiCard8spiStartEv>
    m_spiDriver->unselect();
 80a28cc:	6863      	ldr	r3, [r4, #4]
 80a28ce:	4629      	mov	r1, r5
 80a28d0:	7d18      	ldrb	r0, [r3, #20]
 80a28d2:	f003 ff2e 	bl	80a6732 <digitalWrite>
 80a28d6:	250a      	movs	r5, #10
     m_spiDriver->send(data);
 80a28d8:	21ff      	movs	r1, #255	; 0xff
 80a28da:	6860      	ldr	r0, [r4, #4]
 80a28dc:	3d01      	subs	r5, #1
 80a28de:	f000 f9d7 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
  for (uint8_t i = 0; i < 10; i++) {
 80a28e2:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 80a28e6:	d1f7      	bne.n	80a28d8 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x40>
    m_spiDriver->select();
 80a28e8:	6863      	ldr	r3, [r4, #4]
     digitalWrite(m_csPin, LOW);
 80a28ea:	4629      	mov	r1, r5
 80a28ec:	7d18      	ldrb	r0, [r3, #20]
 80a28ee:	f003 ff20 	bl	80a6732 <digitalWrite>
  }
 80a28f2:	250a      	movs	r5, #10
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
 80a28f4:	2200      	movs	r2, #0
 80a28f6:	4620      	mov	r0, r4
 80a28f8:	4611      	mov	r1, r2
 80a28fa:	f7ff ff8b 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a28fe:	2801      	cmp	r0, #1
 80a2900:	4680      	mov	r8, r0
 80a2902:	d018      	beq.n	80a2936 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x9e>
    if (i == SD_CMD0_RETRY) {
 80a2904:	3d01      	subs	r5, #1
 80a2906:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 80a290a:	d107      	bne.n	80a291c <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x84>
    m_errorCode = code;
 80a290c:	2320      	movs	r3, #32
  spiStop();
 80a290e:	4620      	mov	r0, r4
 80a2910:	7023      	strb	r3, [r4, #0]
 80a2912:	f7ff ff26 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2916:	2000      	movs	r0, #0
}
 80a2918:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     m_spiDriver->send(data);
 80a291c:	21fd      	movs	r1, #253	; 0xfd
 80a291e:	6860      	ldr	r0, [r4, #4]
 80a2920:	f000 f9b6 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
 80a2924:	f44f 7802 	mov.w	r8, #520	; 0x208
    return m_spiDriver->receive();
 80a2928:	6860      	ldr	r0, [r4, #4]
 80a292a:	f000 f996 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
    for (int i = 0; i < 520; i++) {
 80a292e:	f1b8 0801 	subs.w	r8, r8, #1
 80a2932:	d1f9      	bne.n	80a2928 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x90>
 80a2934:	e7de      	b.n	80a28f4 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x5c>
  if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
 80a2936:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 80a293a:	2108      	movs	r1, #8
 80a293c:	4620      	mov	r0, r4
 80a293e:	f7ff ff69 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a2942:	2805      	cmp	r0, #5
 80a2944:	d114      	bne.n	80a2970 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xd8>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
 80a2946:	2500      	movs	r5, #0
    m_type = value;
 80a2948:	f884 800a 	strb.w	r8, [r4, #10]
 80a294c:	b2bf      	uxth	r7, r7
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
 80a294e:	462a      	mov	r2, r5
 80a2950:	2129      	movs	r1, #41	; 0x29
 80a2952:	4620      	mov	r0, r4
 80a2954:	f7ff ff90 	bl	80a2878 <_ZN9SdSpiCard8cardAcmdEhm>
 80a2958:	4602      	mov	r2, r0
 80a295a:	b1d8      	cbz	r0, 80a2994 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xfc>
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
 80a295c:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 80a2960:	4639      	mov	r1, r7
 80a2962:	4620      	mov	r0, r4
 80a2964:	f7ff feca 	bl	80a26fc <_ZN9SdSpiCard10isTimedOutEtt>
 80a2968:	2800      	cmp	r0, #0
 80a296a:	d0f0      	beq.n	80a294e <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xb6>
    m_errorCode = code;
 80a296c:	2343      	movs	r3, #67	; 0x43
 80a296e:	e7ce      	b.n	80a290e <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x76>
 80a2970:	2504      	movs	r5, #4
    return m_spiDriver->receive();
 80a2972:	6860      	ldr	r0, [r4, #4]
 80a2974:	f000 f971 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
 80a2978:	3d01      	subs	r5, #1
    for (uint8_t i = 0; i < 4; i++) {
 80a297a:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
 80a297e:	7260      	strb	r0, [r4, #9]
    for (uint8_t i = 0; i < 4; i++) {
 80a2980:	d1f7      	bne.n	80a2972 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xda>
    if (m_status == 0XAA) {
 80a2982:	28aa      	cmp	r0, #170	; 0xaa
 80a2984:	d104      	bne.n	80a2990 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xf8>
    m_type = value;
 80a2986:	2302      	movs	r3, #2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
 80a2988:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 80a298c:	72a3      	strb	r3, [r4, #10]
    return m_type;
 80a298e:	e7dd      	b.n	80a294c <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xb4>
    m_errorCode = code;
 80a2990:	2325      	movs	r3, #37	; 0x25
 80a2992:	e7bc      	b.n	80a290e <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x76>
  if (type() == SD_CARD_TYPE_SD2) {
 80a2994:	7aa3      	ldrb	r3, [r4, #10]
 80a2996:	2b02      	cmp	r3, #2
 80a2998:	d119      	bne.n	80a29ce <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x136>
    if (cardCommand(CMD58, 0)) {
 80a299a:	213a      	movs	r1, #58	; 0x3a
 80a299c:	4620      	mov	r0, r4
 80a299e:	f7ff ff39 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a29a2:	b108      	cbz	r0, 80a29a8 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x110>
 80a29a4:	2337      	movs	r3, #55	; 0x37
 80a29a6:	e7b2      	b.n	80a290e <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x76>
    return m_spiDriver->receive();
 80a29a8:	6860      	ldr	r0, [r4, #4]
 80a29aa:	f000 f956 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
    if ((spiReceive() & 0XC0) == 0XC0) {
 80a29ae:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
 80a29b2:	28c0      	cmp	r0, #192	; 0xc0
    m_type = value;
 80a29b4:	bf08      	it	eq
 80a29b6:	2303      	moveq	r3, #3
    return m_spiDriver->receive();
 80a29b8:	6860      	ldr	r0, [r4, #4]
    m_type = value;
 80a29ba:	bf08      	it	eq
 80a29bc:	72a3      	strbeq	r3, [r4, #10]
    return m_spiDriver->receive();
 80a29be:	f000 f94c 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
 80a29c2:	6860      	ldr	r0, [r4, #4]
 80a29c4:	f000 f949 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
 80a29c8:	6860      	ldr	r0, [r4, #4]
 80a29ca:	f000 f946 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
  spiStop();
 80a29ce:	4620      	mov	r0, r4
 80a29d0:	f7ff fec7 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
 80a29d4:	7930      	ldrb	r0, [r6, #4]
  m_spiDriver->setSpiSettings(settings);
 80a29d6:	6863      	ldr	r3, [r4, #4]
 80a29d8:	68b1      	ldr	r1, [r6, #8]
 80a29da:	89b2      	ldrh	r2, [r6, #12]
 80a29dc:	7218      	strb	r0, [r3, #8]
 80a29de:	60d9      	str	r1, [r3, #12]
  return true;
 80a29e0:	2001      	movs	r0, #1
 80a29e2:	821a      	strh	r2, [r3, #16]
 80a29e4:	e798      	b.n	80a2918 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x80>
 80a29e6:	bf00      	nop
 80a29e8:	0003d090 	.word	0x0003d090

080a29ec <_ZN9SdSpiCard9readBlockEmPh>:
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
 80a29ec:	b538      	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
 80a29ee:	7a83      	ldrb	r3, [r0, #10]
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
 80a29f0:	4615      	mov	r5, r2
  if (type() != SD_CARD_TYPE_SDHC) {
 80a29f2:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a29f4:	bf18      	it	ne
 80a29f6:	0249      	lslne	r1, r1, #9
  if (cardCommand(CMD17, blockNumber)) {
 80a29f8:	460a      	mov	r2, r1
 80a29fa:	2111      	movs	r1, #17
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
 80a29fc:	4604      	mov	r4, r0
  if (cardCommand(CMD17, blockNumber)) {
 80a29fe:	f7ff ff09 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a2a02:	b130      	cbz	r0, 80a2a12 <_ZN9SdSpiCard9readBlockEmPh+0x26>
    m_errorCode = code;
 80a2a04:	2330      	movs	r3, #48	; 0x30
 80a2a06:	7023      	strb	r3, [r4, #0]
  spiStop();
 80a2a08:	4620      	mov	r0, r4
 80a2a0a:	f7ff feaa 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2a0e:	2500      	movs	r5, #0
 80a2a10:	e00b      	b.n	80a2a2a <_ZN9SdSpiCard9readBlockEmPh+0x3e>
  if (!readData(dst, 512)) {
 80a2a12:	4629      	mov	r1, r5
 80a2a14:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a2a18:	4620      	mov	r0, r4
 80a2a1a:	f7ff feb5 	bl	80a2788 <_ZN9SdSpiCard8readDataEPhj>
 80a2a1e:	4605      	mov	r5, r0
 80a2a20:	2800      	cmp	r0, #0
 80a2a22:	d0f1      	beq.n	80a2a08 <_ZN9SdSpiCard9readBlockEmPh+0x1c>
  spiStop();
 80a2a24:	4620      	mov	r0, r4
 80a2a26:	f7ff fe9c 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
}
 80a2a2a:	4628      	mov	r0, r5
 80a2a2c:	bd38      	pop	{r3, r4, r5, pc}

080a2a2e <_ZN9SdSpiCard9readStartEm>:
bool SdSpiCard::readStart(uint32_t blockNumber) {
 80a2a2e:	b510      	push	{r4, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2a30:	7a83      	ldrb	r3, [r0, #10]
bool SdSpiCard::readStart(uint32_t blockNumber) {
 80a2a32:	460a      	mov	r2, r1
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2a34:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a2a36:	bf18      	it	ne
 80a2a38:	024a      	lslne	r2, r1, #9
  if (cardCommand(CMD18, blockNumber)) {
 80a2a3a:	2112      	movs	r1, #18
bool SdSpiCard::readStart(uint32_t blockNumber) {
 80a2a3c:	4604      	mov	r4, r0
  if (cardCommand(CMD18, blockNumber)) {
 80a2a3e:	f7ff fee9 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a2a42:	b130      	cbz	r0, 80a2a52 <_ZN9SdSpiCard9readStartEm+0x24>
 80a2a44:	2331      	movs	r3, #49	; 0x31
  spiStop();
 80a2a46:	4620      	mov	r0, r4
 80a2a48:	7023      	strb	r3, [r4, #0]
 80a2a4a:	f7ff fe8a 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2a4e:	2000      	movs	r0, #0
}
 80a2a50:	bd10      	pop	{r4, pc}
  return true;
 80a2a52:	2001      	movs	r0, #1
 80a2a54:	e7fc      	b.n	80a2a50 <_ZN9SdSpiCard9readStartEm+0x22>

080a2a56 <_ZN9SdSpiCard8readStopEv>:
bool SdSpiCard::readStop() {
 80a2a56:	b510      	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
 80a2a58:	2200      	movs	r2, #0
 80a2a5a:	210c      	movs	r1, #12
bool SdSpiCard::readStop() {
 80a2a5c:	4604      	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
 80a2a5e:	f7ff fed9 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a2a62:	b130      	cbz	r0, 80a2a72 <_ZN9SdSpiCard8readStopEv+0x1c>
 80a2a64:	2328      	movs	r3, #40	; 0x28
  spiStop();
 80a2a66:	4620      	mov	r0, r4
 80a2a68:	7023      	strb	r3, [r4, #0]
 80a2a6a:	f7ff fe7a 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2a6e:	2000      	movs	r0, #0
}
 80a2a70:	bd10      	pop	{r4, pc}
  spiStop();
 80a2a72:	4620      	mov	r0, r4
 80a2a74:	f7ff fe75 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return true;
 80a2a78:	2001      	movs	r0, #1
 80a2a7a:	e7f9      	b.n	80a2a70 <_ZN9SdSpiCard8readStopEv+0x1a>

080a2a7c <_ZN9SdSpiCard10readBlocksEmPhj>:
bool SdSpiCard::readBlocks(uint32_t block, uint8_t* dst, size_t count) {
 80a2a7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2a7e:	4604      	mov	r4, r0
 80a2a80:	4616      	mov	r6, r2
 80a2a82:	461f      	mov	r7, r3
  if (!readStart(block)) {
 80a2a84:	f7ff ffd3 	bl	80a2a2e <_ZN9SdSpiCard9readStartEm>
 80a2a88:	b168      	cbz	r0, 80a2aa6 <_ZN9SdSpiCard10readBlocksEmPhj+0x2a>
 80a2a8a:	2500      	movs	r5, #0
  for (uint16_t b = 0; b < count; b++, dst += 512) {
 80a2a8c:	b2ab      	uxth	r3, r5
 80a2a8e:	429f      	cmp	r7, r3
 80a2a90:	eb06 2145 	add.w	r1, r6, r5, lsl #9
 80a2a94:	d909      	bls.n	80a2aaa <_ZN9SdSpiCard10readBlocksEmPhj+0x2e>
    if (!readData(dst, 512)) {
 80a2a96:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a2a9a:	4620      	mov	r0, r4
 80a2a9c:	f7ff fe74 	bl	80a2788 <_ZN9SdSpiCard8readDataEPhj>
 80a2aa0:	3501      	adds	r5, #1
 80a2aa2:	2800      	cmp	r0, #0
 80a2aa4:	d1f2      	bne.n	80a2a8c <_ZN9SdSpiCard10readBlocksEmPhj+0x10>
}
 80a2aa6:	2000      	movs	r0, #0
 80a2aa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return readStop();
 80a2aaa:	4620      	mov	r0, r4
}
 80a2aac:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return readStop();
 80a2ab0:	f7ff bfd1 	b.w	80a2a56 <_ZN9SdSpiCard8readStopEv>

080a2ab4 <_ZN9SdSpiCard9writeDataEhPKh>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
 80a2ab4:	b538      	push	{r3, r4, r5, lr}
 80a2ab6:	4604      	mov	r4, r0
 80a2ab8:	4615      	mov	r5, r2
     m_spiDriver->send(data);
 80a2aba:	6840      	ldr	r0, [r0, #4]
 80a2abc:	f000 f8e8 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
    m_spiDriver->send(buf, n);
 80a2ac0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a2ac4:	4629      	mov	r1, r5
 80a2ac6:	6860      	ldr	r0, [r4, #4]
 80a2ac8:	f000 f8e6 	bl	80a2c98 <_ZN14SdSpiAltDriver4sendEPKhj>
     m_spiDriver->send(data);
 80a2acc:	21ff      	movs	r1, #255	; 0xff
 80a2ace:	6860      	ldr	r0, [r4, #4]
 80a2ad0:	f000 f8de 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
 80a2ad4:	21ff      	movs	r1, #255	; 0xff
 80a2ad6:	6860      	ldr	r0, [r4, #4]
 80a2ad8:	f000 f8da 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
    return m_spiDriver->receive();
 80a2adc:	6860      	ldr	r0, [r4, #4]
 80a2ade:	f000 f8bc 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
 80a2ae2:	7260      	strb	r0, [r4, #9]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
 80a2ae4:	f000 001f 	and.w	r0, r0, #31
 80a2ae8:	2805      	cmp	r0, #5
 80a2aea:	d006      	beq.n	80a2afa <_ZN9SdSpiCard9writeDataEhPKh+0x46>
    m_errorCode = code;
 80a2aec:	2357      	movs	r3, #87	; 0x57
    goto fail;
  }
  return true;

fail:
  spiStop();
 80a2aee:	4620      	mov	r0, r4
 80a2af0:	7023      	strb	r3, [r4, #0]
 80a2af2:	f7ff fe36 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2af6:	2000      	movs	r0, #0
}
 80a2af8:	bd38      	pop	{r3, r4, r5, pc}
  return true;
 80a2afa:	2001      	movs	r0, #1
 80a2afc:	e7fc      	b.n	80a2af8 <_ZN9SdSpiCard9writeDataEhPKh+0x44>

080a2afe <_ZN9SdSpiCard10writeBlockEmPKh>:
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
 80a2afe:	b570      	push	{r4, r5, r6, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2b00:	7a83      	ldrb	r3, [r0, #10]
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
 80a2b02:	4615      	mov	r5, r2
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2b04:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a2b06:	bf18      	it	ne
 80a2b08:	0249      	lslne	r1, r1, #9
  if (cardCommand(CMD24, blockNumber)) {
 80a2b0a:	460a      	mov	r2, r1
 80a2b0c:	2118      	movs	r1, #24
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
 80a2b0e:	4604      	mov	r4, r0
  if (cardCommand(CMD24, blockNumber)) {
 80a2b10:	f7ff fe80 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a2b14:	4606      	mov	r6, r0
 80a2b16:	b130      	cbz	r0, 80a2b26 <_ZN9SdSpiCard10writeBlockEmPKh+0x28>
 80a2b18:	2332      	movs	r3, #50	; 0x32
 80a2b1a:	7023      	strb	r3, [r4, #0]
  spiStop();
 80a2b1c:	4620      	mov	r0, r4
 80a2b1e:	f7ff fe20 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2b22:	2500      	movs	r5, #0
 80a2b24:	e01f      	b.n	80a2b66 <_ZN9SdSpiCard10writeBlockEmPKh+0x68>
  if (!writeData(DATA_START_BLOCK, src)) {
 80a2b26:	462a      	mov	r2, r5
 80a2b28:	21fe      	movs	r1, #254	; 0xfe
 80a2b2a:	4620      	mov	r0, r4
 80a2b2c:	f7ff ffc2 	bl	80a2ab4 <_ZN9SdSpiCard9writeDataEhPKh>
 80a2b30:	2800      	cmp	r0, #0
 80a2b32:	d0f3      	beq.n	80a2b1c <_ZN9SdSpiCard10writeBlockEmPKh+0x1e>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2b34:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80a2b38:	4620      	mov	r0, r4
 80a2b3a:	f7ff fe56 	bl	80a27ea <_ZN9SdSpiCard11waitNotBusyEt>
 80a2b3e:	4605      	mov	r5, r0
 80a2b40:	b908      	cbnz	r0, 80a2b46 <_ZN9SdSpiCard10writeBlockEmPKh+0x48>
 80a2b42:	235a      	movs	r3, #90	; 0x5a
 80a2b44:	e7e9      	b.n	80a2b1a <_ZN9SdSpiCard10writeBlockEmPKh+0x1c>
  if (cardCommand(CMD13, 0) || spiReceive()) {
 80a2b46:	4632      	mov	r2, r6
 80a2b48:	210d      	movs	r1, #13
 80a2b4a:	4620      	mov	r0, r4
 80a2b4c:	f7ff fe62 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a2b50:	b108      	cbz	r0, 80a2b56 <_ZN9SdSpiCard10writeBlockEmPKh+0x58>
 80a2b52:	2329      	movs	r3, #41	; 0x29
 80a2b54:	e7e1      	b.n	80a2b1a <_ZN9SdSpiCard10writeBlockEmPKh+0x1c>
    return m_spiDriver->receive();
 80a2b56:	6860      	ldr	r0, [r4, #4]
 80a2b58:	f000 f87f 	bl	80a2c5a <_ZN14SdSpiAltDriver7receiveEv>
 80a2b5c:	2800      	cmp	r0, #0
 80a2b5e:	d1f8      	bne.n	80a2b52 <_ZN9SdSpiCard10writeBlockEmPKh+0x54>
  spiStop();
 80a2b60:	4620      	mov	r0, r4
 80a2b62:	f7ff fdfe 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
}
 80a2b66:	4628      	mov	r0, r5
 80a2b68:	bd70      	pop	{r4, r5, r6, pc}

080a2b6a <_ZN9SdSpiCard9writeDataEPKh>:
bool SdSpiCard::writeData(const uint8_t* src) {
 80a2b6a:	b538      	push	{r3, r4, r5, lr}
 80a2b6c:	460d      	mov	r5, r1
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2b6e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
bool SdSpiCard::writeData(const uint8_t* src) {
 80a2b72:	4604      	mov	r4, r0
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2b74:	f7ff fe39 	bl	80a27ea <_ZN9SdSpiCard11waitNotBusyEt>
 80a2b78:	b930      	cbnz	r0, 80a2b88 <_ZN9SdSpiCard9writeDataEPKh+0x1e>
    m_errorCode = code;
 80a2b7a:	235b      	movs	r3, #91	; 0x5b
 80a2b7c:	7023      	strb	r3, [r4, #0]
  spiStop();
 80a2b7e:	4620      	mov	r0, r4
 80a2b80:	f7ff fdef 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2b84:	2000      	movs	r0, #0
 80a2b86:	e006      	b.n	80a2b96 <_ZN9SdSpiCard9writeDataEPKh+0x2c>
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
 80a2b88:	462a      	mov	r2, r5
 80a2b8a:	21fc      	movs	r1, #252	; 0xfc
 80a2b8c:	4620      	mov	r0, r4
 80a2b8e:	f7ff ff91 	bl	80a2ab4 <_ZN9SdSpiCard9writeDataEhPKh>
 80a2b92:	2800      	cmp	r0, #0
 80a2b94:	d0f3      	beq.n	80a2b7e <_ZN9SdSpiCard9writeDataEPKh+0x14>
}
 80a2b96:	bd38      	pop	{r3, r4, r5, pc}

080a2b98 <_ZN9SdSpiCard10writeStartEm>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t blockNumber) {
 80a2b98:	b510      	push	{r4, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2b9a:	7a83      	ldrb	r3, [r0, #10]
bool SdSpiCard::writeStart(uint32_t blockNumber) {
 80a2b9c:	460a      	mov	r2, r1
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2b9e:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a2ba0:	bf18      	it	ne
 80a2ba2:	024a      	lslne	r2, r1, #9
  }
  if (cardCommand(CMD25, blockNumber)) {
 80a2ba4:	2119      	movs	r1, #25
bool SdSpiCard::writeStart(uint32_t blockNumber) {
 80a2ba6:	4604      	mov	r4, r0
  if (cardCommand(CMD25, blockNumber)) {
 80a2ba8:	f7ff fe34 	bl	80a2814 <_ZN9SdSpiCard11cardCommandEhm>
 80a2bac:	b130      	cbz	r0, 80a2bbc <_ZN9SdSpiCard10writeStartEm+0x24>
 80a2bae:	2333      	movs	r3, #51	; 0x33
    goto fail;
  }
  return true;

fail:
  spiStop();
 80a2bb0:	4620      	mov	r0, r4
 80a2bb2:	7023      	strb	r3, [r4, #0]
 80a2bb4:	f7ff fdd5 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2bb8:	2000      	movs	r0, #0
}
 80a2bba:	bd10      	pop	{r4, pc}
  return true;
 80a2bbc:	2001      	movs	r0, #1
 80a2bbe:	e7fc      	b.n	80a2bba <_ZN9SdSpiCard10writeStartEm+0x22>

080a2bc0 <_ZN9SdSpiCard9writeStopEv>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
 80a2bc0:	b538      	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2bc2:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
bool SdSpiCard::writeStop() {
 80a2bc6:	4604      	mov	r4, r0
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2bc8:	f7ff fe0f 	bl	80a27ea <_ZN9SdSpiCard11waitNotBusyEt>
 80a2bcc:	4605      	mov	r5, r0
 80a2bce:	b930      	cbnz	r0, 80a2bde <_ZN9SdSpiCard9writeStopEv+0x1e>
 80a2bd0:	2356      	movs	r3, #86	; 0x56
 80a2bd2:	7023      	strb	r3, [r4, #0]
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
  spiStop();
 80a2bd4:	4620      	mov	r0, r4
 80a2bd6:	f7ff fdc4 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>

fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
 80a2bda:	4628      	mov	r0, r5
 80a2bdc:	bd38      	pop	{r3, r4, r5, pc}
     m_spiDriver->send(data);
 80a2bde:	21fd      	movs	r1, #253	; 0xfd
 80a2be0:	6860      	ldr	r0, [r4, #4]
 80a2be2:	f000 f855 	bl	80a2c90 <_ZN14SdSpiAltDriver4sendEh>
 80a2be6:	e7f5      	b.n	80a2bd4 <_ZN9SdSpiCard9writeStopEv+0x14>

080a2be8 <_ZN9SdSpiCard11writeBlocksEmPKhj>:
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
 80a2be8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2bea:	4604      	mov	r4, r0
 80a2bec:	4616      	mov	r6, r2
 80a2bee:	461f      	mov	r7, r3
  if (!writeStart(block)) {
 80a2bf0:	f7ff ffd2 	bl	80a2b98 <_ZN9SdSpiCard10writeStartEm>
 80a2bf4:	b170      	cbz	r0, 80a2c14 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x2c>
  for (size_t b = 0; b < count; b++, src += 512) {
 80a2bf6:	2500      	movs	r5, #0
 80a2bf8:	42bd      	cmp	r5, r7
  return writeStop();
 80a2bfa:	4620      	mov	r0, r4
 80a2bfc:	eb06 2145 	add.w	r1, r6, r5, lsl #9
  for (size_t b = 0; b < count; b++, src += 512) {
 80a2c00:	d004      	beq.n	80a2c0c <_ZN9SdSpiCard11writeBlocksEmPKhj+0x24>
    if (!writeData(src)) {
 80a2c02:	f7ff ffb2 	bl	80a2b6a <_ZN9SdSpiCard9writeDataEPKh>
 80a2c06:	b128      	cbz	r0, 80a2c14 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x2c>
  for (size_t b = 0; b < count; b++, src += 512) {
 80a2c08:	3501      	adds	r5, #1
 80a2c0a:	e7f5      	b.n	80a2bf8 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x10>
}
 80a2c0c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return writeStop();
 80a2c10:	f7ff bfd6 	b.w	80a2bc0 <_ZN9SdSpiCard9writeStopEv>
  spiStop();
 80a2c14:	4620      	mov	r0, r4
 80a2c16:	f7ff fda4 	bl	80a2762 <_ZN9SdSpiCard7spiStopEv>
}
 80a2c1a:	2000      	movs	r0, #0
 80a2c1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a2c20 <_ZL36SD_SPI_DMA_TransferComplete_Callbackv>:
#if defined(PLATFORM_ID)
#include "SdSpiDriver.h"
static volatile bool SPI_DMA_TransferCompleted = false;
//-----------------------------------------------------------------------------
static void SD_SPI_DMA_TransferComplete_Callback(void) {
    SPI_DMA_TransferCompleted = true;
 80a2c20:	2201      	movs	r2, #1
 80a2c22:	4b01      	ldr	r3, [pc, #4]	; (80a2c28 <_ZL36SD_SPI_DMA_TransferComplete_Callbackv+0x8>)
 80a2c24:	701a      	strb	r2, [r3, #0]
}
 80a2c26:	4770      	bx	lr
 80a2c28:	20001620 	.word	0x20001620

080a2c2c <_ZN14SdSpiAltDriver8activateEv>:
/** Set SPI options for access to SD/SDHC cards.
 *
 * \param[in] divisor SCK clock divider relative to the APB1 or APB2 clock.
 */
void SdSpiAltDriver::activate() {
  m_spi->beginTransaction(m_spiSettings);
 80a2c2c:	1d01      	adds	r1, r0, #4
 80a2c2e:	6800      	ldr	r0, [r0, #0]
 80a2c30:	f003 b936 	b.w	80a5ea0 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>

080a2c34 <_ZN14SdSpiAltDriver5beginEh>:
//------------------------------------------------------------------------------
/** Initialize the SPI bus.
 *
 * \param[in] chipSelectPin SD card chip select pin.
 */
void SdSpiAltDriver::begin(uint8_t csPin) {
 80a2c34:	b510      	push	{r4, lr}
 80a2c36:	4604      	mov	r4, r0
  m_csPin = csPin;
 80a2c38:	7501      	strb	r1, [r0, #20]
  m_spi->begin();
 80a2c3a:	6800      	ldr	r0, [r0, #0]
 80a2c3c:	f003 f907 	bl	80a5e4e <_ZN8SPIClass5beginEv>
  pinMode(m_csPin, OUTPUT);
 80a2c40:	7d20      	ldrb	r0, [r4, #20]
 80a2c42:	2101      	movs	r1, #1
 80a2c44:	f003 fd64 	bl	80a6710 <pinMode>
  digitalWrite(m_csPin, HIGH);
 80a2c48:	7d20      	ldrb	r0, [r4, #20]
 80a2c4a:	2101      	movs	r1, #1
}
 80a2c4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  digitalWrite(m_csPin, HIGH);
 80a2c50:	f003 bd6f 	b.w	80a6732 <digitalWrite>

080a2c54 <_ZN14SdSpiAltDriver10deactivateEv>:
//------------------------------------------------------------------------------
/**
 * End SPI transaction.
 */
void SdSpiAltDriver::deactivate() {
  m_spi->endTransaction();
 80a2c54:	6800      	ldr	r0, [r0, #0]
 80a2c56:	f003 b908 	b.w	80a5e6a <_ZN8SPIClass14endTransactionEv>

080a2c5a <_ZN14SdSpiAltDriver7receiveEv>:
/** Receive a byte.
 *
 * \return The byte.
 */
uint8_t SdSpiAltDriver::receive() {
  return m_spi->transfer(0XFF);
 80a2c5a:	21ff      	movs	r1, #255	; 0xff
 80a2c5c:	6800      	ldr	r0, [r0, #0]
 80a2c5e:	f003 b98b 	b.w	80a5f78 <_ZN8SPIClass8transferEh>
	...

080a2c64 <_ZN14SdSpiAltDriver7receiveEPhj>:
 * \param[out] buf Buffer to receive the data.
 * \param[in] n Number of bytes to receive.
 *
 * \return Zero for no error or nonzero error code.
 */
uint8_t SdSpiAltDriver::receive(uint8_t* buf, size_t n) {
 80a2c64:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a2c66:	460d      	mov	r5, r1
  SPI_DMA_TransferCompleted = false;
 80a2c68:	2100      	movs	r1, #0
uint8_t SdSpiAltDriver::receive(uint8_t* buf, size_t n) {
 80a2c6a:	4613      	mov	r3, r2
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
 80a2c6c:	4a06      	ldr	r2, [pc, #24]	; (80a2c88 <_ZN14SdSpiAltDriver7receiveEPhj+0x24>)
  SPI_DMA_TransferCompleted = false;
 80a2c6e:	4c07      	ldr	r4, [pc, #28]	; (80a2c8c <_ZN14SdSpiAltDriver7receiveEPhj+0x28>)
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
 80a2c70:	9200      	str	r2, [sp, #0]
 80a2c72:	6800      	ldr	r0, [r0, #0]
 80a2c74:	462a      	mov	r2, r5
  SPI_DMA_TransferCompleted = false;
 80a2c76:	7021      	strb	r1, [r4, #0]
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
 80a2c78:	f003 f984 	bl	80a5f84 <_ZN8SPIClass8transferEPvS0_jPFvvE>
  while (!SPI_DMA_TransferCompleted) {}
 80a2c7c:	7823      	ldrb	r3, [r4, #0]
 80a2c7e:	2b00      	cmp	r3, #0
 80a2c80:	d0fc      	beq.n	80a2c7c <_ZN14SdSpiAltDriver7receiveEPhj+0x18>
  return 0;
}
 80a2c82:	2000      	movs	r0, #0
 80a2c84:	b003      	add	sp, #12
 80a2c86:	bd30      	pop	{r4, r5, pc}
 80a2c88:	080a2c21 	.word	0x080a2c21
 80a2c8c:	20001620 	.word	0x20001620

080a2c90 <_ZN14SdSpiAltDriver4sendEh>:
/** Send a byte.
 *
 * \param[in] b Byte to send
 */
void SdSpiAltDriver::send(uint8_t b) {
  m_spi->transfer(b);
 80a2c90:	6800      	ldr	r0, [r0, #0]
 80a2c92:	f003 b971 	b.w	80a5f78 <_ZN8SPIClass8transferEh>
	...

080a2c98 <_ZN14SdSpiAltDriver4sendEPKhj>:
/** Send multiple bytes.
 *
 * \param[in] buf Buffer for data to be sent.
 * \param[in] n Number of bytes to send.
 */
void SdSpiAltDriver::send(const uint8_t* buf , size_t n) {
 80a2c98:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a2c9a:	4613      	mov	r3, r2
  SPI_DMA_TransferCompleted = false;
 80a2c9c:	2200      	movs	r2, #0

  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
 80a2c9e:	4d06      	ldr	r5, [pc, #24]	; (80a2cb8 <_ZN14SdSpiAltDriver4sendEPKhj+0x20>)
  SPI_DMA_TransferCompleted = false;
 80a2ca0:	4c06      	ldr	r4, [pc, #24]	; (80a2cbc <_ZN14SdSpiAltDriver4sendEPKhj+0x24>)
  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
 80a2ca2:	9500      	str	r5, [sp, #0]
 80a2ca4:	6800      	ldr	r0, [r0, #0]
  SPI_DMA_TransferCompleted = false;
 80a2ca6:	7022      	strb	r2, [r4, #0]
  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
 80a2ca8:	f003 f96c 	bl	80a5f84 <_ZN8SPIClass8transferEPvS0_jPFvvE>
                            SD_SPI_DMA_TransferComplete_Callback);

  while (!SPI_DMA_TransferCompleted) {}
 80a2cac:	7823      	ldrb	r3, [r4, #0]
 80a2cae:	2b00      	cmp	r3, #0
 80a2cb0:	d0fc      	beq.n	80a2cac <_ZN14SdSpiAltDriver4sendEPKhj+0x14>
}
 80a2cb2:	b003      	add	sp, #12
 80a2cb4:	bd30      	pop	{r4, r5, pc}
 80a2cb6:	bf00      	nop
 80a2cb8:	080a2c21 	.word	0x080a2c21
 80a2cbc:	20001620 	.word	0x20001620

080a2cc0 <_ZN17Adafruit_NeoPixel12updateLengthEt>:

uint8_t Adafruit_NeoPixel::getType() const {
    return type;
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a2cc0:	b538      	push	{r3, r4, r5, lr}
 80a2cc2:	4604      	mov	r4, r0
  if (pixels) free(pixels); // Free existing data (if any)
 80a2cc4:	68c0      	ldr	r0, [r0, #12]
void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a2cc6:	460d      	mov	r5, r1
  if (pixels) free(pixels); // Free existing data (if any)
 80a2cc8:	b108      	cbz	r0, 80a2cce <_ZN17Adafruit_NeoPixel12updateLengthEt+0xe>
 80a2cca:	f001 fc6f 	bl	80a45ac <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((type == SK6812RGBW) ? 4 : 3);
 80a2cce:	79a3      	ldrb	r3, [r4, #6]
 80a2cd0:	2b06      	cmp	r3, #6
 80a2cd2:	bf0c      	ite	eq
 80a2cd4:	2004      	moveq	r0, #4
 80a2cd6:	2003      	movne	r0, #3
 80a2cd8:	4368      	muls	r0, r5
 80a2cda:	b280      	uxth	r0, r0
 80a2cdc:	80a0      	strh	r0, [r4, #4]
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 80a2cde:	f001 fc5d 	bl	80a459c <malloc>
 80a2ce2:	60e0      	str	r0, [r4, #12]
 80a2ce4:	b128      	cbz	r0, 80a2cf2 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x32>
    memset(pixels, 0, numBytes);
 80a2ce6:	2100      	movs	r1, #0
 80a2ce8:	88a2      	ldrh	r2, [r4, #4]
 80a2cea:	f004 fde5 	bl	80a78b8 <memset>
    numLEDs = n;
 80a2cee:	8065      	strh	r5, [r4, #2]
  } else {
    numLEDs = numBytes = 0;
  }
}
 80a2cf0:	bd38      	pop	{r3, r4, r5, pc}
    numLEDs = numBytes = 0;
 80a2cf2:	80a0      	strh	r0, [r4, #4]
 80a2cf4:	8060      	strh	r0, [r4, #2]
}
 80a2cf6:	e7fb      	b.n	80a2cf0 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x30>

080a2cf8 <_ZN17Adafruit_NeoPixel5beginEv>:

void Adafruit_NeoPixel::begin(void) {
 80a2cf8:	b510      	push	{r4, lr}
 80a2cfa:	4604      	mov	r4, r0
  pinMode(pin, OUTPUT);
 80a2cfc:	2101      	movs	r1, #1
 80a2cfe:	79c0      	ldrb	r0, [r0, #7]
 80a2d00:	f003 fd06 	bl	80a6710 <pinMode>
  digitalWrite(pin, LOW);
 80a2d04:	2100      	movs	r1, #0
 80a2d06:	79e0      	ldrb	r0, [r4, #7]
 80a2d08:	f003 fd13 	bl	80a6732 <digitalWrite>
  begun = true;
 80a2d0c:	2301      	movs	r3, #1
 80a2d0e:	7023      	strb	r3, [r4, #0]
}
 80a2d10:	bd10      	pop	{r4, pc}

080a2d12 <_ZN17Adafruit_NeoPixel6setPinEh>:

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a2d12:	b538      	push	{r3, r4, r5, lr}
    if (begun) {
 80a2d14:	7803      	ldrb	r3, [r0, #0]
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a2d16:	4605      	mov	r5, r0
 80a2d18:	460c      	mov	r4, r1
    if (begun) {
 80a2d1a:	b11b      	cbz	r3, 80a2d24 <_ZN17Adafruit_NeoPixel6setPinEh+0x12>
        pinMode(pin, INPUT);
 80a2d1c:	2100      	movs	r1, #0
 80a2d1e:	79c0      	ldrb	r0, [r0, #7]
 80a2d20:	f003 fcf6 	bl	80a6710 <pinMode>
    }
    pin = p;
    if (begun) {
 80a2d24:	782b      	ldrb	r3, [r5, #0]
    pin = p;
 80a2d26:	71ec      	strb	r4, [r5, #7]
    if (begun) {
 80a2d28:	b153      	cbz	r3, 80a2d40 <_ZN17Adafruit_NeoPixel6setPinEh+0x2e>
        pinMode(p, OUTPUT);
 80a2d2a:	b2a4      	uxth	r4, r4
 80a2d2c:	4620      	mov	r0, r4
 80a2d2e:	2101      	movs	r1, #1
 80a2d30:	f003 fcee 	bl	80a6710 <pinMode>
        digitalWrite(p, LOW);
 80a2d34:	4620      	mov	r0, r4
    }
}
 80a2d36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        digitalWrite(p, LOW);
 80a2d3a:	2100      	movs	r1, #0
 80a2d3c:	f003 bcf9 	b.w	80a6732 <digitalWrite>
}
 80a2d40:	bd38      	pop	{r3, r4, r5, pc}

080a2d42 <_ZN17Adafruit_NeoPixelC1Ethh>:
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a2d42:	b570      	push	{r4, r5, r6, lr}
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a2d44:	2500      	movs	r5, #0
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a2d46:	4604      	mov	r4, r0
 80a2d48:	4616      	mov	r6, r2
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a2d4a:	7183      	strb	r3, [r0, #6]
 80a2d4c:	e9c0 5503 	strd	r5, r5, [r0, #12]
 80a2d50:	7005      	strb	r5, [r0, #0]
 80a2d52:	7205      	strb	r5, [r0, #8]
  updateLength(n);
 80a2d54:	f7ff ffb4 	bl	80a2cc0 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
 80a2d58:	4620      	mov	r0, r4
 80a2d5a:	4631      	mov	r1, r6
 80a2d5c:	f7ff ffd9 	bl	80a2d12 <_ZN17Adafruit_NeoPixel6setPinEh>
}
 80a2d60:	4620      	mov	r0, r4
 80a2d62:	bd70      	pop	{r4, r5, r6, pc}

080a2d64 <_ZN17Adafruit_NeoPixel4showEv>:

void Adafruit_NeoPixel::show(void) {
  if(!pixels) return;
 80a2d64:	68c3      	ldr	r3, [r0, #12]
 80a2d66:	2b00      	cmp	r3, #0
 80a2d68:	f000 8441 	beq.w	80a35ee <_ZN17Adafruit_NeoPixel4showEv+0x88a>
void Adafruit_NeoPixel::show(void) {
 80a2d6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a2d6e:	7983      	ldrb	r3, [r0, #6]
 80a2d70:	4604      	mov	r4, r0
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  uint32_t wait_time; // wait time in microseconds.
  switch(type) {
 80a2d72:	3b02      	subs	r3, #2
 80a2d74:	b2db      	uxtb	r3, r3
 80a2d76:	2b04      	cmp	r3, #4
 80a2d78:	bf8c      	ite	hi
 80a2d7a:	2532      	movhi	r5, #50	; 0x32
 80a2d7c:	4a28      	ldrls	r2, [pc, #160]	; (80a2e20 <_ZN17Adafruit_NeoPixel4showEv+0xbc>)
void Adafruit_NeoPixel::show(void) {
 80a2d7e:	b087      	sub	sp, #28
 80a2d80:	bf98      	it	ls
 80a2d82:	f852 5023 	ldrls.w	r5, [r2, r3, lsl #2]
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a2d86:	f001 f9db 	bl	80a4140 <HAL_Timer_Get_Micro_Seconds>
    case WS2812B2_FAST:
    default: {   // default = 50us reset pulse
        wait_time = 50L;
      } break;
  }
  while((micros() - endTime) < wait_time);
 80a2d8a:	6923      	ldr	r3, [r4, #16]
 80a2d8c:	1ac0      	subs	r0, r0, r3
 80a2d8e:	42a8      	cmp	r0, r5
 80a2d90:	d3f9      	bcc.n	80a2d86 <_ZN17Adafruit_NeoPixel4showEv+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a2d92:	b672      	cpsid	i
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a2d94:	88a3      	ldrh	r3, [r4, #4]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a2d96:	79a5      	ldrb	r5, [r4, #6]
  volatile uint16_t i = numBytes; // Output loop counter
 80a2d98:	f8ad 300a 	strh.w	r3, [sp, #10]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2d9c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a2da0:	2d02      	cmp	r5, #2
   *ptr = pixels,   // Pointer to next byte
 80a2da2:	68e1      	ldr	r1, [r4, #12]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2da4:	b29b      	uxth	r3, r3
  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a2da6:	f000 826e 	beq.w	80a3286 <_ZN17Adafruit_NeoPixel4showEv+0x522>
 80a2daa:	2d07      	cmp	r5, #7
 80a2dac:	f000 826b 	beq.w	80a3286 <_ZN17Adafruit_NeoPixel4showEv+0x522>
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
 80a2db0:	2d06      	cmp	r5, #6
 80a2db2:	f000 841d 	beq.w	80a35f0 <_ZN17Adafruit_NeoPixel4showEv+0x88c>
        }
        mask >>= 1;
      } while ( ++j < 32 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == WS2812B2 || type == WS2812B2_FAST) { // WS2812B with DWT timer
 80a2db6:	2d05      	cmp	r5, #5
 80a2db8:	f000 83a1 	beq.w	80a34fe <_ZN17Adafruit_NeoPixel4showEv+0x79a>
 80a2dbc:	2d08      	cmp	r5, #8
 80a2dbe:	f000 839e 	beq.w	80a34fe <_ZN17Adafruit_NeoPixel4showEv+0x79a>
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
 80a2dc2:	2d00      	cmp	r5, #0
 80a2dc4:	f040 854f 	bne.w	80a3866 <_ZN17Adafruit_NeoPixel4showEv+0xb02>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2dc8:	2b00      	cmp	r3, #0
 80a2dca:	f000 8392 	beq.w	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a2dce:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
 80a2dd2:	4a14      	ldr	r2, [pc, #80]	; (80a2e24 <_ZN17Adafruit_NeoPixel4showEv+0xc0>)
 80a2dd4:	9604      	str	r6, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a2dd6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
 80a2dda:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a2ddc:	3b03      	subs	r3, #3
 80a2dde:	b29b      	uxth	r3, r3
 80a2de0:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a2de4:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a2de8:	b2db      	uxtb	r3, r3
 80a2dea:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a2dee:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a2df2:	b2db      	uxtb	r3, r3
 80a2df4:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a2df8:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a2dfc:	b2db      	uxtb	r3, r3
 80a2dfe:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a2e02:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a2e06:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a2e0a:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a2e0e:	021b      	lsls	r3, r3, #8
 80a2e10:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a2e14:	4303      	orrs	r3, r0
 80a2e16:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a2e18:	f88d 5005 	strb.w	r5, [sp, #5]
 80a2e1c:	e11b      	b.n	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x2f2>
 80a2e1e:	bf00      	nop
 80a2e20:	080a7e18 	.word	0x080a7e18
 80a2e24:	20001624 	.word	0x20001624
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2e28:	4600      	mov	r0, r0
 80a2e2a:	bf00      	nop
 80a2e2c:	bf00      	nop
 80a2e2e:	bf00      	nop
 80a2e30:	bf00      	nop
 80a2e32:	bf00      	nop
 80a2e34:	bf00      	nop
 80a2e36:	bf00      	nop
 80a2e38:	bf00      	nop
 80a2e3a:	bf00      	nop
 80a2e3c:	bf00      	nop
 80a2e3e:	bf00      	nop
 80a2e40:	bf00      	nop
 80a2e42:	bf00      	nop
 80a2e44:	bf00      	nop
 80a2e46:	bf00      	nop
 80a2e48:	bf00      	nop
 80a2e4a:	bf00      	nop
 80a2e4c:	bf00      	nop
 80a2e4e:	bf00      	nop
 80a2e50:	bf00      	nop
 80a2e52:	bf00      	nop
 80a2e54:	bf00      	nop
 80a2e56:	bf00      	nop
 80a2e58:	bf00      	nop
 80a2e5a:	bf00      	nop
 80a2e5c:	bf00      	nop
 80a2e5e:	bf00      	nop
 80a2e60:	bf00      	nop
 80a2e62:	bf00      	nop
 80a2e64:	bf00      	nop
 80a2e66:	bf00      	nop
 80a2e68:	bf00      	nop
 80a2e6a:	bf00      	nop
 80a2e6c:	bf00      	nop
 80a2e6e:	bf00      	nop
 80a2e70:	bf00      	nop
 80a2e72:	bf00      	nop
 80a2e74:	bf00      	nop
 80a2e76:	bf00      	nop
 80a2e78:	bf00      	nop
 80a2e7a:	bf00      	nop
 80a2e7c:	bf00      	nop
 80a2e7e:	bf00      	nop
 80a2e80:	bf00      	nop
 80a2e82:	bf00      	nop
 80a2e84:	bf00      	nop
 80a2e86:	bf00      	nop
 80a2e88:	bf00      	nop
 80a2e8a:	bf00      	nop
 80a2e8c:	bf00      	nop
 80a2e8e:	bf00      	nop
 80a2e90:	bf00      	nop
 80a2e92:	bf00      	nop
 80a2e94:	bf00      	nop
 80a2e96:	bf00      	nop
 80a2e98:	bf00      	nop
 80a2e9a:	bf00      	nop
 80a2e9c:	bf00      	nop
 80a2e9e:	bf00      	nop
 80a2ea0:	bf00      	nop
 80a2ea2:	bf00      	nop
 80a2ea4:	bf00      	nop
 80a2ea6:	bf00      	nop
 80a2ea8:	bf00      	nop
 80a2eaa:	bf00      	nop
 80a2eac:	bf00      	nop
 80a2eae:	bf00      	nop
 80a2eb0:	bf00      	nop
 80a2eb2:	bf00      	nop
 80a2eb4:	bf00      	nop
 80a2eb6:	bf00      	nop
 80a2eb8:	bf00      	nop
 80a2eba:	bf00      	nop
 80a2ebc:	bf00      	nop
 80a2ebe:	bf00      	nop
 80a2ec0:	bf00      	nop
 80a2ec2:	bf00      	nop
 80a2ec4:	bf00      	nop
 80a2ec6:	bf00      	nop
 80a2ec8:	bf00      	nop
 80a2eca:	bf00      	nop
 80a2ecc:	bf00      	nop
 80a2ece:	bf00      	nop
 80a2ed0:	bf00      	nop
 80a2ed2:	bf00      	nop
 80a2ed4:	bf00      	nop
 80a2ed6:	bf00      	nop
 80a2ed8:	bf00      	nop
 80a2eda:	bf00      	nop
 80a2edc:	bf00      	nop
 80a2ede:	bf00      	nop
 80a2ee0:	bf00      	nop
 80a2ee2:	bf00      	nop
 80a2ee4:	bf00      	nop
 80a2ee6:	bf00      	nop
 80a2ee8:	bf00      	nop
 80a2eea:	bf00      	nop
 80a2eec:	bf00      	nop
 80a2eee:	bf00      	nop
 80a2ef0:	bf00      	nop
 80a2ef2:	bf00      	nop
 80a2ef4:	bf00      	nop
 80a2ef6:	bf00      	nop
 80a2ef8:	bf00      	nop
 80a2efa:	bf00      	nop
 80a2efc:	bf00      	nop
 80a2efe:	bf00      	nop
 80a2f00:	bf00      	nop
 80a2f02:	bf00      	nop
 80a2f04:	bf00      	nop
 80a2f06:	bf00      	nop
 80a2f08:	bf00      	nop
 80a2f0a:	bf00      	nop
 80a2f0c:	bf00      	nop
 80a2f0e:	bf00      	nop
 80a2f10:	bf00      	nop
 80a2f12:	bf00      	nop
 80a2f14:	bf00      	nop
 80a2f16:	bf00      	nop
 80a2f18:	bf00      	nop
 80a2f1a:	bf00      	nop
 80a2f1c:	bf00      	nop
 80a2f1e:	bf00      	nop
 80a2f20:	bf00      	nop
 80a2f22:	bf00      	nop
 80a2f24:	bf00      	nop
 80a2f26:	bf00      	nop
 80a2f28:	bf00      	nop
 80a2f2a:	bf00      	nop
 80a2f2c:	bf00      	nop
 80a2f2e:	bf00      	nop
          // WS2811 spec             1.30us LOW
          // Adafruit on Arduino    (meas. 1.25us)
          // This lib on Spark Core (meas. 1.24us)
          // This lib on Photon     (meas. 1.24us)
          pinSet(pin, LOW); // LOW
 80a2f30:	79e3      	ldrb	r3, [r4, #7]
 80a2f32:	6810      	ldr	r0, [r2, #0]
 80a2f34:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2f38:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2f3c:	88bf      	ldrh	r7, [r7, #4]
 80a2f3e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2f42:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2f44:	4600      	mov	r0, r0
 80a2f46:	bf00      	nop
 80a2f48:	bf00      	nop
 80a2f4a:	bf00      	nop
 80a2f4c:	bf00      	nop
 80a2f4e:	bf00      	nop
 80a2f50:	bf00      	nop
 80a2f52:	bf00      	nop
 80a2f54:	bf00      	nop
 80a2f56:	bf00      	nop
 80a2f58:	bf00      	nop
 80a2f5a:	bf00      	nop
 80a2f5c:	bf00      	nop
 80a2f5e:	bf00      	nop
 80a2f60:	bf00      	nop
 80a2f62:	bf00      	nop
 80a2f64:	bf00      	nop
 80a2f66:	bf00      	nop
 80a2f68:	bf00      	nop
 80a2f6a:	bf00      	nop
 80a2f6c:	bf00      	nop
 80a2f6e:	bf00      	nop
 80a2f70:	bf00      	nop
 80a2f72:	bf00      	nop
 80a2f74:	bf00      	nop
 80a2f76:	bf00      	nop
 80a2f78:	bf00      	nop
 80a2f7a:	bf00      	nop
 80a2f7c:	bf00      	nop
 80a2f7e:	bf00      	nop
 80a2f80:	bf00      	nop
 80a2f82:	bf00      	nop
 80a2f84:	bf00      	nop
 80a2f86:	bf00      	nop
 80a2f88:	bf00      	nop
 80a2f8a:	bf00      	nop
 80a2f8c:	bf00      	nop
 80a2f8e:	bf00      	nop
 80a2f90:	bf00      	nop
 80a2f92:	bf00      	nop
 80a2f94:	bf00      	nop
 80a2f96:	bf00      	nop
 80a2f98:	bf00      	nop
 80a2f9a:	bf00      	nop
 80a2f9c:	bf00      	nop
 80a2f9e:	bf00      	nop
 80a2fa0:	bf00      	nop
 80a2fa2:	bf00      	nop
 80a2fa4:	bf00      	nop
 80a2fa6:	bf00      	nop
 80a2fa8:	bf00      	nop
 80a2faa:	bf00      	nop
 80a2fac:	bf00      	nop
 80a2fae:	bf00      	nop
 80a2fb0:	bf00      	nop
 80a2fb2:	bf00      	nop
 80a2fb4:	bf00      	nop
 80a2fb6:	bf00      	nop
 80a2fb8:	bf00      	nop
 80a2fba:	bf00      	nop
 80a2fbc:	bf00      	nop
 80a2fbe:	bf00      	nop
 80a2fc0:	bf00      	nop
 80a2fc2:	bf00      	nop
 80a2fc4:	bf00      	nop
 80a2fc6:	bf00      	nop
 80a2fc8:	bf00      	nop
 80a2fca:	bf00      	nop
 80a2fcc:	bf00      	nop
 80a2fce:	bf00      	nop
 80a2fd0:	bf00      	nop
 80a2fd2:	bf00      	nop
 80a2fd4:	bf00      	nop
 80a2fd6:	bf00      	nop
 80a2fd8:	bf00      	nop
 80a2fda:	bf00      	nop
 80a2fdc:	bf00      	nop
 80a2fde:	bf00      	nop
 80a2fe0:	bf00      	nop
 80a2fe2:	bf00      	nop
 80a2fe4:	bf00      	nop
 80a2fe6:	bf00      	nop
 80a2fe8:	bf00      	nop
 80a2fea:	bf00      	nop
 80a2fec:	bf00      	nop
 80a2fee:	bf00      	nop
 80a2ff0:	bf00      	nop
 80a2ff2:	bf00      	nop
 80a2ff4:	bf00      	nop
 80a2ff6:	bf00      	nop
 80a2ff8:	bf00      	nop
 80a2ffa:	bf00      	nop
 80a2ffc:	bf00      	nop
 80a2ffe:	bf00      	nop
 80a3000:	bf00      	nop
 80a3002:	bf00      	nop
 80a3004:	bf00      	nop
 80a3006:	bf00      	nop
 80a3008:	bf00      	nop
 80a300a:	bf00      	nop
 80a300c:	bf00      	nop
 80a300e:	bf00      	nop
 80a3010:	bf00      	nop
 80a3012:	bf00      	nop
 80a3014:	bf00      	nop
 80a3016:	bf00      	nop
 80a3018:	bf00      	nop
 80a301a:	bf00      	nop
 80a301c:	bf00      	nop
 80a301e:	bf00      	nop
 80a3020:	bf00      	nop
 80a3022:	bf00      	nop
 80a3024:	bf00      	nop
 80a3026:	bf00      	nop
 80a3028:	bf00      	nop
 80a302a:	bf00      	nop
 80a302c:	bf00      	nop
 80a302e:	bf00      	nop
 80a3030:	bf00      	nop
 80a3032:	bf00      	nop
 80a3034:	bf00      	nop
 80a3036:	bf00      	nop
 80a3038:	bf00      	nop
 80a303a:	bf00      	nop
 80a303c:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a303e:	9b04      	ldr	r3, [sp, #16]
 80a3040:	085b      	lsrs	r3, r3, #1
 80a3042:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a3044:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3048:	3301      	adds	r3, #1
 80a304a:	b2db      	uxtb	r3, r3
 80a304c:	2b17      	cmp	r3, #23
 80a304e:	f88d 3005 	strb.w	r3, [sp, #5]
 80a3052:	f200 8727 	bhi.w	80a3ea4 <_ZN17Adafruit_NeoPixel4showEv+0x1140>
        pinSet(pin, HIGH); // HIGH
 80a3056:	79e3      	ldrb	r3, [r4, #7]
 80a3058:	6810      	ldr	r0, [r2, #0]
 80a305a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a305e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3062:	88bf      	ldrh	r7, [r7, #4]
 80a3064:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3068:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a306a:	9803      	ldr	r0, [sp, #12]
 80a306c:	9b04      	ldr	r3, [sp, #16]
 80a306e:	4218      	tst	r0, r3
 80a3070:	f47f aeda 	bne.w	80a2e28 <_ZN17Adafruit_NeoPixel4showEv+0xc4>
            ::: "r0", "cc", "memory");
 80a3074:	4600      	mov	r0, r0
 80a3076:	bf00      	nop
 80a3078:	bf00      	nop
 80a307a:	bf00      	nop
 80a307c:	bf00      	nop
 80a307e:	bf00      	nop
 80a3080:	bf00      	nop
 80a3082:	bf00      	nop
 80a3084:	bf00      	nop
 80a3086:	bf00      	nop
 80a3088:	bf00      	nop
 80a308a:	bf00      	nop
 80a308c:	bf00      	nop
 80a308e:	bf00      	nop
 80a3090:	bf00      	nop
 80a3092:	bf00      	nop
 80a3094:	bf00      	nop
 80a3096:	bf00      	nop
 80a3098:	bf00      	nop
 80a309a:	bf00      	nop
 80a309c:	bf00      	nop
 80a309e:	bf00      	nop
 80a30a0:	bf00      	nop
 80a30a2:	bf00      	nop
 80a30a4:	bf00      	nop
 80a30a6:	bf00      	nop
 80a30a8:	bf00      	nop
 80a30aa:	bf00      	nop
 80a30ac:	bf00      	nop
 80a30ae:	bf00      	nop
 80a30b0:	bf00      	nop
 80a30b2:	bf00      	nop
 80a30b4:	bf00      	nop
 80a30b6:	bf00      	nop
 80a30b8:	bf00      	nop
 80a30ba:	bf00      	nop
 80a30bc:	bf00      	nop
 80a30be:	bf00      	nop
 80a30c0:	bf00      	nop
 80a30c2:	bf00      	nop
 80a30c4:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a30c6:	79e3      	ldrb	r3, [r4, #7]
 80a30c8:	6810      	ldr	r0, [r2, #0]
 80a30ca:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a30ce:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a30d2:	88bf      	ldrh	r7, [r7, #4]
 80a30d4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a30d8:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a30da:	4600      	mov	r0, r0
 80a30dc:	bf00      	nop
 80a30de:	bf00      	nop
 80a30e0:	bf00      	nop
 80a30e2:	bf00      	nop
 80a30e4:	bf00      	nop
 80a30e6:	bf00      	nop
 80a30e8:	bf00      	nop
 80a30ea:	bf00      	nop
 80a30ec:	bf00      	nop
 80a30ee:	bf00      	nop
 80a30f0:	bf00      	nop
 80a30f2:	bf00      	nop
 80a30f4:	bf00      	nop
 80a30f6:	bf00      	nop
 80a30f8:	bf00      	nop
 80a30fa:	bf00      	nop
 80a30fc:	bf00      	nop
 80a30fe:	bf00      	nop
 80a3100:	bf00      	nop
 80a3102:	bf00      	nop
 80a3104:	bf00      	nop
 80a3106:	bf00      	nop
 80a3108:	bf00      	nop
 80a310a:	bf00      	nop
 80a310c:	bf00      	nop
 80a310e:	bf00      	nop
 80a3110:	bf00      	nop
 80a3112:	bf00      	nop
 80a3114:	bf00      	nop
 80a3116:	bf00      	nop
 80a3118:	bf00      	nop
 80a311a:	bf00      	nop
 80a311c:	bf00      	nop
 80a311e:	bf00      	nop
 80a3120:	bf00      	nop
 80a3122:	bf00      	nop
 80a3124:	bf00      	nop
 80a3126:	bf00      	nop
 80a3128:	bf00      	nop
 80a312a:	bf00      	nop
 80a312c:	bf00      	nop
 80a312e:	bf00      	nop
 80a3130:	bf00      	nop
 80a3132:	bf00      	nop
 80a3134:	bf00      	nop
 80a3136:	bf00      	nop
 80a3138:	bf00      	nop
 80a313a:	bf00      	nop
 80a313c:	bf00      	nop
 80a313e:	bf00      	nop
 80a3140:	bf00      	nop
 80a3142:	bf00      	nop
 80a3144:	bf00      	nop
 80a3146:	bf00      	nop
 80a3148:	bf00      	nop
 80a314a:	bf00      	nop
 80a314c:	bf00      	nop
 80a314e:	bf00      	nop
 80a3150:	bf00      	nop
 80a3152:	bf00      	nop
 80a3154:	bf00      	nop
 80a3156:	bf00      	nop
 80a3158:	bf00      	nop
 80a315a:	bf00      	nop
 80a315c:	bf00      	nop
 80a315e:	bf00      	nop
 80a3160:	bf00      	nop
 80a3162:	bf00      	nop
 80a3164:	bf00      	nop
 80a3166:	bf00      	nop
 80a3168:	bf00      	nop
 80a316a:	bf00      	nop
 80a316c:	bf00      	nop
 80a316e:	bf00      	nop
 80a3170:	bf00      	nop
 80a3172:	bf00      	nop
 80a3174:	bf00      	nop
 80a3176:	bf00      	nop
 80a3178:	bf00      	nop
 80a317a:	bf00      	nop
 80a317c:	bf00      	nop
 80a317e:	bf00      	nop
 80a3180:	bf00      	nop
 80a3182:	bf00      	nop
 80a3184:	bf00      	nop
 80a3186:	bf00      	nop
 80a3188:	bf00      	nop
 80a318a:	bf00      	nop
 80a318c:	bf00      	nop
 80a318e:	bf00      	nop
 80a3190:	bf00      	nop
 80a3192:	bf00      	nop
 80a3194:	bf00      	nop
 80a3196:	bf00      	nop
 80a3198:	bf00      	nop
 80a319a:	bf00      	nop
 80a319c:	bf00      	nop
 80a319e:	bf00      	nop
 80a31a0:	bf00      	nop
 80a31a2:	bf00      	nop
 80a31a4:	bf00      	nop
 80a31a6:	bf00      	nop
 80a31a8:	bf00      	nop
 80a31aa:	bf00      	nop
 80a31ac:	bf00      	nop
 80a31ae:	bf00      	nop
 80a31b0:	bf00      	nop
 80a31b2:	bf00      	nop
 80a31b4:	bf00      	nop
 80a31b6:	bf00      	nop
 80a31b8:	bf00      	nop
 80a31ba:	bf00      	nop
 80a31bc:	bf00      	nop
 80a31be:	bf00      	nop
 80a31c0:	bf00      	nop
 80a31c2:	bf00      	nop
 80a31c4:	bf00      	nop
 80a31c6:	bf00      	nop
 80a31c8:	bf00      	nop
 80a31ca:	bf00      	nop
 80a31cc:	bf00      	nop
 80a31ce:	bf00      	nop
 80a31d0:	bf00      	nop
 80a31d2:	bf00      	nop
 80a31d4:	bf00      	nop
 80a31d6:	bf00      	nop
 80a31d8:	bf00      	nop
 80a31da:	bf00      	nop
 80a31dc:	bf00      	nop
 80a31de:	bf00      	nop
 80a31e0:	bf00      	nop
 80a31e2:	bf00      	nop
 80a31e4:	bf00      	nop
 80a31e6:	bf00      	nop
 80a31e8:	bf00      	nop
 80a31ea:	bf00      	nop
 80a31ec:	bf00      	nop
 80a31ee:	bf00      	nop
 80a31f0:	bf00      	nop
 80a31f2:	bf00      	nop
 80a31f4:	bf00      	nop
 80a31f6:	bf00      	nop
 80a31f8:	bf00      	nop
 80a31fa:	bf00      	nop
 80a31fc:	bf00      	nop
 80a31fe:	bf00      	nop
 80a3200:	bf00      	nop
 80a3202:	bf00      	nop
 80a3204:	bf00      	nop
 80a3206:	bf00      	nop
 80a3208:	bf00      	nop
 80a320a:	bf00      	nop
 80a320c:	bf00      	nop
 80a320e:	bf00      	nop
 80a3210:	bf00      	nop
 80a3212:	bf00      	nop
 80a3214:	bf00      	nop
 80a3216:	bf00      	nop
 80a3218:	bf00      	nop
 80a321a:	bf00      	nop
 80a321c:	bf00      	nop
 80a321e:	bf00      	nop
 80a3220:	bf00      	nop
 80a3222:	bf00      	nop
 80a3224:	bf00      	nop
 80a3226:	bf00      	nop
 80a3228:	bf00      	nop
 80a322a:	bf00      	nop
 80a322c:	bf00      	nop
 80a322e:	bf00      	nop
 80a3230:	bf00      	nop
 80a3232:	bf00      	nop
 80a3234:	bf00      	nop
 80a3236:	bf00      	nop
 80a3238:	bf00      	nop
 80a323a:	bf00      	nop
 80a323c:	bf00      	nop
 80a323e:	bf00      	nop
 80a3240:	bf00      	nop
 80a3242:	bf00      	nop
 80a3244:	bf00      	nop
 80a3246:	bf00      	nop
 80a3248:	bf00      	nop
 80a324a:	bf00      	nop
 80a324c:	bf00      	nop
 80a324e:	bf00      	nop
 80a3250:	bf00      	nop
 80a3252:	bf00      	nop
 80a3254:	bf00      	nop
 80a3256:	bf00      	nop
 80a3258:	bf00      	nop
 80a325a:	bf00      	nop
 80a325c:	bf00      	nop
 80a325e:	bf00      	nop
 80a3260:	bf00      	nop
 80a3262:	bf00      	nop
 80a3264:	bf00      	nop
 80a3266:	bf00      	nop
 80a3268:	bf00      	nop
 80a326a:	bf00      	nop
 80a326c:	bf00      	nop
 80a326e:	bf00      	nop
 80a3270:	bf00      	nop
 80a3272:	bf00      	nop
 80a3274:	bf00      	nop
 80a3276:	bf00      	nop
 80a3278:	bf00      	nop
 80a327a:	bf00      	nop
 80a327c:	bf00      	nop
 80a327e:	bf00      	nop
 80a3280:	bf00      	nop
 80a3282:	bf00      	nop
 80a3284:	e6db      	b.n	80a303e <_ZN17Adafruit_NeoPixel4showEv+0x2da>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3286:	2b00      	cmp	r3, #0
 80a3288:	f000 8133 	beq.w	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a328c:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a3290:	2600      	movs	r6, #0
 80a3292:	4a13      	ldr	r2, [pc, #76]	; (80a32e0 <_ZN17Adafruit_NeoPixel4showEv+0x57c>)
      mask = 0x800000; // reset the mask
 80a3294:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a3296:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      b = *ptr++;   // Next blue byte value
 80a329a:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a329c:	3b03      	subs	r3, #3
 80a329e:	b29b      	uxth	r3, r3
 80a32a0:	f8ad 300a 	strh.w	r3, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a32a4:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a32a8:	b2db      	uxtb	r3, r3
 80a32aa:	f88d 3006 	strb.w	r3, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a32ae:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a32b2:	b2db      	uxtb	r3, r3
 80a32b4:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a32b8:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a32bc:	b2db      	uxtb	r3, r3
 80a32be:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a32c2:	f89d 7006 	ldrb.w	r7, [sp, #6]
 80a32c6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a32ca:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a32ce:	021b      	lsls	r3, r3, #8
 80a32d0:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a32d4:	4303      	orrs	r3, r0
 80a32d6:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a32d8:	f88d 6005 	strb.w	r6, [sp, #5]
 80a32dc:	e080      	b.n	80a33e0 <_ZN17Adafruit_NeoPixel4showEv+0x67c>
 80a32de:	bf00      	nop
 80a32e0:	20001624 	.word	0x20001624
            ::: "r0", "cc", "memory");
 80a32e4:	4600      	mov	r0, r0
 80a32e6:	bf00      	nop
 80a32e8:	bf00      	nop
 80a32ea:	bf00      	nop
 80a32ec:	bf00      	nop
 80a32ee:	bf00      	nop
 80a32f0:	bf00      	nop
 80a32f2:	bf00      	nop
 80a32f4:	bf00      	nop
 80a32f6:	bf00      	nop
 80a32f8:	bf00      	nop
 80a32fa:	bf00      	nop
 80a32fc:	bf00      	nop
 80a32fe:	bf00      	nop
 80a3300:	bf00      	nop
 80a3302:	bf00      	nop
 80a3304:	bf00      	nop
 80a3306:	bf00      	nop
 80a3308:	bf00      	nop
 80a330a:	bf00      	nop
 80a330c:	bf00      	nop
 80a330e:	bf00      	nop
 80a3310:	bf00      	nop
 80a3312:	bf00      	nop
 80a3314:	bf00      	nop
 80a3316:	bf00      	nop
 80a3318:	bf00      	nop
 80a331a:	bf00      	nop
 80a331c:	bf00      	nop
 80a331e:	bf00      	nop
 80a3320:	bf00      	nop
 80a3322:	bf00      	nop
 80a3324:	bf00      	nop
 80a3326:	bf00      	nop
 80a3328:	bf00      	nop
 80a332a:	bf00      	nop
 80a332c:	bf00      	nop
 80a332e:	bf00      	nop
 80a3330:	bf00      	nop
 80a3332:	bf00      	nop
 80a3334:	bf00      	nop
 80a3336:	bf00      	nop
 80a3338:	bf00      	nop
 80a333a:	bf00      	nop
 80a333c:	bf00      	nop
 80a333e:	bf00      	nop
 80a3340:	bf00      	nop
 80a3342:	bf00      	nop
 80a3344:	bf00      	nop
 80a3346:	bf00      	nop
 80a3348:	bf00      	nop
 80a334a:	bf00      	nop
 80a334c:	bf00      	nop
 80a334e:	bf00      	nop
 80a3350:	bf00      	nop
 80a3352:	bf00      	nop
 80a3354:	bf00      	nop
 80a3356:	bf00      	nop
 80a3358:	bf00      	nop
 80a335a:	bf00      	nop
 80a335c:	bf00      	nop
 80a335e:	bf00      	nop
 80a3360:	bf00      	nop
 80a3362:	bf00      	nop
 80a3364:	bf00      	nop
 80a3366:	bf00      	nop
 80a3368:	bf00      	nop
 80a336a:	bf00      	nop
 80a336c:	bf00      	nop
 80a336e:	bf00      	nop
 80a3370:	bf00      	nop
 80a3372:	bf00      	nop
 80a3374:	bf00      	nop
 80a3376:	bf00      	nop
 80a3378:	bf00      	nop
 80a337a:	bf00      	nop
 80a337c:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a337e:	79e3      	ldrb	r3, [r4, #7]
 80a3380:	6810      	ldr	r0, [r2, #0]
 80a3382:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3386:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a338a:	88bf      	ldrh	r7, [r7, #4]
 80a338c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3390:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a3392:	4600      	mov	r0, r0
 80a3394:	bf00      	nop
 80a3396:	bf00      	nop
 80a3398:	bf00      	nop
 80a339a:	bf00      	nop
 80a339c:	bf00      	nop
 80a339e:	bf00      	nop
 80a33a0:	bf00      	nop
 80a33a2:	bf00      	nop
 80a33a4:	bf00      	nop
 80a33a6:	bf00      	nop
 80a33a8:	bf00      	nop
 80a33aa:	bf00      	nop
 80a33ac:	bf00      	nop
 80a33ae:	bf00      	nop
 80a33b0:	bf00      	nop
 80a33b2:	bf00      	nop
 80a33b4:	bf00      	nop
 80a33b6:	bf00      	nop
 80a33b8:	bf00      	nop
 80a33ba:	bf00      	nop
 80a33bc:	bf00      	nop
 80a33be:	bf00      	nop
 80a33c0:	bf00      	nop
 80a33c2:	bf00      	nop
 80a33c4:	bf00      	nop
 80a33c6:	bf00      	nop
        mask >>= 1;
 80a33c8:	9b04      	ldr	r3, [sp, #16]
 80a33ca:	085b      	lsrs	r3, r3, #1
 80a33cc:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a33ce:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a33d2:	3301      	adds	r3, #1
 80a33d4:	b2db      	uxtb	r3, r3
 80a33d6:	2b17      	cmp	r3, #23
 80a33d8:	f88d 3005 	strb.w	r3, [sp, #5]
 80a33dc:	f200 8083 	bhi.w	80a34e6 <_ZN17Adafruit_NeoPixel4showEv+0x782>
        pinSet(pin, HIGH); // HIGH
 80a33e0:	79e3      	ldrb	r3, [r4, #7]
 80a33e2:	6810      	ldr	r0, [r2, #0]
 80a33e4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a33e8:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a33ec:	88bf      	ldrh	r7, [r7, #4]
 80a33ee:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a33f2:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a33f4:	9803      	ldr	r0, [sp, #12]
 80a33f6:	9b04      	ldr	r3, [sp, #16]
 80a33f8:	4218      	tst	r0, r3
 80a33fa:	f47f af73 	bne.w	80a32e4 <_ZN17Adafruit_NeoPixel4showEv+0x580>
            ::: "r0", "cc", "memory");
 80a33fe:	4600      	mov	r0, r0
 80a3400:	bf00      	nop
 80a3402:	bf00      	nop
 80a3404:	bf00      	nop
 80a3406:	bf00      	nop
 80a3408:	bf00      	nop
 80a340a:	bf00      	nop
 80a340c:	bf00      	nop
 80a340e:	bf00      	nop
 80a3410:	bf00      	nop
 80a3412:	bf00      	nop
 80a3414:	bf00      	nop
 80a3416:	bf00      	nop
 80a3418:	bf00      	nop
 80a341a:	bf00      	nop
 80a341c:	bf00      	nop
 80a341e:	bf00      	nop
 80a3420:	bf00      	nop
 80a3422:	bf00      	nop
 80a3424:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a3426:	79e3      	ldrb	r3, [r4, #7]
 80a3428:	6810      	ldr	r0, [r2, #0]
 80a342a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a342e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3432:	88bf      	ldrh	r7, [r7, #4]
 80a3434:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3438:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a343a:	4600      	mov	r0, r0
 80a343c:	bf00      	nop
 80a343e:	bf00      	nop
 80a3440:	bf00      	nop
 80a3442:	bf00      	nop
 80a3444:	bf00      	nop
 80a3446:	bf00      	nop
 80a3448:	bf00      	nop
 80a344a:	bf00      	nop
 80a344c:	bf00      	nop
 80a344e:	bf00      	nop
 80a3450:	bf00      	nop
 80a3452:	bf00      	nop
 80a3454:	bf00      	nop
 80a3456:	bf00      	nop
 80a3458:	bf00      	nop
 80a345a:	bf00      	nop
 80a345c:	bf00      	nop
 80a345e:	bf00      	nop
 80a3460:	bf00      	nop
 80a3462:	bf00      	nop
 80a3464:	bf00      	nop
 80a3466:	bf00      	nop
 80a3468:	bf00      	nop
 80a346a:	bf00      	nop
 80a346c:	bf00      	nop
 80a346e:	bf00      	nop
 80a3470:	bf00      	nop
 80a3472:	bf00      	nop
 80a3474:	bf00      	nop
 80a3476:	bf00      	nop
 80a3478:	bf00      	nop
 80a347a:	bf00      	nop
 80a347c:	bf00      	nop
 80a347e:	bf00      	nop
 80a3480:	bf00      	nop
 80a3482:	bf00      	nop
 80a3484:	bf00      	nop
 80a3486:	bf00      	nop
 80a3488:	bf00      	nop
 80a348a:	bf00      	nop
 80a348c:	bf00      	nop
 80a348e:	bf00      	nop
 80a3490:	bf00      	nop
 80a3492:	bf00      	nop
 80a3494:	bf00      	nop
 80a3496:	bf00      	nop
 80a3498:	bf00      	nop
 80a349a:	bf00      	nop
 80a349c:	bf00      	nop
 80a349e:	bf00      	nop
 80a34a0:	bf00      	nop
 80a34a2:	bf00      	nop
 80a34a4:	bf00      	nop
 80a34a6:	bf00      	nop
 80a34a8:	bf00      	nop
 80a34aa:	bf00      	nop
 80a34ac:	bf00      	nop
 80a34ae:	bf00      	nop
 80a34b0:	bf00      	nop
 80a34b2:	bf00      	nop
 80a34b4:	bf00      	nop
 80a34b6:	bf00      	nop
 80a34b8:	bf00      	nop
 80a34ba:	bf00      	nop
 80a34bc:	bf00      	nop
 80a34be:	bf00      	nop
 80a34c0:	bf00      	nop
 80a34c2:	bf00      	nop
 80a34c4:	bf00      	nop
 80a34c6:	bf00      	nop
 80a34c8:	bf00      	nop
 80a34ca:	bf00      	nop
 80a34cc:	bf00      	nop
 80a34ce:	bf00      	nop
 80a34d0:	bf00      	nop
 80a34d2:	bf00      	nop
 80a34d4:	bf00      	nop
 80a34d6:	bf00      	nop
 80a34d8:	bf00      	nop
 80a34da:	bf00      	nop
 80a34dc:	bf00      	nop
 80a34de:	bf00      	nop
 80a34e0:	bf00      	nop
 80a34e2:	bf00      	nop
 80a34e4:	e770      	b.n	80a33c8 <_ZN17Adafruit_NeoPixel4showEv+0x664>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a34e6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a34ea:	b29b      	uxth	r3, r3
 80a34ec:	2b00      	cmp	r3, #0
 80a34ee:	f47f aed1 	bne.w	80a3294 <_ZN17Adafruit_NeoPixel4showEv+0x530>
  __ASM volatile ("cpsie i");
 80a34f2:	b662      	cpsie	i
 80a34f4:	f000 fe24 	bl	80a4140 <HAL_Timer_Get_Micro_Seconds>
  }
// END of NRF52 implementation


#endif
  endTime = micros(); // Save EOD time for latch on next call
 80a34f8:	6120      	str	r0, [r4, #16]
}
 80a34fa:	b007      	add	sp, #28
 80a34fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a34fe:	2b00      	cmp	r3, #0
 80a3500:	d0f7      	beq.n	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a3502:	f44f 0e00 	mov.w	lr, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a3506:	2600      	movs	r6, #0
        pinSet(pin, HIGH); // HIGH
 80a3508:	4b54      	ldr	r3, [pc, #336]	; (80a365c <_ZN17Adafruit_NeoPixel4showEv+0x8f8>)
 80a350a:	6818      	ldr	r0, [r3, #0]
        cyc = DWT->CYCCNT;
 80a350c:	4b54      	ldr	r3, [pc, #336]	; (80a3660 <_ZN17Adafruit_NeoPixel4showEv+0x8fc>)
      mask = 0x800000; // reset the mask
 80a350e:	f8cd e010 	str.w	lr, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a3512:	f8bd 200a 	ldrh.w	r2, [sp, #10]
      b = *ptr++;   // Next blue byte value
 80a3516:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a3518:	3a03      	subs	r2, #3
 80a351a:	b292      	uxth	r2, r2
 80a351c:	f8ad 200a 	strh.w	r2, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a3520:	f811 2c03 	ldrb.w	r2, [r1, #-3]
 80a3524:	b2d2      	uxtb	r2, r2
 80a3526:	f88d 2006 	strb.w	r2, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a352a:	f811 2c02 	ldrb.w	r2, [r1, #-2]
 80a352e:	b2d2      	uxtb	r2, r2
 80a3530:	f88d 2007 	strb.w	r2, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a3534:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 80a3538:	b2d2      	uxtb	r2, r2
 80a353a:	f88d 2008 	strb.w	r2, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a353e:	f89d c006 	ldrb.w	ip, [sp, #6]
 80a3542:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80a3546:	f89d 7008 	ldrb.w	r7, [sp, #8]
 80a354a:	0212      	lsls	r2, r2, #8
 80a354c:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 80a3550:	433a      	orrs	r2, r7
 80a3552:	9203      	str	r2, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a3554:	f88d 6005 	strb.w	r6, [sp, #5]
        pinSet(pin, HIGH); // HIGH
 80a3558:	79e2      	ldrb	r2, [r4, #7]
        cyc = DWT->CYCCNT;
 80a355a:	685d      	ldr	r5, [r3, #4]
        pinSet(pin, HIGH); // HIGH
 80a355c:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a3560:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a3564:	88bf      	ldrh	r7, [r7, #4]
 80a3566:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
        cyc = DWT->CYCCNT;
 80a356a:	9505      	str	r5, [sp, #20]
        pinSet(pin, HIGH); // HIGH
 80a356c:	8317      	strh	r7, [r2, #24]
        if (c & mask) { // if masked bit is high
 80a356e:	9f03      	ldr	r7, [sp, #12]
 80a3570:	9a04      	ldr	r2, [sp, #16]
 80a3572:	4217      	tst	r7, r2
 80a3574:	d025      	beq.n	80a35c2 <_ZN17Adafruit_NeoPixel4showEv+0x85e>
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a3576:	685a      	ldr	r2, [r3, #4]
 80a3578:	9f05      	ldr	r7, [sp, #20]
 80a357a:	1bd2      	subs	r2, r2, r7
 80a357c:	2a4f      	cmp	r2, #79	; 0x4f
 80a357e:	d9fa      	bls.n	80a3576 <_ZN17Adafruit_NeoPixel4showEv+0x812>
          pinSet(pin, LOW);
 80a3580:	79e2      	ldrb	r2, [r4, #7]
 80a3582:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a3586:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a358a:	88bf      	ldrh	r7, [r7, #4]
 80a358c:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80a3590:	8357      	strh	r7, [r2, #26]
          cyc = DWT->CYCCNT;
 80a3592:	685a      	ldr	r2, [r3, #4]
 80a3594:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
 80a3596:	685a      	ldr	r2, [r3, #4]
 80a3598:	9f05      	ldr	r7, [sp, #20]
 80a359a:	1bd2      	subs	r2, r2, r7
 80a359c:	2a07      	cmp	r2, #7
 80a359e:	d9fa      	bls.n	80a3596 <_ZN17Adafruit_NeoPixel4showEv+0x832>
        mask >>= 1;
 80a35a0:	9a04      	ldr	r2, [sp, #16]
 80a35a2:	0852      	lsrs	r2, r2, #1
 80a35a4:	9204      	str	r2, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a35a6:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a35aa:	3201      	adds	r2, #1
 80a35ac:	b2d2      	uxtb	r2, r2
 80a35ae:	2a17      	cmp	r2, #23
 80a35b0:	f88d 2005 	strb.w	r2, [sp, #5]
 80a35b4:	d9d0      	bls.n	80a3558 <_ZN17Adafruit_NeoPixel4showEv+0x7f4>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a35b6:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a35ba:	b292      	uxth	r2, r2
 80a35bc:	2a00      	cmp	r2, #0
 80a35be:	d1a6      	bne.n	80a350e <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
 80a35c0:	e797      	b.n	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
 80a35c2:	685a      	ldr	r2, [r3, #4]
 80a35c4:	9f05      	ldr	r7, [sp, #20]
 80a35c6:	1bd2      	subs	r2, r2, r7
 80a35c8:	2a18      	cmp	r2, #24
 80a35ca:	d9fa      	bls.n	80a35c2 <_ZN17Adafruit_NeoPixel4showEv+0x85e>
          pinSet(pin, LOW);
 80a35cc:	79e2      	ldrb	r2, [r4, #7]
 80a35ce:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a35d2:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a35d6:	88bf      	ldrh	r7, [r7, #4]
 80a35d8:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80a35dc:	8357      	strh	r7, [r2, #26]
          cyc = DWT->CYCCNT;
 80a35de:	685a      	ldr	r2, [r3, #4]
 80a35e0:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
 80a35e2:	685a      	ldr	r2, [r3, #4]
 80a35e4:	9f05      	ldr	r7, [sp, #20]
 80a35e6:	1bd2      	subs	r2, r2, r7
 80a35e8:	2a45      	cmp	r2, #69	; 0x45
 80a35ea:	d9fa      	bls.n	80a35e2 <_ZN17Adafruit_NeoPixel4showEv+0x87e>
 80a35ec:	e7d8      	b.n	80a35a0 <_ZN17Adafruit_NeoPixel4showEv+0x83c>
 80a35ee:	4770      	bx	lr
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a35f0:	2b00      	cmp	r3, #0
 80a35f2:	f43f af7e 	beq.w	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x80000000; // reset the mask
 80a35f6:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
      j = 0;        // reset the 32-bit counter
 80a35fa:	2600      	movs	r6, #0
 80a35fc:	4a17      	ldr	r2, [pc, #92]	; (80a365c <_ZN17Adafruit_NeoPixel4showEv+0x8f8>)
      mask = 0x80000000; // reset the mask
 80a35fe:	9504      	str	r5, [sp, #16]
      i = i-4;      // decrement bytes remaining
 80a3600:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      w = *ptr++;   // Next white byte value
 80a3604:	3104      	adds	r1, #4
      i = i-4;      // decrement bytes remaining
 80a3606:	3b04      	subs	r3, #4
 80a3608:	b29b      	uxth	r3, r3
 80a360a:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a360e:	f811 3c04 	ldrb.w	r3, [r1, #-4]
 80a3612:	b2db      	uxtb	r3, r3
 80a3614:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a3618:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a361c:	b2db      	uxtb	r3, r3
 80a361e:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a3622:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a3626:	b2db      	uxtb	r3, r3
 80a3628:	f88d 3008 	strb.w	r3, [sp, #8]
      w = *ptr++;   // Next white byte value
 80a362c:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a3630:	b2db      	uxtb	r3, r3
 80a3632:	f88d 3009 	strb.w	r3, [sp, #9]
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
 80a3636:	f89d c007 	ldrb.w	ip, [sp, #7]
 80a363a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a363e:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a3642:	041b      	lsls	r3, r3, #16
 80a3644:	f89d 7009 	ldrb.w	r7, [sp, #9]
 80a3648:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
 80a364c:	433b      	orrs	r3, r7
 80a364e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80a3652:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 32-bit counter
 80a3654:	f88d 6005 	strb.w	r6, [sp, #5]
 80a3658:	e07f      	b.n	80a375a <_ZN17Adafruit_NeoPixel4showEv+0x9f6>
 80a365a:	bf00      	nop
 80a365c:	20001624 	.word	0x20001624
 80a3660:	e0001000 	.word	0xe0001000
            ::: "r0", "cc", "memory");
 80a3664:	4600      	mov	r0, r0
 80a3666:	bf00      	nop
 80a3668:	bf00      	nop
 80a366a:	bf00      	nop
 80a366c:	bf00      	nop
 80a366e:	bf00      	nop
 80a3670:	bf00      	nop
 80a3672:	bf00      	nop
 80a3674:	bf00      	nop
 80a3676:	bf00      	nop
 80a3678:	bf00      	nop
 80a367a:	bf00      	nop
 80a367c:	bf00      	nop
 80a367e:	bf00      	nop
 80a3680:	bf00      	nop
 80a3682:	bf00      	nop
 80a3684:	bf00      	nop
 80a3686:	bf00      	nop
 80a3688:	bf00      	nop
 80a368a:	bf00      	nop
 80a368c:	bf00      	nop
 80a368e:	bf00      	nop
 80a3690:	bf00      	nop
 80a3692:	bf00      	nop
 80a3694:	bf00      	nop
 80a3696:	bf00      	nop
 80a3698:	bf00      	nop
 80a369a:	bf00      	nop
 80a369c:	bf00      	nop
 80a369e:	bf00      	nop
 80a36a0:	bf00      	nop
 80a36a2:	bf00      	nop
 80a36a4:	bf00      	nop
 80a36a6:	bf00      	nop
 80a36a8:	bf00      	nop
 80a36aa:	bf00      	nop
 80a36ac:	bf00      	nop
 80a36ae:	bf00      	nop
 80a36b0:	bf00      	nop
 80a36b2:	bf00      	nop
 80a36b4:	bf00      	nop
 80a36b6:	bf00      	nop
 80a36b8:	bf00      	nop
 80a36ba:	bf00      	nop
 80a36bc:	bf00      	nop
 80a36be:	bf00      	nop
 80a36c0:	bf00      	nop
 80a36c2:	bf00      	nop
 80a36c4:	bf00      	nop
 80a36c6:	bf00      	nop
 80a36c8:	bf00      	nop
 80a36ca:	bf00      	nop
 80a36cc:	bf00      	nop
 80a36ce:	bf00      	nop
 80a36d0:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a36d2:	79e3      	ldrb	r3, [r4, #7]
 80a36d4:	6810      	ldr	r0, [r2, #0]
 80a36d6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a36da:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a36de:	88bf      	ldrh	r7, [r7, #4]
 80a36e0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a36e4:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a36e6:	4600      	mov	r0, r0
 80a36e8:	bf00      	nop
 80a36ea:	bf00      	nop
 80a36ec:	bf00      	nop
 80a36ee:	bf00      	nop
 80a36f0:	bf00      	nop
 80a36f2:	bf00      	nop
 80a36f4:	bf00      	nop
 80a36f6:	bf00      	nop
 80a36f8:	bf00      	nop
 80a36fa:	bf00      	nop
 80a36fc:	bf00      	nop
 80a36fe:	bf00      	nop
 80a3700:	bf00      	nop
 80a3702:	bf00      	nop
 80a3704:	bf00      	nop
 80a3706:	bf00      	nop
 80a3708:	bf00      	nop
 80a370a:	bf00      	nop
 80a370c:	bf00      	nop
 80a370e:	bf00      	nop
 80a3710:	bf00      	nop
 80a3712:	bf00      	nop
 80a3714:	bf00      	nop
 80a3716:	bf00      	nop
 80a3718:	bf00      	nop
 80a371a:	bf00      	nop
 80a371c:	bf00      	nop
 80a371e:	bf00      	nop
 80a3720:	bf00      	nop
 80a3722:	bf00      	nop
 80a3724:	bf00      	nop
 80a3726:	bf00      	nop
 80a3728:	bf00      	nop
 80a372a:	bf00      	nop
 80a372c:	bf00      	nop
 80a372e:	bf00      	nop
 80a3730:	bf00      	nop
 80a3732:	bf00      	nop
 80a3734:	bf00      	nop
 80a3736:	bf00      	nop
 80a3738:	bf00      	nop
 80a373a:	bf00      	nop
 80a373c:	bf00      	nop
 80a373e:	bf00      	nop
 80a3740:	bf00      	nop
 80a3742:	bf00      	nop
        mask >>= 1;
 80a3744:	9b04      	ldr	r3, [sp, #16]
 80a3746:	085b      	lsrs	r3, r3, #1
 80a3748:	9304      	str	r3, [sp, #16]
      } while ( ++j < 32 ); // ... pixel done
 80a374a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a374e:	3301      	adds	r3, #1
 80a3750:	b2db      	uxtb	r3, r3
 80a3752:	2b1f      	cmp	r3, #31
 80a3754:	f88d 3005 	strb.w	r3, [sp, #5]
 80a3758:	d87e      	bhi.n	80a3858 <_ZN17Adafruit_NeoPixel4showEv+0xaf4>
        pinSet(pin, HIGH); // HIGH
 80a375a:	79e3      	ldrb	r3, [r4, #7]
 80a375c:	6810      	ldr	r0, [r2, #0]
 80a375e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3762:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3766:	88bf      	ldrh	r7, [r7, #4]
 80a3768:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a376c:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a376e:	9803      	ldr	r0, [sp, #12]
 80a3770:	9b04      	ldr	r3, [sp, #16]
 80a3772:	4218      	tst	r0, r3
 80a3774:	f47f af76 	bne.w	80a3664 <_ZN17Adafruit_NeoPixel4showEv+0x900>
            ::: "r0", "cc", "memory");
 80a3778:	4600      	mov	r0, r0
 80a377a:	bf00      	nop
 80a377c:	bf00      	nop
 80a377e:	bf00      	nop
 80a3780:	bf00      	nop
 80a3782:	bf00      	nop
 80a3784:	bf00      	nop
 80a3786:	bf00      	nop
 80a3788:	bf00      	nop
 80a378a:	bf00      	nop
 80a378c:	bf00      	nop
 80a378e:	bf00      	nop
 80a3790:	bf00      	nop
 80a3792:	bf00      	nop
 80a3794:	bf00      	nop
 80a3796:	bf00      	nop
 80a3798:	bf00      	nop
 80a379a:	bf00      	nop
 80a379c:	bf00      	nop
 80a379e:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a37a0:	79e3      	ldrb	r3, [r4, #7]
 80a37a2:	6810      	ldr	r0, [r2, #0]
 80a37a4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a37a8:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a37ac:	88bf      	ldrh	r7, [r7, #4]
 80a37ae:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a37b2:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a37b4:	4600      	mov	r0, r0
 80a37b6:	bf00      	nop
 80a37b8:	bf00      	nop
 80a37ba:	bf00      	nop
 80a37bc:	bf00      	nop
 80a37be:	bf00      	nop
 80a37c0:	bf00      	nop
 80a37c2:	bf00      	nop
 80a37c4:	bf00      	nop
 80a37c6:	bf00      	nop
 80a37c8:	bf00      	nop
 80a37ca:	bf00      	nop
 80a37cc:	bf00      	nop
 80a37ce:	bf00      	nop
 80a37d0:	bf00      	nop
 80a37d2:	bf00      	nop
 80a37d4:	bf00      	nop
 80a37d6:	bf00      	nop
 80a37d8:	bf00      	nop
 80a37da:	bf00      	nop
 80a37dc:	bf00      	nop
 80a37de:	bf00      	nop
 80a37e0:	bf00      	nop
 80a37e2:	bf00      	nop
 80a37e4:	bf00      	nop
 80a37e6:	bf00      	nop
 80a37e8:	bf00      	nop
 80a37ea:	bf00      	nop
 80a37ec:	bf00      	nop
 80a37ee:	bf00      	nop
 80a37f0:	bf00      	nop
 80a37f2:	bf00      	nop
 80a37f4:	bf00      	nop
 80a37f6:	bf00      	nop
 80a37f8:	bf00      	nop
 80a37fa:	bf00      	nop
 80a37fc:	bf00      	nop
 80a37fe:	bf00      	nop
 80a3800:	bf00      	nop
 80a3802:	bf00      	nop
 80a3804:	bf00      	nop
 80a3806:	bf00      	nop
 80a3808:	bf00      	nop
 80a380a:	bf00      	nop
 80a380c:	bf00      	nop
 80a380e:	bf00      	nop
 80a3810:	bf00      	nop
 80a3812:	bf00      	nop
 80a3814:	bf00      	nop
 80a3816:	bf00      	nop
 80a3818:	bf00      	nop
 80a381a:	bf00      	nop
 80a381c:	bf00      	nop
 80a381e:	bf00      	nop
 80a3820:	bf00      	nop
 80a3822:	bf00      	nop
 80a3824:	bf00      	nop
 80a3826:	bf00      	nop
 80a3828:	bf00      	nop
 80a382a:	bf00      	nop
 80a382c:	bf00      	nop
 80a382e:	bf00      	nop
 80a3830:	bf00      	nop
 80a3832:	bf00      	nop
 80a3834:	bf00      	nop
 80a3836:	bf00      	nop
 80a3838:	bf00      	nop
 80a383a:	bf00      	nop
 80a383c:	bf00      	nop
 80a383e:	bf00      	nop
 80a3840:	bf00      	nop
 80a3842:	bf00      	nop
 80a3844:	bf00      	nop
 80a3846:	bf00      	nop
 80a3848:	bf00      	nop
 80a384a:	bf00      	nop
 80a384c:	bf00      	nop
 80a384e:	bf00      	nop
 80a3850:	bf00      	nop
 80a3852:	bf00      	nop
 80a3854:	bf00      	nop
 80a3856:	e775      	b.n	80a3744 <_ZN17Adafruit_NeoPixel4showEv+0x9e0>
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a3858:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a385c:	b29b      	uxth	r3, r3
 80a385e:	2b00      	cmp	r3, #0
 80a3860:	f47f aecd 	bne.w	80a35fe <_ZN17Adafruit_NeoPixel4showEv+0x89a>
 80a3864:	e645      	b.n	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
 80a3866:	2d03      	cmp	r5, #3
 80a3868:	f000 812b 	beq.w	80a3ac2 <_ZN17Adafruit_NeoPixel4showEv+0xd5e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a386c:	2b00      	cmp	r3, #0
 80a386e:	f43f ae40 	beq.w	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a3872:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a3876:	2600      	movs	r6, #0
 80a3878:	4a17      	ldr	r2, [pc, #92]	; (80a38d8 <_ZN17Adafruit_NeoPixel4showEv+0xb74>)
      mask = 0x800000; // reset the mask
 80a387a:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a387c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      pinSet(pin, LOW); // LOW
 80a3880:	79e0      	ldrb	r0, [r4, #7]
      i = i-3;      // decrement bytes remaining
 80a3882:	3b03      	subs	r3, #3
 80a3884:	b29b      	uxth	r3, r3
 80a3886:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a388a:	780b      	ldrb	r3, [r1, #0]
      pinSet(pin, LOW); // LOW
 80a388c:	6817      	ldr	r7, [r2, #0]
      r = *ptr++;   // Next red byte value
 80a388e:	b2db      	uxtb	r3, r3
 80a3890:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a3894:	784b      	ldrb	r3, [r1, #1]
      pinSet(pin, LOW); // LOW
 80a3896:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
      b = *ptr++;   // Next blue byte value
 80a389a:	b2db      	uxtb	r3, r3
 80a389c:	f88d 3008 	strb.w	r3, [sp, #8]
      g = *ptr++;   // Next green byte value
 80a38a0:	788b      	ldrb	r3, [r1, #2]
      pinSet(pin, LOW); // LOW
 80a38a2:	eb07 0c80 	add.w	ip, r7, r0, lsl #2
      g = *ptr++;   // Next green byte value
 80a38a6:	b2db      	uxtb	r3, r3
 80a38a8:	f88d 3006 	strb.w	r3, [sp, #6]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a38ac:	f89d e007 	ldrb.w	lr, [sp, #7]
 80a38b0:	f89d 3008 	ldrb.w	r3, [sp, #8]
      pinSet(pin, LOW); // LOW
 80a38b4:	f8bc c004 	ldrh.w	ip, [ip, #4]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a38b8:	021b      	lsls	r3, r3, #8
 80a38ba:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 80a38be:	f89d e006 	ldrb.w	lr, [sp, #6]
      pinSet(pin, LOW); // LOW
 80a38c2:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a38c6:	ea43 030e 	orr.w	r3, r3, lr
 80a38ca:	9303      	str	r3, [sp, #12]
      g = *ptr++;   // Next green byte value
 80a38cc:	3103      	adds	r1, #3
      j = 0;        // reset the 24-bit counter
 80a38ce:	f88d 6005 	strb.w	r6, [sp, #5]
      pinSet(pin, LOW); // LOW
 80a38d2:	f8a0 c01a 	strh.w	ip, [r0, #26]
 80a38d6:	e07c      	b.n	80a39d2 <_ZN17Adafruit_NeoPixel4showEv+0xc6e>
 80a38d8:	20001624 	.word	0x20001624
          mask >>= 1; // Do this task during the long delay of this bit
 80a38dc:	9b04      	ldr	r3, [sp, #16]
 80a38de:	085b      	lsrs	r3, r3, #1
 80a38e0:	9304      	str	r3, [sp, #16]
            ::: "r0", "cc", "memory");
 80a38e2:	4600      	mov	r0, r0
 80a38e4:	bf00      	nop
 80a38e6:	bf00      	nop
 80a38e8:	bf00      	nop
 80a38ea:	bf00      	nop
 80a38ec:	bf00      	nop
 80a38ee:	bf00      	nop
 80a38f0:	bf00      	nop
 80a38f2:	bf00      	nop
 80a38f4:	bf00      	nop
 80a38f6:	bf00      	nop
 80a38f8:	bf00      	nop
 80a38fa:	bf00      	nop
 80a38fc:	bf00      	nop
 80a38fe:	bf00      	nop
 80a3900:	bf00      	nop
 80a3902:	bf00      	nop
 80a3904:	bf00      	nop
 80a3906:	bf00      	nop
 80a3908:	bf00      	nop
 80a390a:	bf00      	nop
 80a390c:	bf00      	nop
 80a390e:	bf00      	nop
 80a3910:	bf00      	nop
 80a3912:	bf00      	nop
 80a3914:	bf00      	nop
 80a3916:	bf00      	nop
 80a3918:	bf00      	nop
 80a391a:	bf00      	nop
 80a391c:	bf00      	nop
 80a391e:	bf00      	nop
 80a3920:	bf00      	nop
 80a3922:	bf00      	nop
 80a3924:	bf00      	nop
 80a3926:	bf00      	nop
 80a3928:	bf00      	nop
 80a392a:	bf00      	nop
 80a392c:	bf00      	nop
 80a392e:	bf00      	nop
 80a3930:	bf00      	nop
 80a3932:	bf00      	nop
 80a3934:	bf00      	nop
 80a3936:	bf00      	nop
 80a3938:	bf00      	nop
 80a393a:	bf00      	nop
 80a393c:	bf00      	nop
 80a393e:	bf00      	nop
 80a3940:	bf00      	nop
 80a3942:	bf00      	nop
 80a3944:	bf00      	nop
 80a3946:	bf00      	nop
 80a3948:	bf00      	nop
 80a394a:	bf00      	nop
 80a394c:	bf00      	nop
 80a394e:	bf00      	nop
 80a3950:	bf00      	nop
 80a3952:	bf00      	nop
 80a3954:	bf00      	nop
 80a3956:	bf00      	nop
 80a3958:	bf00      	nop
 80a395a:	bf00      	nop
 80a395c:	bf00      	nop
 80a395e:	bf00      	nop
 80a3960:	bf00      	nop
 80a3962:	bf00      	nop
 80a3964:	bf00      	nop
 80a3966:	bf00      	nop
          pinSet(pin, HIGH); // HIGH
 80a3968:	79e0      	ldrb	r0, [r4, #7]
 80a396a:	6817      	ldr	r7, [r2, #0]
          j++;
 80a396c:	f89d 3005 	ldrb.w	r3, [sp, #5]
          pinSet(pin, HIGH); // HIGH
 80a3970:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a3974:	eb07 0c80 	add.w	ip, r7, r0, lsl #2
 80a3978:	f8bc c004 	ldrh.w	ip, [ip, #4]
 80a397c:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
          j++;
 80a3980:	3301      	adds	r3, #1
 80a3982:	b2db      	uxtb	r3, r3
 80a3984:	f88d 3005 	strb.w	r3, [sp, #5]
          pinSet(pin, HIGH); // HIGH
 80a3988:	f8a0 c018 	strh.w	ip, [r0, #24]
            ::: "r0", "cc", "memory");
 80a398c:	4600      	mov	r0, r0
 80a398e:	bf00      	nop
 80a3990:	bf00      	nop
 80a3992:	bf00      	nop
 80a3994:	bf00      	nop
 80a3996:	bf00      	nop
 80a3998:	bf00      	nop
 80a399a:	bf00      	nop
 80a399c:	bf00      	nop
 80a399e:	bf00      	nop
 80a39a0:	bf00      	nop
 80a39a2:	bf00      	nop
 80a39a4:	bf00      	nop
 80a39a6:	bf00      	nop
 80a39a8:	bf00      	nop
 80a39aa:	bf00      	nop
 80a39ac:	bf00      	nop
 80a39ae:	bf00      	nop
 80a39b0:	bf00      	nop
 80a39b2:	bf00      	nop
 80a39b4:	bf00      	nop
          if(j==24) break;
 80a39b6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a39ba:	2b18      	cmp	r3, #24
 80a39bc:	d07a      	beq.n	80a3ab4 <_ZN17Adafruit_NeoPixel4showEv+0xd50>
          pinSet(pin, LOW); // LOW
 80a39be:	79e3      	ldrb	r3, [r4, #7]
 80a39c0:	6810      	ldr	r0, [r2, #0]
 80a39c2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a39c6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a39ca:	88bf      	ldrh	r7, [r7, #4]
 80a39cc:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a39d0:	835f      	strh	r7, [r3, #26]
        if (c & mask) { // if masked bit is high
 80a39d2:	9803      	ldr	r0, [sp, #12]
 80a39d4:	9b04      	ldr	r3, [sp, #16]
 80a39d6:	4218      	tst	r0, r3
 80a39d8:	d180      	bne.n	80a38dc <_ZN17Adafruit_NeoPixel4showEv+0xb78>
            ::: "r0", "cc", "memory");
 80a39da:	4600      	mov	r0, r0
 80a39dc:	bf00      	nop
 80a39de:	bf00      	nop
 80a39e0:	bf00      	nop
 80a39e2:	bf00      	nop
 80a39e4:	bf00      	nop
 80a39e6:	bf00      	nop
 80a39e8:	bf00      	nop
 80a39ea:	bf00      	nop
 80a39ec:	bf00      	nop
 80a39ee:	bf00      	nop
 80a39f0:	bf00      	nop
 80a39f2:	bf00      	nop
 80a39f4:	bf00      	nop
 80a39f6:	bf00      	nop
 80a39f8:	bf00      	nop
 80a39fa:	bf00      	nop
          pinSet(pin, HIGH); // HIGH
 80a39fc:	79e3      	ldrb	r3, [r4, #7]
 80a39fe:	6810      	ldr	r0, [r2, #0]
 80a3a00:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3a04:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3a08:	88bf      	ldrh	r7, [r7, #4]
 80a3a0a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3a0e:	831f      	strh	r7, [r3, #24]
          j++;
 80a3a10:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3a14:	3301      	adds	r3, #1
 80a3a16:	b2db      	uxtb	r3, r3
 80a3a18:	f88d 3005 	strb.w	r3, [sp, #5]
          mask >>= 1; // Do this task during the long delay of this bit
 80a3a1c:	9b04      	ldr	r3, [sp, #16]
 80a3a1e:	085b      	lsrs	r3, r3, #1
 80a3a20:	9304      	str	r3, [sp, #16]
            ::: "r0", "cc", "memory");
 80a3a22:	4600      	mov	r0, r0
 80a3a24:	bf00      	nop
 80a3a26:	bf00      	nop
 80a3a28:	bf00      	nop
 80a3a2a:	bf00      	nop
 80a3a2c:	bf00      	nop
 80a3a2e:	bf00      	nop
 80a3a30:	bf00      	nop
 80a3a32:	bf00      	nop
 80a3a34:	bf00      	nop
 80a3a36:	bf00      	nop
 80a3a38:	bf00      	nop
 80a3a3a:	bf00      	nop
 80a3a3c:	bf00      	nop
 80a3a3e:	bf00      	nop
 80a3a40:	bf00      	nop
 80a3a42:	bf00      	nop
 80a3a44:	bf00      	nop
 80a3a46:	bf00      	nop
 80a3a48:	bf00      	nop
 80a3a4a:	bf00      	nop
 80a3a4c:	bf00      	nop
 80a3a4e:	bf00      	nop
 80a3a50:	bf00      	nop
 80a3a52:	bf00      	nop
 80a3a54:	bf00      	nop
 80a3a56:	bf00      	nop
 80a3a58:	bf00      	nop
 80a3a5a:	bf00      	nop
 80a3a5c:	bf00      	nop
 80a3a5e:	bf00      	nop
 80a3a60:	bf00      	nop
 80a3a62:	bf00      	nop
 80a3a64:	bf00      	nop
 80a3a66:	bf00      	nop
 80a3a68:	bf00      	nop
 80a3a6a:	bf00      	nop
 80a3a6c:	bf00      	nop
 80a3a6e:	bf00      	nop
 80a3a70:	bf00      	nop
 80a3a72:	bf00      	nop
 80a3a74:	bf00      	nop
 80a3a76:	bf00      	nop
 80a3a78:	bf00      	nop
 80a3a7a:	bf00      	nop
 80a3a7c:	bf00      	nop
 80a3a7e:	bf00      	nop
 80a3a80:	bf00      	nop
 80a3a82:	bf00      	nop
 80a3a84:	bf00      	nop
 80a3a86:	bf00      	nop
 80a3a88:	bf00      	nop
 80a3a8a:	bf00      	nop
 80a3a8c:	bf00      	nop
 80a3a8e:	bf00      	nop
 80a3a90:	bf00      	nop
 80a3a92:	bf00      	nop
 80a3a94:	bf00      	nop
 80a3a96:	bf00      	nop
 80a3a98:	bf00      	nop
 80a3a9a:	bf00      	nop
 80a3a9c:	bf00      	nop
 80a3a9e:	bf00      	nop
 80a3aa0:	bf00      	nop
 80a3aa2:	bf00      	nop
 80a3aa4:	bf00      	nop
 80a3aa6:	bf00      	nop
 80a3aa8:	bf00      	nop
 80a3aaa:	bf00      	nop
          if(j==24) break;
 80a3aac:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3ab0:	2b18      	cmp	r3, #24
 80a3ab2:	d184      	bne.n	80a39be <_ZN17Adafruit_NeoPixel4showEv+0xc5a>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3ab4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3ab8:	b29b      	uxth	r3, r3
 80a3aba:	2b00      	cmp	r3, #0
 80a3abc:	f47f aedd 	bne.w	80a387a <_ZN17Adafruit_NeoPixel4showEv+0xb16>
 80a3ac0:	e517      	b.n	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3ac2:	2b00      	cmp	r3, #0
 80a3ac4:	f43f ad15 	beq.w	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a3ac8:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a3acc:	2600      	movs	r6, #0
 80a3ace:	4a13      	ldr	r2, [pc, #76]	; (80a3b1c <_ZN17Adafruit_NeoPixel4showEv+0xdb8>)
      mask = 0x800000; // reset the mask
 80a3ad0:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a3ad2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      b = *ptr++;   // Next green byte value
 80a3ad6:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a3ad8:	3b03      	subs	r3, #3
 80a3ada:	b29b      	uxth	r3, r3
 80a3adc:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a3ae0:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a3ae4:	b2db      	uxtb	r3, r3
 80a3ae6:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next blue byte value
 80a3aea:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a3aee:	b2db      	uxtb	r3, r3
 80a3af0:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next green byte value
 80a3af4:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a3af8:	b2db      	uxtb	r3, r3
 80a3afa:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a3afe:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a3b02:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a3b06:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a3b0a:	021b      	lsls	r3, r3, #8
 80a3b0c:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a3b10:	4303      	orrs	r3, r0
 80a3b12:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a3b14:	f88d 6005 	strb.w	r6, [sp, #5]
 80a3b18:	e0e1      	b.n	80a3cde <_ZN17Adafruit_NeoPixel4showEv+0xf7a>
 80a3b1a:	bf00      	nop
 80a3b1c:	20001624 	.word	0x20001624
            ::: "r0", "cc", "memory");
 80a3b20:	4600      	mov	r0, r0
 80a3b22:	bf00      	nop
 80a3b24:	bf00      	nop
 80a3b26:	bf00      	nop
 80a3b28:	bf00      	nop
 80a3b2a:	bf00      	nop
 80a3b2c:	bf00      	nop
 80a3b2e:	bf00      	nop
 80a3b30:	bf00      	nop
 80a3b32:	bf00      	nop
 80a3b34:	bf00      	nop
 80a3b36:	bf00      	nop
 80a3b38:	bf00      	nop
 80a3b3a:	bf00      	nop
 80a3b3c:	bf00      	nop
 80a3b3e:	bf00      	nop
 80a3b40:	bf00      	nop
 80a3b42:	bf00      	nop
 80a3b44:	bf00      	nop
 80a3b46:	bf00      	nop
 80a3b48:	bf00      	nop
 80a3b4a:	bf00      	nop
 80a3b4c:	bf00      	nop
 80a3b4e:	bf00      	nop
 80a3b50:	bf00      	nop
 80a3b52:	bf00      	nop
 80a3b54:	bf00      	nop
 80a3b56:	bf00      	nop
 80a3b58:	bf00      	nop
 80a3b5a:	bf00      	nop
 80a3b5c:	bf00      	nop
 80a3b5e:	bf00      	nop
 80a3b60:	bf00      	nop
 80a3b62:	bf00      	nop
 80a3b64:	bf00      	nop
 80a3b66:	bf00      	nop
 80a3b68:	bf00      	nop
 80a3b6a:	bf00      	nop
 80a3b6c:	bf00      	nop
 80a3b6e:	bf00      	nop
 80a3b70:	bf00      	nop
 80a3b72:	bf00      	nop
 80a3b74:	bf00      	nop
 80a3b76:	bf00      	nop
 80a3b78:	bf00      	nop
 80a3b7a:	bf00      	nop
 80a3b7c:	bf00      	nop
 80a3b7e:	bf00      	nop
 80a3b80:	bf00      	nop
 80a3b82:	bf00      	nop
 80a3b84:	bf00      	nop
 80a3b86:	bf00      	nop
 80a3b88:	bf00      	nop
 80a3b8a:	bf00      	nop
 80a3b8c:	bf00      	nop
 80a3b8e:	bf00      	nop
 80a3b90:	bf00      	nop
 80a3b92:	bf00      	nop
 80a3b94:	bf00      	nop
 80a3b96:	bf00      	nop
 80a3b98:	bf00      	nop
 80a3b9a:	bf00      	nop
 80a3b9c:	bf00      	nop
 80a3b9e:	bf00      	nop
 80a3ba0:	bf00      	nop
 80a3ba2:	bf00      	nop
 80a3ba4:	bf00      	nop
 80a3ba6:	bf00      	nop
 80a3ba8:	bf00      	nop
 80a3baa:	bf00      	nop
 80a3bac:	bf00      	nop
 80a3bae:	bf00      	nop
 80a3bb0:	bf00      	nop
 80a3bb2:	bf00      	nop
 80a3bb4:	bf00      	nop
 80a3bb6:	bf00      	nop
 80a3bb8:	bf00      	nop
 80a3bba:	bf00      	nop
 80a3bbc:	bf00      	nop
 80a3bbe:	bf00      	nop
 80a3bc0:	bf00      	nop
 80a3bc2:	bf00      	nop
 80a3bc4:	bf00      	nop
 80a3bc6:	bf00      	nop
 80a3bc8:	bf00      	nop
 80a3bca:	bf00      	nop
 80a3bcc:	bf00      	nop
 80a3bce:	bf00      	nop
 80a3bd0:	bf00      	nop
 80a3bd2:	bf00      	nop
 80a3bd4:	bf00      	nop
 80a3bd6:	bf00      	nop
 80a3bd8:	bf00      	nop
 80a3bda:	bf00      	nop
 80a3bdc:	bf00      	nop
 80a3bde:	bf00      	nop
 80a3be0:	bf00      	nop
 80a3be2:	bf00      	nop
 80a3be4:	bf00      	nop
 80a3be6:	bf00      	nop
 80a3be8:	bf00      	nop
 80a3bea:	bf00      	nop
 80a3bec:	bf00      	nop
 80a3bee:	bf00      	nop
 80a3bf0:	bf00      	nop
 80a3bf2:	bf00      	nop
 80a3bf4:	bf00      	nop
 80a3bf6:	bf00      	nop
 80a3bf8:	bf00      	nop
 80a3bfa:	bf00      	nop
 80a3bfc:	bf00      	nop
 80a3bfe:	bf00      	nop
 80a3c00:	bf00      	nop
 80a3c02:	bf00      	nop
 80a3c04:	bf00      	nop
 80a3c06:	bf00      	nop
 80a3c08:	bf00      	nop
 80a3c0a:	bf00      	nop
 80a3c0c:	bf00      	nop
 80a3c0e:	bf00      	nop
 80a3c10:	bf00      	nop
 80a3c12:	bf00      	nop
 80a3c14:	bf00      	nop
 80a3c16:	bf00      	nop
 80a3c18:	bf00      	nop
 80a3c1a:	bf00      	nop
 80a3c1c:	bf00      	nop
 80a3c1e:	bf00      	nop
 80a3c20:	bf00      	nop
 80a3c22:	bf00      	nop
 80a3c24:	bf00      	nop
 80a3c26:	bf00      	nop
 80a3c28:	bf00      	nop
 80a3c2a:	bf00      	nop
 80a3c2c:	bf00      	nop
 80a3c2e:	bf00      	nop
 80a3c30:	bf00      	nop
 80a3c32:	bf00      	nop
 80a3c34:	bf00      	nop
 80a3c36:	bf00      	nop
 80a3c38:	bf00      	nop
 80a3c3a:	bf00      	nop
 80a3c3c:	bf00      	nop
 80a3c3e:	bf00      	nop
 80a3c40:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a3c42:	79e3      	ldrb	r3, [r4, #7]
 80a3c44:	6810      	ldr	r0, [r2, #0]
 80a3c46:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3c4a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3c4e:	88bf      	ldrh	r7, [r7, #4]
 80a3c50:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3c54:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a3c56:	4600      	mov	r0, r0
 80a3c58:	bf00      	nop
 80a3c5a:	bf00      	nop
 80a3c5c:	bf00      	nop
 80a3c5e:	bf00      	nop
 80a3c60:	bf00      	nop
 80a3c62:	bf00      	nop
 80a3c64:	bf00      	nop
 80a3c66:	bf00      	nop
 80a3c68:	bf00      	nop
 80a3c6a:	bf00      	nop
 80a3c6c:	bf00      	nop
 80a3c6e:	bf00      	nop
 80a3c70:	bf00      	nop
 80a3c72:	bf00      	nop
 80a3c74:	bf00      	nop
 80a3c76:	bf00      	nop
 80a3c78:	bf00      	nop
 80a3c7a:	bf00      	nop
 80a3c7c:	bf00      	nop
 80a3c7e:	bf00      	nop
 80a3c80:	bf00      	nop
 80a3c82:	bf00      	nop
 80a3c84:	bf00      	nop
 80a3c86:	bf00      	nop
 80a3c88:	bf00      	nop
 80a3c8a:	bf00      	nop
 80a3c8c:	bf00      	nop
 80a3c8e:	bf00      	nop
 80a3c90:	bf00      	nop
 80a3c92:	bf00      	nop
 80a3c94:	bf00      	nop
 80a3c96:	bf00      	nop
 80a3c98:	bf00      	nop
 80a3c9a:	bf00      	nop
 80a3c9c:	bf00      	nop
 80a3c9e:	bf00      	nop
 80a3ca0:	bf00      	nop
 80a3ca2:	bf00      	nop
 80a3ca4:	bf00      	nop
 80a3ca6:	bf00      	nop
 80a3ca8:	bf00      	nop
 80a3caa:	bf00      	nop
 80a3cac:	bf00      	nop
 80a3cae:	bf00      	nop
 80a3cb0:	bf00      	nop
 80a3cb2:	bf00      	nop
 80a3cb4:	bf00      	nop
 80a3cb6:	bf00      	nop
 80a3cb8:	bf00      	nop
 80a3cba:	bf00      	nop
 80a3cbc:	bf00      	nop
 80a3cbe:	bf00      	nop
 80a3cc0:	bf00      	nop
 80a3cc2:	bf00      	nop
 80a3cc4:	bf00      	nop
        mask >>= 1;
 80a3cc6:	9b04      	ldr	r3, [sp, #16]
 80a3cc8:	085b      	lsrs	r3, r3, #1
 80a3cca:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a3ccc:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3cd0:	3301      	adds	r3, #1
 80a3cd2:	b2db      	uxtb	r3, r3
 80a3cd4:	2b17      	cmp	r3, #23
 80a3cd6:	f88d 3005 	strb.w	r3, [sp, #5]
 80a3cda:	f200 80eb 	bhi.w	80a3eb4 <_ZN17Adafruit_NeoPixel4showEv+0x1150>
        pinSet(pin, HIGH); // HIGH
 80a3cde:	79e3      	ldrb	r3, [r4, #7]
 80a3ce0:	6810      	ldr	r0, [r2, #0]
 80a3ce2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3ce6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3cea:	88bf      	ldrh	r7, [r7, #4]
 80a3cec:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3cf0:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a3cf2:	9803      	ldr	r0, [sp, #12]
 80a3cf4:	9b04      	ldr	r3, [sp, #16]
 80a3cf6:	4218      	tst	r0, r3
 80a3cf8:	f47f af12 	bne.w	80a3b20 <_ZN17Adafruit_NeoPixel4showEv+0xdbc>
            ::: "r0", "cc", "memory");
 80a3cfc:	4600      	mov	r0, r0
 80a3cfe:	bf00      	nop
 80a3d00:	bf00      	nop
 80a3d02:	bf00      	nop
 80a3d04:	bf00      	nop
 80a3d06:	bf00      	nop
 80a3d08:	bf00      	nop
 80a3d0a:	bf00      	nop
 80a3d0c:	bf00      	nop
 80a3d0e:	bf00      	nop
 80a3d10:	bf00      	nop
 80a3d12:	bf00      	nop
 80a3d14:	bf00      	nop
 80a3d16:	bf00      	nop
 80a3d18:	bf00      	nop
 80a3d1a:	bf00      	nop
 80a3d1c:	bf00      	nop
 80a3d1e:	bf00      	nop
 80a3d20:	bf00      	nop
 80a3d22:	bf00      	nop
 80a3d24:	bf00      	nop
 80a3d26:	bf00      	nop
 80a3d28:	bf00      	nop
 80a3d2a:	bf00      	nop
 80a3d2c:	bf00      	nop
 80a3d2e:	bf00      	nop
 80a3d30:	bf00      	nop
 80a3d32:	bf00      	nop
 80a3d34:	bf00      	nop
 80a3d36:	bf00      	nop
 80a3d38:	bf00      	nop
 80a3d3a:	bf00      	nop
 80a3d3c:	bf00      	nop
 80a3d3e:	bf00      	nop
 80a3d40:	bf00      	nop
 80a3d42:	bf00      	nop
 80a3d44:	bf00      	nop
 80a3d46:	bf00      	nop
 80a3d48:	bf00      	nop
 80a3d4a:	bf00      	nop
 80a3d4c:	bf00      	nop
 80a3d4e:	bf00      	nop
 80a3d50:	bf00      	nop
 80a3d52:	bf00      	nop
 80a3d54:	bf00      	nop
 80a3d56:	bf00      	nop
 80a3d58:	bf00      	nop
 80a3d5a:	bf00      	nop
 80a3d5c:	bf00      	nop
 80a3d5e:	bf00      	nop
 80a3d60:	bf00      	nop
 80a3d62:	bf00      	nop
 80a3d64:	bf00      	nop
 80a3d66:	bf00      	nop
 80a3d68:	bf00      	nop
 80a3d6a:	bf00      	nop
 80a3d6c:	bf00      	nop
 80a3d6e:	bf00      	nop
 80a3d70:	bf00      	nop
 80a3d72:	bf00      	nop
 80a3d74:	bf00      	nop
 80a3d76:	bf00      	nop
 80a3d78:	bf00      	nop
 80a3d7a:	bf00      	nop
 80a3d7c:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a3d7e:	79e3      	ldrb	r3, [r4, #7]
 80a3d80:	6810      	ldr	r0, [r2, #0]
 80a3d82:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3d86:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3d8a:	88bf      	ldrh	r7, [r7, #4]
 80a3d8c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3d90:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a3d92:	4600      	mov	r0, r0
 80a3d94:	bf00      	nop
 80a3d96:	bf00      	nop
 80a3d98:	bf00      	nop
 80a3d9a:	bf00      	nop
 80a3d9c:	bf00      	nop
 80a3d9e:	bf00      	nop
 80a3da0:	bf00      	nop
 80a3da2:	bf00      	nop
 80a3da4:	bf00      	nop
 80a3da6:	bf00      	nop
 80a3da8:	bf00      	nop
 80a3daa:	bf00      	nop
 80a3dac:	bf00      	nop
 80a3dae:	bf00      	nop
 80a3db0:	bf00      	nop
 80a3db2:	bf00      	nop
 80a3db4:	bf00      	nop
 80a3db6:	bf00      	nop
 80a3db8:	bf00      	nop
 80a3dba:	bf00      	nop
 80a3dbc:	bf00      	nop
 80a3dbe:	bf00      	nop
 80a3dc0:	bf00      	nop
 80a3dc2:	bf00      	nop
 80a3dc4:	bf00      	nop
 80a3dc6:	bf00      	nop
 80a3dc8:	bf00      	nop
 80a3dca:	bf00      	nop
 80a3dcc:	bf00      	nop
 80a3dce:	bf00      	nop
 80a3dd0:	bf00      	nop
 80a3dd2:	bf00      	nop
 80a3dd4:	bf00      	nop
 80a3dd6:	bf00      	nop
 80a3dd8:	bf00      	nop
 80a3dda:	bf00      	nop
 80a3ddc:	bf00      	nop
 80a3dde:	bf00      	nop
 80a3de0:	bf00      	nop
 80a3de2:	bf00      	nop
 80a3de4:	bf00      	nop
 80a3de6:	bf00      	nop
 80a3de8:	bf00      	nop
 80a3dea:	bf00      	nop
 80a3dec:	bf00      	nop
 80a3dee:	bf00      	nop
 80a3df0:	bf00      	nop
 80a3df2:	bf00      	nop
 80a3df4:	bf00      	nop
 80a3df6:	bf00      	nop
 80a3df8:	bf00      	nop
 80a3dfa:	bf00      	nop
 80a3dfc:	bf00      	nop
 80a3dfe:	bf00      	nop
 80a3e00:	bf00      	nop
 80a3e02:	bf00      	nop
 80a3e04:	bf00      	nop
 80a3e06:	bf00      	nop
 80a3e08:	bf00      	nop
 80a3e0a:	bf00      	nop
 80a3e0c:	bf00      	nop
 80a3e0e:	bf00      	nop
 80a3e10:	bf00      	nop
 80a3e12:	bf00      	nop
 80a3e14:	bf00      	nop
 80a3e16:	bf00      	nop
 80a3e18:	bf00      	nop
 80a3e1a:	bf00      	nop
 80a3e1c:	bf00      	nop
 80a3e1e:	bf00      	nop
 80a3e20:	bf00      	nop
 80a3e22:	bf00      	nop
 80a3e24:	bf00      	nop
 80a3e26:	bf00      	nop
 80a3e28:	bf00      	nop
 80a3e2a:	bf00      	nop
 80a3e2c:	bf00      	nop
 80a3e2e:	bf00      	nop
 80a3e30:	bf00      	nop
 80a3e32:	bf00      	nop
 80a3e34:	bf00      	nop
 80a3e36:	bf00      	nop
 80a3e38:	bf00      	nop
 80a3e3a:	bf00      	nop
 80a3e3c:	bf00      	nop
 80a3e3e:	bf00      	nop
 80a3e40:	bf00      	nop
 80a3e42:	bf00      	nop
 80a3e44:	bf00      	nop
 80a3e46:	bf00      	nop
 80a3e48:	bf00      	nop
 80a3e4a:	bf00      	nop
 80a3e4c:	bf00      	nop
 80a3e4e:	bf00      	nop
 80a3e50:	bf00      	nop
 80a3e52:	bf00      	nop
 80a3e54:	bf00      	nop
 80a3e56:	bf00      	nop
 80a3e58:	bf00      	nop
 80a3e5a:	bf00      	nop
 80a3e5c:	bf00      	nop
 80a3e5e:	bf00      	nop
 80a3e60:	bf00      	nop
 80a3e62:	bf00      	nop
 80a3e64:	bf00      	nop
 80a3e66:	bf00      	nop
 80a3e68:	bf00      	nop
 80a3e6a:	bf00      	nop
 80a3e6c:	bf00      	nop
 80a3e6e:	bf00      	nop
 80a3e70:	bf00      	nop
 80a3e72:	bf00      	nop
 80a3e74:	bf00      	nop
 80a3e76:	bf00      	nop
 80a3e78:	bf00      	nop
 80a3e7a:	bf00      	nop
 80a3e7c:	bf00      	nop
 80a3e7e:	bf00      	nop
 80a3e80:	bf00      	nop
 80a3e82:	bf00      	nop
 80a3e84:	bf00      	nop
 80a3e86:	bf00      	nop
 80a3e88:	bf00      	nop
 80a3e8a:	bf00      	nop
 80a3e8c:	bf00      	nop
 80a3e8e:	bf00      	nop
 80a3e90:	bf00      	nop
 80a3e92:	bf00      	nop
 80a3e94:	bf00      	nop
 80a3e96:	bf00      	nop
 80a3e98:	bf00      	nop
 80a3e9a:	bf00      	nop
 80a3e9c:	bf00      	nop
 80a3e9e:	bf00      	nop
 80a3ea0:	bf00      	nop
 80a3ea2:	e710      	b.n	80a3cc6 <_ZN17Adafruit_NeoPixel4showEv+0xf62>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3ea4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3ea8:	b29b      	uxth	r3, r3
 80a3eaa:	2b00      	cmp	r3, #0
 80a3eac:	f47e af92 	bne.w	80a2dd4 <_ZN17Adafruit_NeoPixel4showEv+0x70>
 80a3eb0:	f7ff bb1f 	b.w	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3eb4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3eb8:	b29b      	uxth	r3, r3
 80a3eba:	2b00      	cmp	r3, #0
 80a3ebc:	f47f ae08 	bne.w	80a3ad0 <_ZN17Adafruit_NeoPixel4showEv+0xd6c>
 80a3ec0:	f7ff bb17 	b.w	80a34f2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>

080a3ec4 <_ZN17Adafruit_NeoPixel13setPixelColorEtm>:
}

// Set pixel color from 'packed' 32-bit RGB color:
// If RGB+W color, order of bytes is WRGB in packed 32-bit form
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {
  if(n < numLEDs) {
 80a3ec4:	8843      	ldrh	r3, [r0, #2]
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {
 80a3ec6:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(n < numLEDs) {
 80a3ec8:	428b      	cmp	r3, r1
 80a3eca:	d926      	bls.n	80a3f1a <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>
    uint8_t
      r = (uint8_t)(c >> 16),
      g = (uint8_t)(c >>  8),
      b = (uint8_t)c;
    if(brightness) { // See notes in setBrightness()
 80a3ecc:	7a05      	ldrb	r5, [r0, #8]
 80a3ece:	f3c2 4307 	ubfx	r3, r2, #16, #8
 80a3ed2:	f3c2 2407 	ubfx	r4, r2, #8, #8
 80a3ed6:	b2d6      	uxtb	r6, r2
 80a3ed8:	b13d      	cbz	r5, 80a3eea <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x26>
      r = (r * brightness) >> 8;
 80a3eda:	436b      	muls	r3, r5
      g = (g * brightness) >> 8;
 80a3edc:	436c      	muls	r4, r5
      b = (b * brightness) >> 8;
 80a3ede:	436e      	muls	r6, r5
      r = (r * brightness) >> 8;
 80a3ee0:	f3c3 2307 	ubfx	r3, r3, #8, #8
      g = (g * brightness) >> 8;
 80a3ee4:	f3c4 2407 	ubfx	r4, r4, #8, #8
      b = (b * brightness) >> 8;
 80a3ee8:	0a36      	lsrs	r6, r6, #8
    }
    uint8_t *p = &pixels[n * (type==SK6812RGBW?4:3)];
 80a3eea:	f890 c006 	ldrb.w	ip, [r0, #6]
 80a3eee:	68c7      	ldr	r7, [r0, #12]
 80a3ef0:	f1bc 0f06 	cmp.w	ip, #6
 80a3ef4:	bf0c      	ite	eq
 80a3ef6:	2504      	moveq	r5, #4
 80a3ef8:	2503      	movne	r5, #3
 80a3efa:	4369      	muls	r1, r5
 80a3efc:	f1ac 0c02 	sub.w	ip, ip, #2
 80a3f00:	187d      	adds	r5, r7, r1
    switch(type) {
 80a3f02:	f1bc 0f06 	cmp.w	ip, #6
 80a3f06:	d81d      	bhi.n	80a3f44 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x80>
 80a3f08:	e8df f00c 	tbb	[pc, ip]
 80a3f0c:	04081c04 	.word	0x04081c04
 80a3f10:	040f      	.short	0x040f
 80a3f12:	04          	.byte	0x04
 80a3f13:	00          	.byte	0x00
      case WS2812B: // WS2812, WS2812B & WS2813 is GRB order.
      case WS2812B_FAST:
      case WS2812B2:
      case WS2812B2_FAST: {
          *p++ = g;
 80a3f14:	547c      	strb	r4, [r7, r1]
          *p++ = r;
 80a3f16:	706b      	strb	r3, [r5, #1]
          *p = b;
 80a3f18:	70ae      	strb	r6, [r5, #2]
          *p++ = g;
          *p = b;
        } break;
    }
  }
}
 80a3f1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
          *p++ = r;
 80a3f1c:	2bfe      	cmp	r3, #254	; 0xfe
 80a3f1e:	bf28      	it	cs
 80a3f20:	23fe      	movcs	r3, #254	; 0xfe
 80a3f22:	547b      	strb	r3, [r7, r1]
          *p++ = b;
 80a3f24:	706e      	strb	r6, [r5, #1]
          *p = g;
 80a3f26:	70ac      	strb	r4, [r5, #2]
        } break;
 80a3f28:	e7f7      	b.n	80a3f1a <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>
          *p++ = r;
 80a3f2a:	547b      	strb	r3, [r7, r1]
          *p++ = g;
 80a3f2c:	706c      	strb	r4, [r5, #1]
          *p++ = b;
 80a3f2e:	70ae      	strb	r6, [r5, #2]
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a3f30:	7a03      	ldrb	r3, [r0, #8]
          uint8_t w = (uint8_t)(c >> 24);
 80a3f32:	0e12      	lsrs	r2, r2, #24
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a3f34:	b913      	cbnz	r3, 80a3f3c <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x78>
          uint8_t w = (uint8_t)(c >> 24);
 80a3f36:	b2d2      	uxtb	r2, r2
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a3f38:	70ea      	strb	r2, [r5, #3]
        } break;
 80a3f3a:	e7ee      	b.n	80a3f1a <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a3f3c:	435a      	muls	r2, r3
 80a3f3e:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a3f42:	e7f9      	b.n	80a3f38 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x74>
          *p++ = r;
 80a3f44:	547b      	strb	r3, [r7, r1]
          *p++ = g;
 80a3f46:	706c      	strb	r4, [r5, #1]
          *p = b;
 80a3f48:	70ae      	strb	r6, [r5, #2]
}
 80a3f4a:	e7e6      	b.n	80a3f1a <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>

080a3f4c <_GLOBAL__sub_I_PIN_MAP2>:
  return brightness - 1;
}

void Adafruit_NeoPixel::clear(void) {
  memset(pixels, 0, numBytes);
}
 80a3f4c:	b508      	push	{r3, lr}
  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed
 80a3f4e:	f000 f907 	bl	80a4160 <HAL_Pin_Map>
 80a3f52:	4b01      	ldr	r3, [pc, #4]	; (80a3f58 <_GLOBAL__sub_I_PIN_MAP2+0xc>)
 80a3f54:	6018      	str	r0, [r3, #0]
}
 80a3f56:	bd08      	pop	{r3, pc}
 80a3f58:	20001624 	.word	0x20001624

080a3f5c <_ZN7SpeakerC1EPtS0_t>:

Speaker::Speaker(uint16_t *buffer0, uint16_t *buffer1, uint16_t bufferSize)
    : bufferSize(bufferSize) ,
    lastBuffer(0xFF),
    audioFrequency(8000),
    privateBuffer(false)
 80a3f5c:	8043      	strh	r3, [r0, #2]
 80a3f5e:	23ff      	movs	r3, #255	; 0xff
 80a3f60:	7103      	strb	r3, [r0, #4]
 80a3f62:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
Speaker::Speaker(uint16_t *buffer0, uint16_t *buffer1, uint16_t bufferSize)
 80a3f66:	b530      	push	{r4, r5, lr}
    privateBuffer(false)
 80a3f68:	80c3      	strh	r3, [r0, #6]
 80a3f6a:	2500      	movs	r5, #0
{
    numBuffers = (buffer0 == buffer1) ? 1 : 2;
 80a3f6c:	4291      	cmp	r1, r2
 80a3f6e:	bf0c      	ite	eq
 80a3f70:	2301      	moveq	r3, #1
 80a3f72:	2302      	movne	r3, #2
    buffer[0] = buffer0;
    buffer[1] = buffer1;
 80a3f74:	e9c0 1202 	strd	r1, r2, [r0, #8]
    privateBuffer(false)
 80a3f78:	7005      	strb	r5, [r0, #0]
    numBuffers = (buffer0 == buffer1) ? 1 : 2;
 80a3f7a:	7043      	strb	r3, [r0, #1]
}
 80a3f7c:	bd30      	pop	{r4, r5, pc}
	...

080a3f80 <_ZN7Speaker7setupHWEt>:
    this->audioFrequency = audioFrequency;
    setupHW(audioFrequency);
}

void Speaker::setupHW(uint16_t audioFrequency)
{
 80a3f80:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a3f82:	4606      	mov	r6, r0
 80a3f84:	b095      	sub	sp, #84	; 0x54
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6 | RCC_APB1Periph_DAC, ENABLE);
    /* DMA clock enable */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);

    /* DMA1 Stream5 channel7 configuration */
    DMA_DeInit(DMA1_Stream5);
 80a3f86:	4d38      	ldr	r5, [pc, #224]	; (80a4068 <_ZN7Speaker7setupHWEt+0xe8>)
{
 80a3f88:	460f      	mov	r7, r1
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6 | RCC_APB1Periph_DAC, ENABLE);
 80a3f8a:	4838      	ldr	r0, [pc, #224]	; (80a406c <_ZN7Speaker7setupHWEt+0xec>)
 80a3f8c:	2101      	movs	r1, #1
 80a3f8e:	f7fc f9d3 	bl	80a0338 <RCC_APB1PeriphClockCmd>
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
 80a3f92:	2101      	movs	r1, #1
 80a3f94:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80a3f98:	f7fc f9c2 	bl	80a0320 <RCC_AHB1PeriphClockCmd>
    DMA_DeInit(DMA1_Stream5);
 80a3f9c:	4628      	mov	r0, r5
 80a3f9e:	f7fc f8dd 	bl	80a015c <DMA_DeInit>

    DMA_InitTypeDef DMA_InitStructure;
    DMA_StructInit(&DMA_InitStructure);
 80a3fa2:	a805      	add	r0, sp, #20
 80a3fa4:	f7fc f98a 	bl	80a02bc <DMA_StructInit>
    DMA_InitStructure.DMA_BufferSize = bufferSize;
 80a3fa8:	8873      	ldrh	r3, [r6, #2]
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &_DAC->DHR12L1;
    DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer[0];
    DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 80a3faa:	2400      	movs	r4, #0
    DMA_InitStructure.DMA_BufferSize = bufferSize;
 80a3fac:	9309      	str	r3, [sp, #36]	; 0x24
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &_DAC->DHR12L1;
 80a3fae:	4b30      	ldr	r3, [pc, #192]	; (80a4070 <_ZN7Speaker7setupHWEt+0xf0>)
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 80a3fb0:	f44f 6200 	mov.w	r2, #2048	; 0x800
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &_DAC->DHR12L1;
 80a3fb4:	9306      	str	r3, [sp, #24]
    DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer[0];
 80a3fb6:	68b3      	ldr	r3, [r6, #8]
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 80a3fb8:	f44f 7180 	mov.w	r1, #256	; 0x100
    DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer[0];
 80a3fbc:	9307      	str	r3, [sp, #28]
    DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 80a3fbe:	2340      	movs	r3, #64	; 0x40
 80a3fc0:	9308      	str	r3, [sp, #32]
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 80a3fc2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80a3fc6:	e9cd 430a 	strd	r4, r3, [sp, #40]	; 0x28
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 80a3fca:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80a3fce:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 80a3fd2:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80a3fd6:	e9cd 130e 	strd	r1, r3, [sp, #56]	; 0x38
    DMA_InitStructure.DMA_Channel = DMA_Channel_7; // Stream5 Channel7 = DAC1
 80a3fda:	f04f 6360 	mov.w	r3, #234881024	; 0xe000000
    DMA_Init(DMA1_Stream5, &DMA_InitStructure);
 80a3fde:	4628      	mov	r0, r5
 80a3fe0:	a905      	add	r1, sp, #20
    DMA_InitStructure.DMA_Channel = DMA_Channel_7; // Stream5 Channel7 = DAC1
 80a3fe2:	9305      	str	r3, [sp, #20]
    DMA_Init(DMA1_Stream5, &DMA_InitStructure);
 80a3fe4:	f7fc f940 	bl	80a0268 <DMA_Init>

    /* Configure DMA1 Stream5 double buffering */
    DMA_DoubleBufferModeConfig(DMA1_Stream5, (uint32_t) buffer[1], DMA_Memory_1);
 80a3fe8:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80a3fec:	4628      	mov	r0, r5
 80a3fee:	68f1      	ldr	r1, [r6, #12]
 80a3ff0:	f7fc f97e 	bl	80a02f0 <DMA_DoubleBufferModeConfig>
    DMA_DoubleBufferModeCmd(DMA1_Stream5, ENABLE);
 80a3ff4:	4628      	mov	r0, r5
 80a3ff6:	2101      	movs	r1, #1
 80a3ff8:	f7fc f984 	bl	80a0304 <DMA_DoubleBufferModeCmd>

    /* Enable DMA1 Stream5 */
    DMA_Cmd(DMA1_Stream5, ENABLE);
 80a3ffc:	2101      	movs	r1, #1
 80a3ffe:	4628      	mov	r0, r5
 80a4000:	f7fc f96d 	bl	80a02de <DMA_Cmd>

    /* DAC channel1 Configuration */
    DAC_DeInit();
 80a4004:	f7fc f860 	bl	80a00c8 <DAC_DeInit>

    DAC_InitTypeDef DAC_InitStructure;
    DAC_StructInit(&DAC_InitStructure);
 80a4008:	a801      	add	r0, sp, #4
 80a400a:	f7fc f881 	bl	80a0110 <DAC_StructInit>
    
    DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO;
 80a400e:	2304      	movs	r3, #4
    DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
    DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;

    DAC_Init(DAC_Channel_1, &DAC_InitStructure);
 80a4010:	4620      	mov	r0, r4
 80a4012:	eb0d 0103 	add.w	r1, sp, r3
    DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
 80a4016:	e9cd 3401 	strd	r3, r4, [sp, #4]
    DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 80a401a:	9404      	str	r4, [sp, #16]
    DAC_Init(DAC_Channel_1, &DAC_InitStructure);
 80a401c:	f7fc f862 	bl	80a00e4 <DAC_Init>

    /* Enable DAC Channel1 */
    DAC_Cmd(DAC_Channel_1, ENABLE);
 80a4020:	4620      	mov	r0, r4
 80a4022:	2101      	movs	r1, #1
 80a4024:	f7fc f87a 	bl	80a011c <DAC_Cmd>

    /* Enable DMA for DAC Channel1 */
    DAC_DMACmd(DAC_Channel_1, ENABLE);
 80a4028:	4620      	mov	r0, r4

    /* TIM6 Configuration */
    TIM_DeInit(TIM6);
 80a402a:	4c12      	ldr	r4, [pc, #72]	; (80a4074 <_ZN7Speaker7setupHWEt+0xf4>)
    DAC_DMACmd(DAC_Channel_1, ENABLE);
 80a402c:	2101      	movs	r1, #1
 80a402e:	f7fc f885 	bl	80a013c <DAC_DMACmd>
    TIM_DeInit(TIM6);
 80a4032:	4620      	mov	r0, r4
 80a4034:	f7fc f9a4 	bl	80a0380 <TIM_DeInit>
    TIM_Cmd(TIM6, ENABLE);
}

uint16_t Speaker::timerAutoReloadValue(uint16_t audioFrequency)
{
    return SystemCoreClock / 2 / audioFrequency;
 80a4038:	4b0f      	ldr	r3, [pc, #60]	; (80a4078 <_ZN7Speaker7setupHWEt+0xf8>)
    TIM_SetAutoreload(TIM6, timerAutoReloadValue(audioFrequency));
 80a403a:	4620      	mov	r0, r4
    return SystemCoreClock / 2 / audioFrequency;
 80a403c:	681b      	ldr	r3, [r3, #0]
 80a403e:	085b      	lsrs	r3, r3, #1
 80a4040:	fbb3 f1f7 	udiv	r1, r3, r7
    TIM_SetAutoreload(TIM6, timerAutoReloadValue(audioFrequency));
 80a4044:	b289      	uxth	r1, r1
 80a4046:	f7fc fa45 	bl	80a04d4 <TIM_SetAutoreload>
    TIM_SelectOutputTrigger(TIM6, TIM_TRGOSource_Update);
 80a404a:	4620      	mov	r0, r4
 80a404c:	2120      	movs	r1, #32
 80a404e:	f7fc fa58 	bl	80a0502 <TIM_SelectOutputTrigger>
    TIM_ITConfig(TIM6, TIM_IT_Update, ENABLE);
 80a4052:	2201      	movs	r2, #1
 80a4054:	4620      	mov	r0, r4
 80a4056:	4611      	mov	r1, r2
 80a4058:	f7fc fa4a 	bl	80a04f0 <TIM_ITConfig>
    TIM_Cmd(TIM6, ENABLE);
 80a405c:	2101      	movs	r1, #1
 80a405e:	4620      	mov	r0, r4
 80a4060:	f7fc fa3a 	bl	80a04d8 <TIM_Cmd>
}
 80a4064:	b015      	add	sp, #84	; 0x54
 80a4066:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a4068:	40026088 	.word	0x40026088
 80a406c:	20000010 	.word	0x20000010
 80a4070:	4000740c 	.word	0x4000740c
 80a4074:	40001000 	.word	0x40001000
 80a4078:	20000020 	.word	0x20000020

080a407c <_ZN7Speaker5beginEt>:
    this->audioFrequency = audioFrequency;
 80a407c:	80c1      	strh	r1, [r0, #6]
    setupHW(audioFrequency);
 80a407e:	f7ff bf7f 	b.w	80a3f80 <_ZN7Speaker7setupHWEt>
	...

080a4084 <_ZN7Speaker3endEv>:
}

void Speaker::end()
{
 80a4084:	b510      	push	{r4, lr}
    /* Disable TIM6 update interrupt */
    TIM_ITConfig(TIM6, TIM_IT_Update, DISABLE);
 80a4086:	4c06      	ldr	r4, [pc, #24]	; (80a40a0 <_ZN7Speaker3endEv+0x1c>)
 80a4088:	2101      	movs	r1, #1
 80a408a:	4620      	mov	r0, r4
 80a408c:	2200      	movs	r2, #0
 80a408e:	f7fc fa2f 	bl	80a04f0 <TIM_ITConfig>
    /* Disable TIM6 */
    TIM_Cmd(TIM6, DISABLE);
 80a4092:	4620      	mov	r0, r4
}
 80a4094:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    TIM_Cmd(TIM6, DISABLE);
 80a4098:	2100      	movs	r1, #0
 80a409a:	f7fc ba1d 	b.w	80a04d8 <TIM_Cmd>
 80a409e:	bf00      	nop
 80a40a0:	40001000 	.word	0x40001000

080a40a4 <_ZN7Speaker5readyEv>:
{
   return (uint8_t) DMA_GetCurrentMemoryTarget(DMA1_Stream5);
}

bool Speaker::ready()
{
 80a40a4:	b510      	push	{r4, lr}
 80a40a6:	4604      	mov	r4, r0
   return (uint8_t) DMA_GetCurrentMemoryTarget(DMA1_Stream5);
 80a40a8:	4805      	ldr	r0, [pc, #20]	; (80a40c0 <_ZN7Speaker5readyEv+0x1c>)
 80a40aa:	f7fc f934 	bl	80a0316 <DMA_GetCurrentMemoryTarget>
    uint8_t cur = currentBuffer();
    if (cur != lastBuffer)
 80a40ae:	7923      	ldrb	r3, [r4, #4]
   return (uint8_t) DMA_GetCurrentMemoryTarget(DMA1_Stream5);
 80a40b0:	b2c0      	uxtb	r0, r0
    if (cur != lastBuffer)
 80a40b2:	4283      	cmp	r3, r0
    {
        lastBuffer = cur;
 80a40b4:	bf16      	itet	ne
 80a40b6:	7120      	strbne	r0, [r4, #4]
        return true;
    }
    else
    {
        return false;
 80a40b8:	2000      	moveq	r0, #0
        return true;
 80a40ba:	2001      	movne	r0, #1
    }
}
 80a40bc:	bd10      	pop	{r4, pc}
 80a40be:	bf00      	nop
 80a40c0:	40026088 	.word	0x40026088

080a40c4 <_ZN7Speaker9getBufferEv>:

uint16_t *Speaker::getBuffer()
{
 80a40c4:	b510      	push	{r4, lr}
 80a40c6:	4604      	mov	r4, r0
   return (uint8_t) DMA_GetCurrentMemoryTarget(DMA1_Stream5);
 80a40c8:	4804      	ldr	r0, [pc, #16]	; (80a40dc <_ZN7Speaker9getBufferEv+0x18>)
 80a40ca:	f7fc f924 	bl	80a0316 <DMA_GetCurrentMemoryTarget>
    /* Return alternate buffer for DMA1 Stream5 double buffering */
    return currentBuffer() ? buffer[0] : buffer[1];
 80a40ce:	f010 0fff 	tst.w	r0, #255	; 0xff
 80a40d2:	bf14      	ite	ne
 80a40d4:	68a0      	ldrne	r0, [r4, #8]
 80a40d6:	68e0      	ldreq	r0, [r4, #12]
}
 80a40d8:	bd10      	pop	{r4, pc}
 80a40da:	bf00      	nop
 80a40dc:	40026088 	.word	0x40026088

080a40e0 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a40e0:	b508      	push	{r3, lr}
 80a40e2:	4b02      	ldr	r3, [pc, #8]	; (80a40ec <os_mutex_recursive_create+0xc>)
 80a40e4:	681b      	ldr	r3, [r3, #0]
 80a40e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a40e8:	9301      	str	r3, [sp, #4]
 80a40ea:	bd08      	pop	{r3, pc}
 80a40ec:	080601d0 	.word	0x080601d0

080a40f0 <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
 80a40f0:	b508      	push	{r3, lr}
 80a40f2:	4b02      	ldr	r3, [pc, #8]	; (80a40fc <os_mutex_recursive_destroy+0xc>)
 80a40f4:	681b      	ldr	r3, [r3, #0]
 80a40f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a40f8:	9301      	str	r3, [sp, #4]
 80a40fa:	bd08      	pop	{r3, pc}
 80a40fc:	080601d0 	.word	0x080601d0

080a4100 <os_mutex_recursive_lock>:
DYNALIB_FN(19, hal_concurrent, os_mutex_recursive_lock, int(os_mutex_recursive_t))
 80a4100:	b508      	push	{r3, lr}
 80a4102:	4b02      	ldr	r3, [pc, #8]	; (80a410c <os_mutex_recursive_lock+0xc>)
 80a4104:	681b      	ldr	r3, [r3, #0]
 80a4106:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a4108:	9301      	str	r3, [sp, #4]
 80a410a:	bd08      	pop	{r3, pc}
 80a410c:	080601d0 	.word	0x080601d0

080a4110 <os_mutex_recursive_unlock>:
DYNALIB_FN(20, hal_concurrent, os_mutex_recursive_trylock, int(os_mutex_recursive_t))
DYNALIB_FN(21, hal_concurrent, os_mutex_recursive_unlock, int(os_mutex_recursive_t))
 80a4110:	b508      	push	{r3, lr}
 80a4112:	4b02      	ldr	r3, [pc, #8]	; (80a411c <os_mutex_recursive_unlock+0xc>)
 80a4114:	681b      	ldr	r3, [r3, #0]
 80a4116:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a4118:	9301      	str	r3, [sp, #4]
 80a411a:	bd08      	pop	{r3, pc}
 80a411c:	080601d0 	.word	0x080601d0

080a4120 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a4120:	b508      	push	{r3, lr}
 80a4122:	4b02      	ldr	r3, [pc, #8]	; (80a412c <HAL_RNG_GetRandomNumber+0xc>)
 80a4124:	681b      	ldr	r3, [r3, #0]
 80a4126:	685b      	ldr	r3, [r3, #4]
 80a4128:	9301      	str	r3, [sp, #4]
 80a412a:	bd08      	pop	{r3, pc}
 80a412c:	0806019c 	.word	0x0806019c

080a4130 <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a4130:	b508      	push	{r3, lr}
 80a4132:	4b02      	ldr	r3, [pc, #8]	; (80a413c <HAL_Delay_Microseconds+0xc>)
 80a4134:	681b      	ldr	r3, [r3, #0]
 80a4136:	68db      	ldr	r3, [r3, #12]
 80a4138:	9301      	str	r3, [sp, #4]
 80a413a:	bd08      	pop	{r3, pc}
 80a413c:	0806019c 	.word	0x0806019c

080a4140 <HAL_Timer_Get_Micro_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a4140:	b508      	push	{r3, lr}
 80a4142:	4b02      	ldr	r3, [pc, #8]	; (80a414c <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a4144:	681b      	ldr	r3, [r3, #0]
 80a4146:	691b      	ldr	r3, [r3, #16]
 80a4148:	9301      	str	r3, [sp, #4]
 80a414a:	bd08      	pop	{r3, pc}
 80a414c:	0806019c 	.word	0x0806019c

080a4150 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a4150:	b508      	push	{r3, lr}
 80a4152:	4b02      	ldr	r3, [pc, #8]	; (80a415c <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a4154:	681b      	ldr	r3, [r3, #0]
 80a4156:	695b      	ldr	r3, [r3, #20]
 80a4158:	9301      	str	r3, [sp, #4]
 80a415a:	bd08      	pop	{r3, pc}
 80a415c:	0806019c 	.word	0x0806019c

080a4160 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a4160:	b508      	push	{r3, lr}
 80a4162:	4b02      	ldr	r3, [pc, #8]	; (80a416c <HAL_Pin_Map+0xc>)
 80a4164:	681b      	ldr	r3, [r3, #0]
 80a4166:	681b      	ldr	r3, [r3, #0]
 80a4168:	9301      	str	r3, [sp, #4]
 80a416a:	bd08      	pop	{r3, pc}
 80a416c:	080601b0 	.word	0x080601b0

080a4170 <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a4170:	b508      	push	{r3, lr}
 80a4172:	4b02      	ldr	r3, [pc, #8]	; (80a417c <HAL_Validate_Pin_Function+0xc>)
 80a4174:	681b      	ldr	r3, [r3, #0]
 80a4176:	685b      	ldr	r3, [r3, #4]
 80a4178:	9301      	str	r3, [sp, #4]
 80a417a:	bd08      	pop	{r3, pc}
 80a417c:	080601b0 	.word	0x080601b0

080a4180 <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a4180:	b508      	push	{r3, lr}
 80a4182:	4b02      	ldr	r3, [pc, #8]	; (80a418c <HAL_Pin_Mode+0xc>)
 80a4184:	681b      	ldr	r3, [r3, #0]
 80a4186:	689b      	ldr	r3, [r3, #8]
 80a4188:	9301      	str	r3, [sp, #4]
 80a418a:	bd08      	pop	{r3, pc}
 80a418c:	080601b0 	.word	0x080601b0

080a4190 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a4190:	b508      	push	{r3, lr}
 80a4192:	4b02      	ldr	r3, [pc, #8]	; (80a419c <HAL_Get_Pin_Mode+0xc>)
 80a4194:	681b      	ldr	r3, [r3, #0]
 80a4196:	68db      	ldr	r3, [r3, #12]
 80a4198:	9301      	str	r3, [sp, #4]
 80a419a:	bd08      	pop	{r3, pc}
 80a419c:	080601b0 	.word	0x080601b0

080a41a0 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a41a0:	b508      	push	{r3, lr}
 80a41a2:	4b02      	ldr	r3, [pc, #8]	; (80a41ac <HAL_GPIO_Write+0xc>)
 80a41a4:	681b      	ldr	r3, [r3, #0]
 80a41a6:	691b      	ldr	r3, [r3, #16]
 80a41a8:	9301      	str	r3, [sp, #4]
 80a41aa:	bd08      	pop	{r3, pc}
 80a41ac:	080601b0 	.word	0x080601b0

080a41b0 <HAL_GPIO_Read>:
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
 80a41b0:	b508      	push	{r3, lr}
 80a41b2:	4b02      	ldr	r3, [pc, #8]	; (80a41bc <HAL_GPIO_Read+0xc>)
 80a41b4:	681b      	ldr	r3, [r3, #0]
 80a41b6:	695b      	ldr	r3, [r3, #20]
 80a41b8:	9301      	str	r3, [sp, #4]
 80a41ba:	bd08      	pop	{r3, pc}
 80a41bc:	080601b0 	.word	0x080601b0

080a41c0 <hal_adc_read>:
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
DYNALIB_FN(11, hal_gpio, hal_adc_set_sample_time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, hal_adc_read, int32_t(uint16_t))
 80a41c0:	b508      	push	{r3, lr}
 80a41c2:	4b02      	ldr	r3, [pc, #8]	; (80a41cc <hal_adc_read+0xc>)
 80a41c4:	681b      	ldr	r3, [r3, #0]
 80a41c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a41c8:	9301      	str	r3, [sp, #4]
 80a41ca:	bd08      	pop	{r3, pc}
 80a41cc:	080601b0 	.word	0x080601b0

080a41d0 <hal_i2c_write>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, hal_i2c_begin, void(hal_i2c_interface_t, hal_i2c_mode_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, hal_i2c_end, void(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, hal_i2c_request, uint32_t(hal_i2c_interface_t, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, hal_i2c_begin_transmission, void(hal_i2c_interface_t, uint8_t, const hal_i2c_transmission_config_t*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, hal_i2c_end_transmission, uint8_t(hal_i2c_interface_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, hal_i2c_write, uint32_t(hal_i2c_interface_t, uint8_t, void*))
 80a41d0:	b508      	push	{r3, lr}
 80a41d2:	4b02      	ldr	r3, [pc, #8]	; (80a41dc <hal_i2c_write+0xc>)
 80a41d4:	681b      	ldr	r3, [r3, #0]
 80a41d6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a41d8:	9301      	str	r3, [sp, #4]
 80a41da:	bd08      	pop	{r3, pc}
 80a41dc:	080601ac 	.word	0x080601ac

080a41e0 <hal_i2c_available>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, hal_i2c_available, int32_t(hal_i2c_interface_t, void*))
 80a41e0:	b508      	push	{r3, lr}
 80a41e2:	4b02      	ldr	r3, [pc, #8]	; (80a41ec <hal_i2c_available+0xc>)
 80a41e4:	681b      	ldr	r3, [r3, #0]
 80a41e6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a41e8:	9301      	str	r3, [sp, #4]
 80a41ea:	bd08      	pop	{r3, pc}
 80a41ec:	080601ac 	.word	0x080601ac

080a41f0 <hal_i2c_read>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, hal_i2c_read, int32_t(hal_i2c_interface_t, void*))
 80a41f0:	b508      	push	{r3, lr}
 80a41f2:	4b02      	ldr	r3, [pc, #8]	; (80a41fc <hal_i2c_read+0xc>)
 80a41f4:	681b      	ldr	r3, [r3, #0]
 80a41f6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a41f8:	9301      	str	r3, [sp, #4]
 80a41fa:	bd08      	pop	{r3, pc}
 80a41fc:	080601ac 	.word	0x080601ac

080a4200 <hal_i2c_peek>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, hal_i2c_peek, int32_t(hal_i2c_interface_t, void*))
 80a4200:	b508      	push	{r3, lr}
 80a4202:	4b02      	ldr	r3, [pc, #8]	; (80a420c <hal_i2c_peek+0xc>)
 80a4204:	681b      	ldr	r3, [r3, #0]
 80a4206:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a4208:	9301      	str	r3, [sp, #4]
 80a420a:	bd08      	pop	{r3, pc}
 80a420c:	080601ac 	.word	0x080601ac

080a4210 <hal_i2c_flush>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, hal_i2c_flush, void(hal_i2c_interface_t, void*))
 80a4210:	b508      	push	{r3, lr}
 80a4212:	4b02      	ldr	r3, [pc, #8]	; (80a421c <hal_i2c_flush+0xc>)
 80a4214:	681b      	ldr	r3, [r3, #0]
 80a4216:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a4218:	9301      	str	r3, [sp, #4]
 80a421a:	bd08      	pop	{r3, pc}
 80a421c:	080601ac 	.word	0x080601ac

080a4220 <hal_i2c_is_enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, hal_i2c_is_enabled, bool(hal_i2c_interface_t, void*))
 80a4220:	b508      	push	{r3, lr}
 80a4222:	4b02      	ldr	r3, [pc, #8]	; (80a422c <hal_i2c_is_enabled+0xc>)
 80a4224:	681b      	ldr	r3, [r3, #0]
 80a4226:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a4228:	9301      	str	r3, [sp, #4]
 80a422a:	bd08      	pop	{r3, pc}
 80a422c:	080601ac 	.word	0x080601ac

080a4230 <hal_i2c_init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, hal_i2c_set_callback_on_received, void(hal_i2c_interface_t, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, hal_i2c_set_callback_on_requested, void(hal_i2c_interface_t, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, hal_i2c_init, int(hal_i2c_interface_t, const hal_i2c_config_t*))
 80a4230:	b508      	push	{r3, lr}
 80a4232:	4b03      	ldr	r3, [pc, #12]	; (80a4240 <hal_i2c_init+0x10>)
 80a4234:	681b      	ldr	r3, [r3, #0]
 80a4236:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a423a:	9301      	str	r3, [sp, #4]
 80a423c:	bd08      	pop	{r3, pc}
 80a423e:	0000      	.short	0x0000
 80a4240:	080601ac 	.word	0x080601ac

080a4244 <HAL_Servo_Attach>:
DYNALIB_FN(0, hal_peripherals, HAL_Tone_Start, void(uint8_t, uint32_t, uint32_t))
DYNALIB_FN(1, hal_peripherals, HAL_Tone_Stop, void(uint8_t))
DYNALIB_FN(2, hal_peripherals, HAL_Tone_Get_Frequency, uint32_t(uint8_t))
DYNALIB_FN(3, hal_peripherals, HAL_Tone_Is_Stopped, bool(uint8_t))

DYNALIB_FN(4, hal_peripherals, HAL_Servo_Attach, void(uint16_t))
 80a4244:	b508      	push	{r3, lr}
 80a4246:	4b02      	ldr	r3, [pc, #8]	; (80a4250 <HAL_Servo_Attach+0xc>)
 80a4248:	681b      	ldr	r3, [r3, #0]
 80a424a:	691b      	ldr	r3, [r3, #16]
 80a424c:	9301      	str	r3, [sp, #4]
 80a424e:	bd08      	pop	{r3, pc}
 80a4250:	080601a8 	.word	0x080601a8

080a4254 <HAL_Servo_Detach>:
DYNALIB_FN(5, hal_peripherals, HAL_Servo_Detach, void(uint16_t))
 80a4254:	b508      	push	{r3, lr}
 80a4256:	4b02      	ldr	r3, [pc, #8]	; (80a4260 <HAL_Servo_Detach+0xc>)
 80a4258:	681b      	ldr	r3, [r3, #0]
 80a425a:	695b      	ldr	r3, [r3, #20]
 80a425c:	9301      	str	r3, [sp, #4]
 80a425e:	bd08      	pop	{r3, pc}
 80a4260:	080601a8 	.word	0x080601a8

080a4264 <HAL_Servo_Write_Pulse_Width>:
DYNALIB_FN(6, hal_peripherals, HAL_Servo_Write_Pulse_Width, void(uint16_t, uint16_t))
 80a4264:	b508      	push	{r3, lr}
 80a4266:	4b02      	ldr	r3, [pc, #8]	; (80a4270 <HAL_Servo_Write_Pulse_Width+0xc>)
 80a4268:	681b      	ldr	r3, [r3, #0]
 80a426a:	699b      	ldr	r3, [r3, #24]
 80a426c:	9301      	str	r3, [sp, #4]
 80a426e:	bd08      	pop	{r3, pc}
 80a4270:	080601a8 	.word	0x080601a8

080a4274 <hal_spi_begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, hal_spi_begin, void(hal_spi_interface_t, uint16_t))
 80a4274:	b508      	push	{r3, lr}
 80a4276:	4b02      	ldr	r3, [pc, #8]	; (80a4280 <hal_spi_begin+0xc>)
 80a4278:	681b      	ldr	r3, [r3, #0]
 80a427a:	681b      	ldr	r3, [r3, #0]
 80a427c:	9301      	str	r3, [sp, #4]
 80a427e:	bd08      	pop	{r3, pc}
 80a4280:	080601b4 	.word	0x080601b4

080a4284 <hal_spi_transfer>:
DYNALIB_FN(1, hal_spi, hal_spi_end, void(hal_spi_interface_t))
DYNALIB_FN(2, hal_spi, hal_spi_set_bit_order, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(3, hal_spi, hal_spi_set_data_mode, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(4, hal_spi, hal_spi_set_clock_divider, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(5, hal_spi, hal_spi_transfer, uint16_t(hal_spi_interface_t, uint16_t))
 80a4284:	b508      	push	{r3, lr}
 80a4286:	4b02      	ldr	r3, [pc, #8]	; (80a4290 <hal_spi_transfer+0xc>)
 80a4288:	681b      	ldr	r3, [r3, #0]
 80a428a:	695b      	ldr	r3, [r3, #20]
 80a428c:	9301      	str	r3, [sp, #4]
 80a428e:	bd08      	pop	{r3, pc}
 80a4290:	080601b4 	.word	0x080601b4

080a4294 <hal_spi_init>:
DYNALIB_FN(6, hal_spi, hal_spi_is_enabled_deprecated, bool(void))
DYNALIB_FN(7, hal_spi, hal_spi_init, void(hal_spi_interface_t))
 80a4294:	b508      	push	{r3, lr}
 80a4296:	4b02      	ldr	r3, [pc, #8]	; (80a42a0 <hal_spi_init+0xc>)
 80a4298:	681b      	ldr	r3, [r3, #0]
 80a429a:	69db      	ldr	r3, [r3, #28]
 80a429c:	9301      	str	r3, [sp, #4]
 80a429e:	bd08      	pop	{r3, pc}
 80a42a0:	080601b4 	.word	0x080601b4

080a42a4 <hal_spi_is_enabled>:
DYNALIB_FN(8, hal_spi, hal_spi_is_enabled, bool(hal_spi_interface_t))
 80a42a4:	b508      	push	{r3, lr}
 80a42a6:	4b02      	ldr	r3, [pc, #8]	; (80a42b0 <hal_spi_is_enabled+0xc>)
 80a42a8:	681b      	ldr	r3, [r3, #0]
 80a42aa:	6a1b      	ldr	r3, [r3, #32]
 80a42ac:	9301      	str	r3, [sp, #4]
 80a42ae:	bd08      	pop	{r3, pc}
 80a42b0:	080601b4 	.word	0x080601b4

080a42b4 <hal_spi_info>:
DYNALIB_FN(9, hal_spi, hal_spi_info, void(hal_spi_interface_t, hal_spi_info_t*, void*))
 80a42b4:	b508      	push	{r3, lr}
 80a42b6:	4b02      	ldr	r3, [pc, #8]	; (80a42c0 <hal_spi_info+0xc>)
 80a42b8:	681b      	ldr	r3, [r3, #0]
 80a42ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a42bc:	9301      	str	r3, [sp, #4]
 80a42be:	bd08      	pop	{r3, pc}
 80a42c0:	080601b4 	.word	0x080601b4

080a42c4 <hal_spi_transfer_dma>:
DYNALIB_FN(10, hal_spi, hal_spi_transfer_dma, void(hal_spi_interface_t, void*, void*, uint32_t, hal_spi_dma_user_callback))
 80a42c4:	b508      	push	{r3, lr}
 80a42c6:	4b02      	ldr	r3, [pc, #8]	; (80a42d0 <hal_spi_transfer_dma+0xc>)
 80a42c8:	681b      	ldr	r3, [r3, #0]
 80a42ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a42cc:	9301      	str	r3, [sp, #4]
 80a42ce:	bd08      	pop	{r3, pc}
 80a42d0:	080601b4 	.word	0x080601b4

080a42d4 <hal_spi_transfer_dma_status>:
DYNALIB_FN(11, hal_spi, hal_spi_begin_ext, void(hal_spi_interface_t, hal_spi_mode_t, uint16_t, void*))
DYNALIB_FN(12, hal_spi, hal_spi_set_callback_on_selected, void(hal_spi_interface_t, hal_spi_select_user_callback, void*))
DYNALIB_FN(13, hal_spi, hal_spi_transfer_dma_cancel, void(hal_spi_interface_t))
DYNALIB_FN(14, hal_spi, hal_spi_transfer_dma_status, int32_t(hal_spi_interface_t, hal_spi_transfer_status_t*))
 80a42d4:	b508      	push	{r3, lr}
 80a42d6:	4b02      	ldr	r3, [pc, #8]	; (80a42e0 <hal_spi_transfer_dma_status+0xc>)
 80a42d8:	681b      	ldr	r3, [r3, #0]
 80a42da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a42dc:	9301      	str	r3, [sp, #4]
 80a42de:	bd08      	pop	{r3, pc}
 80a42e0:	080601b4 	.word	0x080601b4

080a42e4 <hal_spi_set_settings>:
DYNALIB_FN(15, hal_spi, hal_spi_set_settings, int32_t(hal_spi_interface_t, uint8_t, uint8_t, uint8_t, uint8_t, void*))
 80a42e4:	b508      	push	{r3, lr}
 80a42e6:	4b02      	ldr	r3, [pc, #8]	; (80a42f0 <hal_spi_set_settings+0xc>)
 80a42e8:	681b      	ldr	r3, [r3, #0]
 80a42ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a42ec:	9301      	str	r3, [sp, #4]
 80a42ee:	bd08      	pop	{r3, pc}
 80a42f0:	080601b4 	.word	0x080601b4

080a42f4 <hal_usart_init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, hal_usart_init, void(hal_usart_interface_t, hal_usart_ring_buffer_t*, hal_usart_ring_buffer_t*))
 80a42f4:	b508      	push	{r3, lr}
 80a42f6:	4b02      	ldr	r3, [pc, #8]	; (80a4300 <hal_usart_init+0xc>)
 80a42f8:	681b      	ldr	r3, [r3, #0]
 80a42fa:	699b      	ldr	r3, [r3, #24]
 80a42fc:	9301      	str	r3, [sp, #4]
 80a42fe:	bd08      	pop	{r3, pc}
 80a4300:	080601c4 	.word	0x080601c4

080a4304 <hal_usart_end>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, hal_usart_begin, void(hal_usart_interface_t, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, hal_usart_end, void(hal_usart_interface_t))
 80a4304:	b508      	push	{r3, lr}
 80a4306:	4b02      	ldr	r3, [pc, #8]	; (80a4310 <hal_usart_end+0xc>)
 80a4308:	681b      	ldr	r3, [r3, #0]
 80a430a:	6a1b      	ldr	r3, [r3, #32]
 80a430c:	9301      	str	r3, [sp, #4]
 80a430e:	bd08      	pop	{r3, pc}
 80a4310:	080601c4 	.word	0x080601c4

080a4314 <hal_usart_write>:
DYNALIB_FN(BASE_IDX + 3, hal_usart, hal_usart_write, uint32_t(hal_usart_interface_t, uint8_t))
 80a4314:	b508      	push	{r3, lr}
 80a4316:	4b02      	ldr	r3, [pc, #8]	; (80a4320 <hal_usart_write+0xc>)
 80a4318:	681b      	ldr	r3, [r3, #0]
 80a431a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a431c:	9301      	str	r3, [sp, #4]
 80a431e:	bd08      	pop	{r3, pc}
 80a4320:	080601c4 	.word	0x080601c4

080a4324 <hal_usart_available>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, hal_usart_available, int32_t(hal_usart_interface_t))
 80a4324:	b508      	push	{r3, lr}
 80a4326:	4b02      	ldr	r3, [pc, #8]	; (80a4330 <hal_usart_available+0xc>)
 80a4328:	681b      	ldr	r3, [r3, #0]
 80a432a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a432c:	9301      	str	r3, [sp, #4]
 80a432e:	bd08      	pop	{r3, pc}
 80a4330:	080601c4 	.word	0x080601c4

080a4334 <hal_usart_read>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, hal_usart_read, int32_t(hal_usart_interface_t))
 80a4334:	b508      	push	{r3, lr}
 80a4336:	4b02      	ldr	r3, [pc, #8]	; (80a4340 <hal_usart_read+0xc>)
 80a4338:	681b      	ldr	r3, [r3, #0]
 80a433a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a433c:	9301      	str	r3, [sp, #4]
 80a433e:	bd08      	pop	{r3, pc}
 80a4340:	080601c4 	.word	0x080601c4

080a4344 <hal_usart_peek>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, hal_usart_peek, int32_t(hal_usart_interface_t))
 80a4344:	b508      	push	{r3, lr}
 80a4346:	4b02      	ldr	r3, [pc, #8]	; (80a4350 <hal_usart_peek+0xc>)
 80a4348:	681b      	ldr	r3, [r3, #0]
 80a434a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a434c:	9301      	str	r3, [sp, #4]
 80a434e:	bd08      	pop	{r3, pc}
 80a4350:	080601c4 	.word	0x080601c4

080a4354 <hal_usart_flush>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, hal_usart_flush, void(hal_usart_interface_t))
 80a4354:	b508      	push	{r3, lr}
 80a4356:	4b02      	ldr	r3, [pc, #8]	; (80a4360 <hal_usart_flush+0xc>)
 80a4358:	681b      	ldr	r3, [r3, #0]
 80a435a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a435c:	9301      	str	r3, [sp, #4]
 80a435e:	bd08      	pop	{r3, pc}
 80a4360:	080601c4 	.word	0x080601c4

080a4364 <hal_usart_is_enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, hal_usart_is_enabled, bool(hal_usart_interface_t))
 80a4364:	b508      	push	{r3, lr}
 80a4366:	4b02      	ldr	r3, [pc, #8]	; (80a4370 <hal_usart_is_enabled+0xc>)
 80a4368:	681b      	ldr	r3, [r3, #0]
 80a436a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a436c:	9301      	str	r3, [sp, #4]
 80a436e:	bd08      	pop	{r3, pc}
 80a4370:	080601c4 	.word	0x080601c4

080a4374 <hal_usart_available_data_for_write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, hal_usart_half_duplex, void(hal_usart_interface_t, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, hal_usart_available_data_for_write, int32_t(hal_usart_interface_t))
 80a4374:	b508      	push	{r3, lr}
 80a4376:	4b02      	ldr	r3, [pc, #8]	; (80a4380 <hal_usart_available_data_for_write+0xc>)
 80a4378:	681b      	ldr	r3, [r3, #0]
 80a437a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a437c:	9301      	str	r3, [sp, #4]
 80a437e:	bd08      	pop	{r3, pc}
 80a4380:	080601c4 	.word	0x080601c4

080a4384 <hal_usart_begin_config>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, hal_usart_begin_config, void(hal_usart_interface_t serial, uint32_t baud, uint32_t config, void *ptr))
 80a4384:	b508      	push	{r3, lr}
 80a4386:	4b02      	ldr	r3, [pc, #8]	; (80a4390 <hal_usart_begin_config+0xc>)
 80a4388:	681b      	ldr	r3, [r3, #0]
 80a438a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a438c:	9301      	str	r3, [sp, #4]
 80a438e:	bd08      	pop	{r3, pc}
 80a4390:	080601c4 	.word	0x080601c4

080a4394 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a4394:	b508      	push	{r3, lr}
 80a4396:	4b02      	ldr	r3, [pc, #8]	; (80a43a0 <HAL_USB_USART_Init+0xc>)
 80a4398:	681b      	ldr	r3, [r3, #0]
 80a439a:	681b      	ldr	r3, [r3, #0]
 80a439c:	9301      	str	r3, [sp, #4]
 80a439e:	bd08      	pop	{r3, pc}
 80a43a0:	080601d8 	.word	0x080601d8

080a43a4 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a43a4:	b508      	push	{r3, lr}
 80a43a6:	4b02      	ldr	r3, [pc, #8]	; (80a43b0 <HAL_USB_USART_Begin+0xc>)
 80a43a8:	681b      	ldr	r3, [r3, #0]
 80a43aa:	685b      	ldr	r3, [r3, #4]
 80a43ac:	9301      	str	r3, [sp, #4]
 80a43ae:	bd08      	pop	{r3, pc}
 80a43b0:	080601d8 	.word	0x080601d8

080a43b4 <HAL_USB_USART_End>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
 80a43b4:	b508      	push	{r3, lr}
 80a43b6:	4b02      	ldr	r3, [pc, #8]	; (80a43c0 <HAL_USB_USART_End+0xc>)
 80a43b8:	681b      	ldr	r3, [r3, #0]
 80a43ba:	689b      	ldr	r3, [r3, #8]
 80a43bc:	9301      	str	r3, [sp, #4]
 80a43be:	bd08      	pop	{r3, pc}
 80a43c0:	080601d8 	.word	0x080601d8

080a43c4 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a43c4:	b508      	push	{r3, lr}
 80a43c6:	4b02      	ldr	r3, [pc, #8]	; (80a43d0 <HAL_USB_USART_Available_Data+0xc>)
 80a43c8:	681b      	ldr	r3, [r3, #0]
 80a43ca:	691b      	ldr	r3, [r3, #16]
 80a43cc:	9301      	str	r3, [sp, #4]
 80a43ce:	bd08      	pop	{r3, pc}
 80a43d0:	080601d8 	.word	0x080601d8

080a43d4 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a43d4:	b508      	push	{r3, lr}
 80a43d6:	4b02      	ldr	r3, [pc, #8]	; (80a43e0 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a43d8:	681b      	ldr	r3, [r3, #0]
 80a43da:	695b      	ldr	r3, [r3, #20]
 80a43dc:	9301      	str	r3, [sp, #4]
 80a43de:	bd08      	pop	{r3, pc}
 80a43e0:	080601d8 	.word	0x080601d8

080a43e4 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a43e4:	b508      	push	{r3, lr}
 80a43e6:	4b02      	ldr	r3, [pc, #8]	; (80a43f0 <HAL_USB_USART_Receive_Data+0xc>)
 80a43e8:	681b      	ldr	r3, [r3, #0]
 80a43ea:	699b      	ldr	r3, [r3, #24]
 80a43ec:	9301      	str	r3, [sp, #4]
 80a43ee:	bd08      	pop	{r3, pc}
 80a43f0:	080601d8 	.word	0x080601d8

080a43f4 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a43f4:	b508      	push	{r3, lr}
 80a43f6:	4b02      	ldr	r3, [pc, #8]	; (80a4400 <HAL_USB_USART_Send_Data+0xc>)
 80a43f8:	681b      	ldr	r3, [r3, #0]
 80a43fa:	69db      	ldr	r3, [r3, #28]
 80a43fc:	9301      	str	r3, [sp, #4]
 80a43fe:	bd08      	pop	{r3, pc}
 80a4400:	080601d8 	.word	0x080601d8

080a4404 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a4404:	b508      	push	{r3, lr}
 80a4406:	4b02      	ldr	r3, [pc, #8]	; (80a4410 <HAL_USB_USART_Flush_Data+0xc>)
 80a4408:	681b      	ldr	r3, [r3, #0]
 80a440a:	6a1b      	ldr	r3, [r3, #32]
 80a440c:	9301      	str	r3, [sp, #4]
 80a440e:	bd08      	pop	{r3, pc}
 80a4410:	080601d8 	.word	0x080601d8

080a4414 <inet_gethostbyname>:
DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a4414:	b508      	push	{r3, lr}
 80a4416:	4b02      	ldr	r3, [pc, #8]	; (80a4420 <inet_gethostbyname+0xc>)
 80a4418:	681b      	ldr	r3, [r3, #0]
 80a441a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a441c:	9301      	str	r3, [sp, #4]
 80a441e:	bd08      	pop	{r3, pc}
 80a4420:	080601c0 	.word	0x080601c0

080a4424 <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
 80a4424:	b508      	push	{r3, lr}
 80a4426:	4b02      	ldr	r3, [pc, #8]	; (80a4430 <panic_+0xc>)
 80a4428:	681b      	ldr	r3, [r3, #0]
 80a442a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a442c:	9301      	str	r3, [sp, #4]
 80a442e:	bd08      	pop	{r3, pc}
 80a4430:	080201a8 	.word	0x080201a8

080a4434 <log_message_v>:
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
DYNALIB_FN(21, services, log_message_v, void(int, const char*, LogAttributes*, void*, const char*, va_list))
 80a4434:	b508      	push	{r3, lr}
 80a4436:	4b02      	ldr	r3, [pc, #8]	; (80a4440 <log_message_v+0xc>)
 80a4438:	681b      	ldr	r3, [r3, #0]
 80a443a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a443c:	9301      	str	r3, [sp, #4]
 80a443e:	bd08      	pop	{r3, pc}
 80a4440:	080201a8 	.word	0x080201a8

080a4444 <log_printf_v>:
DYNALIB_FN(22, services, log_write, void(int, const char*, const char*, size_t, void*))
DYNALIB_FN(23, services, log_printf, void(int, const char*, void*, const char*, ...))
DYNALIB_FN(24, services, log_printf_v, void(int, const char*, void*, const char*, va_list))
 80a4444:	b508      	push	{r3, lr}
 80a4446:	4b02      	ldr	r3, [pc, #8]	; (80a4450 <log_printf_v+0xc>)
 80a4448:	681b      	ldr	r3, [r3, #0]
 80a444a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a444c:	9301      	str	r3, [sp, #4]
 80a444e:	bd08      	pop	{r3, pc}
 80a4450:	080201a8 	.word	0x080201a8

080a4454 <log_level_name>:
DYNALIB_FN(25, services, log_dump, void(int, const char*, const void*, size_t, int, void*))
DYNALIB_FN(26, services, log_enabled, int(int, const char*, void*))
DYNALIB_FN(27, services, log_level_name, const char*(int, void*))
 80a4454:	b508      	push	{r3, lr}
 80a4456:	4b02      	ldr	r3, [pc, #8]	; (80a4460 <log_level_name+0xc>)
 80a4458:	681b      	ldr	r3, [r3, #0]
 80a445a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a445c:	9301      	str	r3, [sp, #4]
 80a445e:	bd08      	pop	{r3, pc}
 80a4460:	080201a8 	.word	0x080201a8

080a4464 <log_set_callbacks>:
DYNALIB_FN(28, services, log_set_callbacks, void(log_message_callback_type, log_write_callback_type, log_enabled_callback_type, void*))
 80a4464:	b508      	push	{r3, lr}
 80a4466:	4b02      	ldr	r3, [pc, #8]	; (80a4470 <log_set_callbacks+0xc>)
 80a4468:	681b      	ldr	r3, [r3, #0]
 80a446a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a446c:	9301      	str	r3, [sp, #4]
 80a446e:	bd08      	pop	{r3, pc}
 80a4470:	080201a8 	.word	0x080201a8

080a4474 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a4474:	b508      	push	{r3, lr}
 80a4476:	4b02      	ldr	r3, [pc, #8]	; (80a4480 <set_system_mode+0xc>)
 80a4478:	681b      	ldr	r3, [r3, #0]
 80a447a:	685b      	ldr	r3, [r3, #4]
 80a447c:	9301      	str	r3, [sp, #4]
 80a447e:	bd08      	pop	{r3, pc}
 80a4480:	080601a4 	.word	0x080601a4

080a4484 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a4484:	b508      	push	{r3, lr}
 80a4486:	4b03      	ldr	r3, [pc, #12]	; (80a4494 <system_ctrl_set_app_request_handler+0x10>)
 80a4488:	681b      	ldr	r3, [r3, #0]
 80a448a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a448e:	9301      	str	r3, [sp, #4]
 80a4490:	bd08      	pop	{r3, pc}
 80a4492:	0000      	.short	0x0000
 80a4494:	080601a4 	.word	0x080601a4

080a4498 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a4498:	b508      	push	{r3, lr}
 80a449a:	4b03      	ldr	r3, [pc, #12]	; (80a44a8 <system_ctrl_set_result+0x10>)
 80a449c:	681b      	ldr	r3, [r3, #0]
 80a449e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a44a2:	9301      	str	r3, [sp, #4]
 80a44a4:	bd08      	pop	{r3, pc}
 80a44a6:	0000      	.short	0x0000
 80a44a8:	080601a4 	.word	0x080601a4

080a44ac <spark_function>:


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
 80a44ac:	b508      	push	{r3, lr}
 80a44ae:	4b02      	ldr	r3, [pc, #8]	; (80a44b8 <spark_function+0xc>)
 80a44b0:	681b      	ldr	r3, [r3, #0]
 80a44b2:	685b      	ldr	r3, [r3, #4]
 80a44b4:	9301      	str	r3, [sp, #4]
 80a44b6:	bd08      	pop	{r3, pc}
 80a44b8:	080601cc 	.word	0x080601cc

080a44bc <spark_process>:
DYNALIB_FN(2, system_cloud, spark_process, void(void))
 80a44bc:	b508      	push	{r3, lr}
 80a44be:	4b02      	ldr	r3, [pc, #8]	; (80a44c8 <spark_process+0xc>)
 80a44c0:	681b      	ldr	r3, [r3, #0]
 80a44c2:	689b      	ldr	r3, [r3, #8]
 80a44c4:	9301      	str	r3, [sp, #4]
 80a44c6:	bd08      	pop	{r3, pc}
 80a44c8:	080601cc 	.word	0x080601cc

080a44cc <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time32_t*, time_t*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, const void*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a44cc:	b508      	push	{r3, lr}
 80a44ce:	4b02      	ldr	r3, [pc, #8]	; (80a44d8 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a44d0:	681b      	ldr	r3, [r3, #0]
 80a44d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a44d4:	9301      	str	r3, [sp, #4]
 80a44d6:	bd08      	pop	{r3, pc}
 80a44d8:	080601cc 	.word	0x080601cc

080a44dc <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a44dc:	b508      	push	{r3, lr}
 80a44de:	4b02      	ldr	r3, [pc, #8]	; (80a44e8 <network_connect+0xc>)
 80a44e0:	681b      	ldr	r3, [r3, #0]
 80a44e2:	685b      	ldr	r3, [r3, #4]
 80a44e4:	9301      	str	r3, [sp, #4]
 80a44e6:	bd08      	pop	{r3, pc}
 80a44e8:	080601c8 	.word	0x080601c8

080a44ec <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a44ec:	b508      	push	{r3, lr}
 80a44ee:	4b02      	ldr	r3, [pc, #8]	; (80a44f8 <network_connecting+0xc>)
 80a44f0:	681b      	ldr	r3, [r3, #0]
 80a44f2:	689b      	ldr	r3, [r3, #8]
 80a44f4:	9301      	str	r3, [sp, #4]
 80a44f6:	bd08      	pop	{r3, pc}
 80a44f8:	080601c8 	.word	0x080601c8

080a44fc <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a44fc:	b508      	push	{r3, lr}
 80a44fe:	4b02      	ldr	r3, [pc, #8]	; (80a4508 <network_disconnect+0xc>)
 80a4500:	681b      	ldr	r3, [r3, #0]
 80a4502:	68db      	ldr	r3, [r3, #12]
 80a4504:	9301      	str	r3, [sp, #4]
 80a4506:	bd08      	pop	{r3, pc}
 80a4508:	080601c8 	.word	0x080601c8

080a450c <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a450c:	b508      	push	{r3, lr}
 80a450e:	4b02      	ldr	r3, [pc, #8]	; (80a4518 <network_ready+0xc>)
 80a4510:	681b      	ldr	r3, [r3, #0]
 80a4512:	691b      	ldr	r3, [r3, #16]
 80a4514:	9301      	str	r3, [sp, #4]
 80a4516:	bd08      	pop	{r3, pc}
 80a4518:	080601c8 	.word	0x080601c8

080a451c <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a451c:	b508      	push	{r3, lr}
 80a451e:	4b02      	ldr	r3, [pc, #8]	; (80a4528 <network_on+0xc>)
 80a4520:	681b      	ldr	r3, [r3, #0]
 80a4522:	695b      	ldr	r3, [r3, #20]
 80a4524:	9301      	str	r3, [sp, #4]
 80a4526:	bd08      	pop	{r3, pc}
 80a4528:	080601c8 	.word	0x080601c8

080a452c <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a452c:	b508      	push	{r3, lr}
 80a452e:	4b02      	ldr	r3, [pc, #8]	; (80a4538 <network_off+0xc>)
 80a4530:	681b      	ldr	r3, [r3, #0]
 80a4532:	699b      	ldr	r3, [r3, #24]
 80a4534:	9301      	str	r3, [sp, #4]
 80a4536:	bd08      	pop	{r3, pc}
 80a4538:	080601c8 	.word	0x080601c8

080a453c <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a453c:	b508      	push	{r3, lr}
 80a453e:	4b02      	ldr	r3, [pc, #8]	; (80a4548 <network_listen+0xc>)
 80a4540:	681b      	ldr	r3, [r3, #0]
 80a4542:	69db      	ldr	r3, [r3, #28]
 80a4544:	9301      	str	r3, [sp, #4]
 80a4546:	bd08      	pop	{r3, pc}
 80a4548:	080601c8 	.word	0x080601c8

080a454c <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a454c:	b508      	push	{r3, lr}
 80a454e:	4b02      	ldr	r3, [pc, #8]	; (80a4558 <network_listening+0xc>)
 80a4550:	681b      	ldr	r3, [r3, #0]
 80a4552:	6a1b      	ldr	r3, [r3, #32]
 80a4554:	9301      	str	r3, [sp, #4]
 80a4556:	bd08      	pop	{r3, pc}
 80a4558:	080601c8 	.word	0x080601c8

080a455c <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a455c:	b508      	push	{r3, lr}
 80a455e:	4b02      	ldr	r3, [pc, #8]	; (80a4568 <network_set_listen_timeout+0xc>)
 80a4560:	681b      	ldr	r3, [r3, #0]
 80a4562:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a4564:	9301      	str	r3, [sp, #4]
 80a4566:	bd08      	pop	{r3, pc}
 80a4568:	080601c8 	.word	0x080601c8

080a456c <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a456c:	b508      	push	{r3, lr}
 80a456e:	4b02      	ldr	r3, [pc, #8]	; (80a4578 <network_get_listen_timeout+0xc>)
 80a4570:	681b      	ldr	r3, [r3, #0]
 80a4572:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a4574:	9301      	str	r3, [sp, #4]
 80a4576:	bd08      	pop	{r3, pc}
 80a4578:	080601c8 	.word	0x080601c8

080a457c <network_is_on>:
DYNALIB_FN(14, system_net, network_set_hostname, int(network_handle_t, uint32_t, const char*, void*))
DYNALIB_FN(15, system_net, network_get_hostname, int(network_handle_t, uint32_t, char*, size_t, void*))
DYNALIB_FN(16, system_net, network_is_on, bool(network_handle_t, void*))
 80a457c:	b508      	push	{r3, lr}
 80a457e:	4b02      	ldr	r3, [pc, #8]	; (80a4588 <network_is_on+0xc>)
 80a4580:	681b      	ldr	r3, [r3, #0]
 80a4582:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a4584:	9301      	str	r3, [sp, #4]
 80a4586:	bd08      	pop	{r3, pc}
 80a4588:	080601c8 	.word	0x080601c8

080a458c <network_is_off>:
DYNALIB_FN(17, system_net, network_is_off, bool(network_handle_t, void*))
 80a458c:	b508      	push	{r3, lr}
 80a458e:	4b02      	ldr	r3, [pc, #8]	; (80a4598 <network_is_off+0xc>)
 80a4590:	681b      	ldr	r3, [r3, #0]
 80a4592:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a4594:	9301      	str	r3, [sp, #4]
 80a4596:	bd08      	pop	{r3, pc}
 80a4598:	080601c8 	.word	0x080601c8

080a459c <malloc>:
#include "hal_platform.h"
#endif // defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a459c:	b508      	push	{r3, lr}
 80a459e:	4b02      	ldr	r3, [pc, #8]	; (80a45a8 <malloc+0xc>)
 80a45a0:	681b      	ldr	r3, [r3, #0]
 80a45a2:	681b      	ldr	r3, [r3, #0]
 80a45a4:	9301      	str	r3, [sp, #4]
 80a45a6:	bd08      	pop	{r3, pc}
 80a45a8:	080601a0 	.word	0x080601a0

080a45ac <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a45ac:	b508      	push	{r3, lr}
 80a45ae:	4b02      	ldr	r3, [pc, #8]	; (80a45b8 <free+0xc>)
 80a45b0:	681b      	ldr	r3, [r3, #0]
 80a45b2:	685b      	ldr	r3, [r3, #4]
 80a45b4:	9301      	str	r3, [sp, #4]
 80a45b6:	bd08      	pop	{r3, pc}
 80a45b8:	080601a0 	.word	0x080601a0

080a45bc <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a45bc:	b508      	push	{r3, lr}
 80a45be:	4b02      	ldr	r3, [pc, #8]	; (80a45c8 <realloc+0xc>)
 80a45c0:	681b      	ldr	r3, [r3, #0]
 80a45c2:	689b      	ldr	r3, [r3, #8]
 80a45c4:	9301      	str	r3, [sp, #4]
 80a45c6:	bd08      	pop	{r3, pc}
 80a45c8:	080601a0 	.word	0x080601a0

080a45cc <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a45cc:	b508      	push	{r3, lr}
 80a45ce:	4b02      	ldr	r3, [pc, #8]	; (80a45d8 <vsnprintf+0xc>)
 80a45d0:	681b      	ldr	r3, [r3, #0]
 80a45d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a45d4:	9301      	str	r3, [sp, #4]
 80a45d6:	bd08      	pop	{r3, pc}
 80a45d8:	080601a0 	.word	0x080601a0

080a45dc <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a45dc:	b508      	push	{r3, lr}
 80a45de:	4b02      	ldr	r3, [pc, #8]	; (80a45e8 <abort+0xc>)
 80a45e0:	681b      	ldr	r3, [r3, #0]
 80a45e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a45e4:	9301      	str	r3, [sp, #4]
 80a45e6:	bd08      	pop	{r3, pc}
 80a45e8:	080601a0 	.word	0x080601a0

080a45ec <__errno>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
DYNALIB_FN(13, rt, _free_r, void(struct _reent*, void*))
DYNALIB_FN(14, rt, _realloc_r, void*(struct _reent*, void*, size_t))
DYNALIB_FN(15, rt, __errno, int*())
 80a45ec:	b508      	push	{r3, lr}
 80a45ee:	4b02      	ldr	r3, [pc, #8]	; (80a45f8 <__errno+0xc>)
 80a45f0:	681b      	ldr	r3, [r3, #0]
 80a45f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a45f4:	9301      	str	r3, [sp, #4]
 80a45f6:	bd08      	pop	{r3, pc}
 80a45f8:	080601a0 	.word	0x080601a0

080a45fc <newlib_impure_ptr_callback>:
// RT is currently being imported into system-part1 from system-part2,
// which is the reverse direction.

#if defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))
DYNALIB_FN(16, rt, __assert_func, void(const char*, int, const char*, const char*))
DYNALIB_FN(17, rt, newlib_impure_ptr_callback, void(void (*)(struct _reent*, size_t, uint32_t, void*), void*))
 80a45fc:	b508      	push	{r3, lr}
 80a45fe:	4b02      	ldr	r3, [pc, #8]	; (80a4608 <newlib_impure_ptr_callback+0xc>)
 80a4600:	681b      	ldr	r3, [r3, #0]
 80a4602:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a4604:	9301      	str	r3, [sp, #4]
 80a4606:	bd08      	pop	{r3, pc}
 80a4608:	080601a0 	.word	0x080601a0

080a460c <_Z3mapiiiii>:
    hal_adc_set_sample_time(ADC_SampleTime);
}

int map(int value, int fromStart, int fromEnd, int toStart, int toEnd)
{
    if (fromEnd == fromStart) {
 80a460c:	428a      	cmp	r2, r1
{
 80a460e:	b510      	push	{r4, lr}
    if (fromEnd == fromStart) {
 80a4610:	d007      	beq.n	80a4622 <_Z3mapiiiii+0x16>
        return value;
    }
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
 80a4612:	9c02      	ldr	r4, [sp, #8]
 80a4614:	1a40      	subs	r0, r0, r1
 80a4616:	1ae4      	subs	r4, r4, r3
 80a4618:	4360      	muls	r0, r4
 80a461a:	1a52      	subs	r2, r2, r1
 80a461c:	fb90 f0f2 	sdiv	r0, r0, r2
 80a4620:	4418      	add	r0, r3
}
 80a4622:	bd10      	pop	{r4, pc}

080a4624 <_ZN10CloudClass22call_std_user_functionEPvPKcS0_>:
    String p(param);
    return (*fn)(p);
}

int CloudClass::call_std_user_function(void* data, const char* param, void* reserved)
{
 80a4624:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80a4626:	4604      	mov	r4, r0
    user_std_function_int_str_t* fn = (user_std_function_int_str_t*)(data);
    return (*fn)(String(param));
 80a4628:	4668      	mov	r0, sp
 80a462a:	f001 fd08 	bl	80a603e <_ZN6StringC1EPKc>
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a462e:	68a3      	ldr	r3, [r4, #8]
 80a4630:	b90b      	cbnz	r3, 80a4636 <_ZN10CloudClass22call_std_user_functionEPvPKcS0_+0x12>
	__throw_bad_function_call();
 80a4632:	f002 f913 	bl	80a685c <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a4636:	68e3      	ldr	r3, [r4, #12]
 80a4638:	4669      	mov	r1, sp
 80a463a:	4620      	mov	r0, r4
 80a463c:	4798      	blx	r3
 80a463e:	4604      	mov	r4, r0
 80a4640:	4668      	mov	r0, sp
 80a4642:	f001 fcb2 	bl	80a5faa <_ZN6StringD1Ev>
}
 80a4646:	4620      	mov	r0, r4
 80a4648:	b004      	add	sp, #16
 80a464a:	bd10      	pop	{r4, pc}

080a464c <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a464c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
 80a464e:	2300      	movs	r3, #0
         size = sizeof(*this);
 80a4650:	2410      	movs	r4, #16
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
 80a4652:	e9cd 0102 	strd	r0, r1, [sp, #8]
    desc.funcKey = funcKey;
 80a4656:	9201      	str	r2, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a4658:	4669      	mov	r1, sp
 80a465a:	461a      	mov	r2, r3
 80a465c:	4618      	mov	r0, r3
         memset(this, 0, sizeof(*this));
 80a465e:	f8ad 3002 	strh.w	r3, [sp, #2]
         size = sizeof(*this);
 80a4662:	f8ad 4000 	strh.w	r4, [sp]
 80a4666:	f7ff ff21 	bl	80a44ac <spark_function>
}
 80a466a:	b004      	add	sp, #16
 80a466c:	bd10      	pop	{r4, pc}

080a466e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a466e:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
 80a4670:	6804      	ldr	r4, [r0, #0]
      ~__shared_count() noexcept
 80a4672:	4605      	mov	r5, r0
	if (_M_pi != nullptr)
 80a4674:	b17c      	cbz	r4, 80a4696 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
      if (--_M_use_count == 0)
 80a4676:	6863      	ldr	r3, [r4, #4]
 80a4678:	3b01      	subs	r3, #1
 80a467a:	6063      	str	r3, [r4, #4]
 80a467c:	b95b      	cbnz	r3, 80a4696 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
          _M_dispose();
 80a467e:	6823      	ldr	r3, [r4, #0]
 80a4680:	4620      	mov	r0, r4
 80a4682:	689b      	ldr	r3, [r3, #8]
 80a4684:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a4686:	68a3      	ldr	r3, [r4, #8]
 80a4688:	3b01      	subs	r3, #1
 80a468a:	60a3      	str	r3, [r4, #8]
 80a468c:	b91b      	cbnz	r3, 80a4696 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
 80a468e:	6823      	ldr	r3, [r4, #0]
 80a4690:	4620      	mov	r0, r4
 80a4692:	68db      	ldr	r3, [r3, #12]
 80a4694:	4798      	blx	r3
	  _M_pi->_M_release();
      }
 80a4696:	4628      	mov	r0, r5
 80a4698:	bd38      	pop	{r3, r4, r5, pc}

080a469a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
 80a469a:	680b      	ldr	r3, [r1, #0]
 80a469c:	6003      	str	r3, [r0, #0]
      {
	if (_M_pi != 0)
 80a469e:	b113      	cbz	r3, 80a46a6 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    { ++_M_use_count; }
 80a46a0:	685a      	ldr	r2, [r3, #4]
 80a46a2:	3201      	adds	r2, #1
 80a46a4:	605a      	str	r2, [r3, #4]
	  _M_pi->_M_add_ref_copy();
      }
 80a46a6:	4770      	bx	lr

080a46a8 <_ZN7TwoWireD1Ev>:
private:
  hal_i2c_interface_t _i2c;

public:
  TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& config);
  virtual ~TwoWire() {};
 80a46a8:	4770      	bx	lr

080a46aa <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a46aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a46ac:	4606      	mov	r6, r0
 80a46ae:	4615      	mov	r5, r2
 80a46b0:	460c      	mov	r4, r1
 80a46b2:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a46b4:	42bc      	cmp	r4, r7
 80a46b6:	d006      	beq.n	80a46c6 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a46b8:	6833      	ldr	r3, [r6, #0]
 80a46ba:	4630      	mov	r0, r6
 80a46bc:	689b      	ldr	r3, [r3, #8]
 80a46be:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a46c2:	4798      	blx	r3
  for(size_t i = 0; i < quantity; ++i)
 80a46c4:	e7f6      	b.n	80a46b4 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a46c6:	4628      	mov	r0, r5
 80a46c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a46ca <_ZN7TwoWire5writeEh>:
  return hal_i2c_write(_i2c, data, NULL);
 80a46ca:	2200      	movs	r2, #0
 80a46cc:	7c00      	ldrb	r0, [r0, #16]
 80a46ce:	f7ff bd7f 	b.w	80a41d0 <hal_i2c_write>

080a46d2 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return hal_i2c_available(_i2c, NULL);
 80a46d2:	2100      	movs	r1, #0
 80a46d4:	7c00      	ldrb	r0, [r0, #16]
 80a46d6:	f7ff bd83 	b.w	80a41e0 <hal_i2c_available>

080a46da <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return hal_i2c_read(_i2c, NULL);
 80a46da:	2100      	movs	r1, #0
 80a46dc:	7c00      	ldrb	r0, [r0, #16]
 80a46de:	f7ff bd87 	b.w	80a41f0 <hal_i2c_read>

080a46e2 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return hal_i2c_peek(_i2c, NULL);
 80a46e2:	2100      	movs	r1, #0
 80a46e4:	7c00      	ldrb	r0, [r0, #16]
 80a46e6:	f7ff bd8b 	b.w	80a4200 <hal_i2c_peek>

080a46ea <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  hal_i2c_flush(_i2c, NULL);
 80a46ea:	2100      	movs	r1, #0
 80a46ec:	7c00      	ldrb	r0, [r0, #16]
 80a46ee:	f7ff bd8f 	b.w	80a4210 <hal_i2c_flush>

080a46f2 <_ZN7TwoWireD0Ev>:
 80a46f2:	b510      	push	{r4, lr}
 80a46f4:	4604      	mov	r4, r0
 80a46f6:	2114      	movs	r1, #20
 80a46f8:	f002 f8aa 	bl	80a6850 <_ZdlPvj>
 80a46fc:	4620      	mov	r0, r4
 80a46fe:	bd10      	pop	{r4, pc}

080a4700 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>:
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a4700:	b510      	push	{r4, lr}
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a4702:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a4706:	4604      	mov	r4, r0
 80a4708:	4608      	mov	r0, r1
 80a470a:	2100      	movs	r1, #0
 80a470c:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a4710:	4b03      	ldr	r3, [pc, #12]	; (80a4720 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x20>)
  hal_i2c_init(_i2c, &conf);
 80a4712:	4611      	mov	r1, r2
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a4714:	6023      	str	r3, [r4, #0]
  _i2c = i2c;
 80a4716:	7420      	strb	r0, [r4, #16]
  hal_i2c_init(_i2c, &conf);
 80a4718:	f7ff fd8a 	bl	80a4230 <hal_i2c_init>
}
 80a471c:	4620      	mov	r0, r4
 80a471e:	bd10      	pop	{r4, pc}
 80a4720:	080a7e34 	.word	0x080a7e34

080a4724 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a4724:	4770      	bx	lr

080a4726 <_ZN9IPAddressD0Ev>:
 80a4726:	b510      	push	{r4, lr}
 80a4728:	4604      	mov	r4, r0
 80a472a:	2118      	movs	r1, #24
 80a472c:	f002 f890 	bl	80a6850 <_ZdlPvj>
 80a4730:	4620      	mov	r0, r4
 80a4732:	bd10      	pop	{r4, pc}

080a4734 <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a4734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a4736:	460e      	mov	r6, r1
 80a4738:	2400      	movs	r4, #0
 80a473a:	f100 0708 	add.w	r7, r0, #8
 80a473e:	1d05      	adds	r5, r0, #4
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
 80a4740:	f817 1d01 	ldrb.w	r1, [r7, #-1]!
 80a4744:	220a      	movs	r2, #10
 80a4746:	4630      	mov	r0, r6
 80a4748:	f001 faa1 	bl	80a5c8e <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a474c:	42af      	cmp	r7, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a474e:	4404      	add	r4, r0
    for (int i = 0; i < 4; i++)
 80a4750:	d101      	bne.n	80a4756 <_ZNK9IPAddress7printToER5Print+0x22>
    }
    return n;
}
 80a4752:	4620      	mov	r0, r4
 80a4754:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (n)
 80a4756:	2c00      	cmp	r4, #0
 80a4758:	d0f2      	beq.n	80a4740 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a475a:	212e      	movs	r1, #46	; 0x2e
 80a475c:	4630      	mov	r0, r6
 80a475e:	f001 fa87 	bl	80a5c70 <_ZN5Print5printEc>
 80a4762:	4404      	add	r4, r0
 80a4764:	e7ec      	b.n	80a4740 <_ZNK9IPAddress7printToER5Print+0xc>
	...

080a4768 <_ZN9IPAddressC1Ev>:
IPAddress::IPAddress()
 80a4768:	b510      	push	{r4, lr}
 80a476a:	4604      	mov	r4, r0
 80a476c:	4b04      	ldr	r3, [pc, #16]	; (80a4780 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a476e:	2211      	movs	r2, #17
 80a4770:	2100      	movs	r1, #0
 80a4772:	f840 3b04 	str.w	r3, [r0], #4
 80a4776:	f003 f89f 	bl	80a78b8 <memset>
}
 80a477a:	4620      	mov	r0, r4
 80a477c:	bd10      	pop	{r4, pc}
 80a477e:	bf00      	nop
 80a4780:	080a7e5c 	.word	0x080a7e5c

080a4784 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:
IPAddress::IPAddress(const HAL_IPAddress& address)
 80a4784:	4603      	mov	r3, r0
 80a4786:	4a07      	ldr	r2, [pc, #28]	; (80a47a4 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a4788:	b510      	push	{r4, lr}
 80a478a:	f843 2b04 	str.w	r2, [r3], #4
    memcpy(&this->address, &address, sizeof(address));
 80a478e:	f101 0210 	add.w	r2, r1, #16
 80a4792:	f851 4b04 	ldr.w	r4, [r1], #4
 80a4796:	4291      	cmp	r1, r2
 80a4798:	f843 4b04 	str.w	r4, [r3], #4
 80a479c:	d1f9      	bne.n	80a4792 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a479e:	780a      	ldrb	r2, [r1, #0]
 80a47a0:	701a      	strb	r2, [r3, #0]
}
 80a47a2:	bd10      	pop	{r4, pc}
 80a47a4:	080a7e5c 	.word	0x080a7e5c

080a47a8 <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint32_t address)
 80a47a8:	4a02      	ldr	r2, [pc, #8]	; (80a47b4 <_ZN9IPAddressC1Em+0xc>)
    address.ipv4 = ipv4;
 80a47aa:	e9c0 2100 	strd	r2, r1, [r0]
        address.v = version;
 80a47ae:	2204      	movs	r2, #4
 80a47b0:	7502      	strb	r2, [r0, #20]
}
 80a47b2:	4770      	bx	lr
 80a47b4:	080a7e5c 	.word	0x080a7e5c

080a47b8 <_ZN9IPAddress8set_ipv4Ehhhh>:
{
 80a47b8:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a47ba:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a47be:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 80a47c2:	2304      	movs	r3, #4
 80a47c4:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80a47c8:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
 80a47cc:	6044      	str	r4, [r0, #4]
 80a47ce:	7503      	strb	r3, [r0, #20]
}
 80a47d0:	bd10      	pop	{r4, pc}
	...

080a47d4 <_ZN9IPAddressC1Ehhhh>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a47d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a47d6:	4d04      	ldr	r5, [pc, #16]	; (80a47e8 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a47d8:	6005      	str	r5, [r0, #0]
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a47da:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a47de:	9500      	str	r5, [sp, #0]
 80a47e0:	f7ff ffea 	bl	80a47b8 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a47e4:	b003      	add	sp, #12
 80a47e6:	bd30      	pop	{r4, r5, pc}
 80a47e8:	080a7e5c 	.word	0x080a7e5c

080a47ec <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t>:

namespace {

// Skips token and all its children tokens if any
const jsmntok_t* skipToken(const jsmntok_t *t) {
    size_t n = 1;
 80a47ec:	2201      	movs	r2, #1
 80a47ee:	f100 0310 	add.w	r3, r0, #16
    do {
        if (t->type == JSMN_OBJECT) {
 80a47f2:	f813 1c10 	ldrb.w	r1, [r3, #-16]
 80a47f6:	4618      	mov	r0, r3
 80a47f8:	2901      	cmp	r1, #1
 80a47fa:	d108      	bne.n	80a480e <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x22>
            n += t->size * 2; // Number of name and value tokens
 80a47fc:	f853 1c04 	ldr.w	r1, [r3, #-4]
 80a4800:	eb02 0241 	add.w	r2, r2, r1, lsl #1
        } else if (t->type == JSMN_ARRAY) {
            n += t->size; // Number of value tokens
        }
        ++t;
        --n;
    } while (n);
 80a4804:	3a01      	subs	r2, #1
 80a4806:	f103 0310 	add.w	r3, r3, #16
 80a480a:	d1f2      	bne.n	80a47f2 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x6>
    return t;
}
 80a480c:	4770      	bx	lr
        } else if (t->type == JSMN_ARRAY) {
 80a480e:	2902      	cmp	r1, #2
            n += t->size; // Number of value tokens
 80a4810:	bf04      	itt	eq
 80a4812:	f853 1c04 	ldreq.w	r1, [r3, #-4]
 80a4816:	1852      	addeq	r2, r2, r1
 80a4818:	e7f4      	b.n	80a4804 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x18>

080a481a <_ZN5spark10JSONWriter6printfEPKcz>:
    write("null", 4);
    state_ = NEXT;
    return *this;
}

void spark::JSONWriter::printf(const char *fmt, ...) {
 80a481a:	b40e      	push	{r1, r2, r3}
 80a481c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a4820:	b087      	sub	sp, #28
 80a4822:	af00      	add	r7, sp, #0
 80a4824:	f107 0534 	add.w	r5, r7, #52	; 0x34
 80a4828:	f855 8b04 	ldr.w	r8, [r5], #4
 80a482c:	4604      	mov	r4, r0
    char buf[16];
    va_list args;
    va_start(args, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a482e:	462b      	mov	r3, r5
 80a4830:	4642      	mov	r2, r8
 80a4832:	2110      	movs	r1, #16
 80a4834:	f107 0008 	add.w	r0, r7, #8
    va_start(args, fmt);
 80a4838:	607d      	str	r5, [r7, #4]
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a483a:	f7ff fec7 	bl	80a45cc <vsnprintf>
    va_end(args);
    if ((size_t)n >= sizeof(buf)) {
 80a483e:	280f      	cmp	r0, #15
 80a4840:	d91b      	bls.n	80a487a <_ZN5spark10JSONWriter6printfEPKcz+0x60>
        char buf[n + 1]; // Use larger buffer
 80a4842:	f100 0308 	add.w	r3, r0, #8
 80a4846:	f023 0307 	bic.w	r3, r3, #7
        va_start(args, fmt);
        n = vsnprintf(buf, sizeof(buf), fmt, args);
        va_end(args);
        if (n > 0) {
            write(buf, n);
        }
 80a484a:	466e      	mov	r6, sp
        char buf[n + 1]; // Use larger buffer
 80a484c:	ebad 0d03 	sub.w	sp, sp, r3
        n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a4850:	4642      	mov	r2, r8
 80a4852:	1c41      	adds	r1, r0, #1
 80a4854:	462b      	mov	r3, r5
 80a4856:	4668      	mov	r0, sp
        va_start(args, fmt);
 80a4858:	607d      	str	r5, [r7, #4]
        n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a485a:	f7ff feb7 	bl	80a45cc <vsnprintf>
        if (n > 0) {
 80a485e:	1e02      	subs	r2, r0, #0
 80a4860:	dd04      	ble.n	80a486c <_ZN5spark10JSONWriter6printfEPKcz+0x52>
            write(buf, n);
 80a4862:	6823      	ldr	r3, [r4, #0]
 80a4864:	4669      	mov	r1, sp
 80a4866:	4620      	mov	r0, r4
 80a4868:	689b      	ldr	r3, [r3, #8]
 80a486a:	4798      	blx	r3
 80a486c:	46b5      	mov	sp, r6
    } else if (n > 0) {
        write(buf, n);
    }
}
 80a486e:	371c      	adds	r7, #28
 80a4870:	46bd      	mov	sp, r7
 80a4872:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80a4876:	b003      	add	sp, #12
 80a4878:	4770      	bx	lr
    } else if (n > 0) {
 80a487a:	2800      	cmp	r0, #0
 80a487c:	d0f7      	beq.n	80a486e <_ZN5spark10JSONWriter6printfEPKcz+0x54>
        write(buf, n);
 80a487e:	6823      	ldr	r3, [r4, #0]
 80a4880:	4602      	mov	r2, r0
 80a4882:	689b      	ldr	r3, [r3, #8]
 80a4884:	4620      	mov	r0, r4
 80a4886:	f107 0108 	add.w	r1, r7, #8
 80a488a:	4798      	blx	r3
}
 80a488c:	e7ef      	b.n	80a486e <_ZN5spark10JSONWriter6printfEPKcz+0x54>

080a488e <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.0>:
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a488e:	b510      	push	{r4, lr}
 80a4890:	4604      	mov	r4, r0
          _M_dispose();
 80a4892:	6803      	ldr	r3, [r0, #0]
 80a4894:	689b      	ldr	r3, [r3, #8]
 80a4896:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a4898:	68a3      	ldr	r3, [r4, #8]
 80a489a:	3b01      	subs	r3, #1
 80a489c:	60a3      	str	r3, [r4, #8]
 80a489e:	b92b      	cbnz	r3, 80a48ac <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.0+0x1e>
            _M_destroy();
 80a48a0:	6823      	ldr	r3, [r4, #0]
 80a48a2:	4620      	mov	r0, r4
    }
 80a48a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            _M_destroy();
 80a48a8:	68db      	ldr	r3, [r3, #12]
 80a48aa:	4718      	bx	r3
    }
 80a48ac:	bd10      	pop	{r4, pc}

080a48ae <_ZN5spark10JSONWriter5writeEc>:

inline spark::JSONWriter& spark::JSONWriter::value(const String &val) {
    return value(val.c_str(), val.length());
}

inline void spark::JSONWriter::write(char c) {
 80a48ae:	b507      	push	{r0, r1, r2, lr}
    write(&c, 1);
 80a48b0:	6803      	ldr	r3, [r0, #0]
inline void spark::JSONWriter::write(char c) {
 80a48b2:	f88d 1007 	strb.w	r1, [sp, #7]
    write(&c, 1);
 80a48b6:	2201      	movs	r2, #1
 80a48b8:	689b      	ldr	r3, [r3, #8]
 80a48ba:	f10d 0107 	add.w	r1, sp, #7
 80a48be:	4798      	blx	r3
}
 80a48c0:	b003      	add	sp, #12
 80a48c2:	f85d fb04 	ldr.w	pc, [sp], #4

080a48c6 <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_>:
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
 80a48c6:	b538      	push	{r3, r4, r5, lr}
 80a48c8:	680b      	ldr	r3, [r1, #0]
 80a48ca:	4604      	mov	r4, r0
 80a48cc:	6003      	str	r3, [r0, #0]
 80a48ce:	684d      	ldr	r5, [r1, #4]
	if (__tmp != _M_pi)
 80a48d0:	6843      	ldr	r3, [r0, #4]
 80a48d2:	429d      	cmp	r5, r3
 80a48d4:	d00c      	beq.n	80a48f0 <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_+0x2a>
	    if (__tmp != 0)
 80a48d6:	b115      	cbz	r5, 80a48de <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_+0x18>
    { ++_M_use_count; }
 80a48d8:	686b      	ldr	r3, [r5, #4]
 80a48da:	3301      	adds	r3, #1
 80a48dc:	606b      	str	r3, [r5, #4]
	    if (_M_pi != 0)
 80a48de:	6860      	ldr	r0, [r4, #4]
 80a48e0:	b128      	cbz	r0, 80a48ee <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_+0x28>
      if (--_M_use_count == 0)
 80a48e2:	6843      	ldr	r3, [r0, #4]
 80a48e4:	3b01      	subs	r3, #1
 80a48e6:	6043      	str	r3, [r0, #4]
 80a48e8:	b90b      	cbnz	r3, 80a48ee <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_+0x28>
 80a48ea:	f7ff ffd0 	bl	80a488e <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.0>
	    _M_pi = __tmp;
 80a48ee:	6065      	str	r5, [r4, #4]
    class __shared_ptr
 80a48f0:	4620      	mov	r0, r4
 80a48f2:	bd38      	pop	{r3, r4, r5, pc}

080a48f4 <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:
spark::JSONValue::JSONValue(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a48f4:	460b      	mov	r3, r1
 80a48f6:	4611      	mov	r1, r2
#if __cplusplus > 201402L
      using weak_type = __weak_ptr<_Tp, _Lp>;
#endif

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
 80a48f8:	2200      	movs	r2, #0
 80a48fa:	b510      	push	{r4, lr}
 80a48fc:	4604      	mov	r4, r0
      constexpr __shared_count() noexcept : _M_pi(0)
 80a48fe:	e9c0 2200 	strd	r2, r2, [r0]
        t_ = t;
 80a4902:	6083      	str	r3, [r0, #8]
    if (t) {
 80a4904:	b90b      	cbnz	r3, 80a490a <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x16>
}
 80a4906:	4620      	mov	r0, r4
 80a4908:	bd10      	pop	{r4, pc}
   *
   *  The object pointed to is deleted when the last shared_ptr pointing to
   *  it is destroyed or reset.
  */
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
 80a490a:	f7ff ffdc 	bl	80a48c6 <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_>
 80a490e:	e7fa      	b.n	80a4906 <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x12>

080a4910 <_ZNK5spark9JSONValue4typeEv>:
spark::JSONType spark::JSONValue::type() const {
 80a4910:	4603      	mov	r3, r0
    if (!t_) {
 80a4912:	6880      	ldr	r0, [r0, #8]
 80a4914:	b320      	cbz	r0, 80a4960 <_ZNK5spark9JSONValue4typeEv+0x50>
    switch (t_->type) {
 80a4916:	7802      	ldrb	r2, [r0, #0]
 80a4918:	2a03      	cmp	r2, #3
 80a491a:	d81a      	bhi.n	80a4952 <_ZNK5spark9JSONValue4typeEv+0x42>
 80a491c:	e8df f002 	tbb	[pc, r2]
 80a4920:	1b021704 	.word	0x1b021704
 80a4924:	2005      	movs	r0, #5
 80a4926:	4770      	bx	lr
        const char c = d_->json[t_->start];
 80a4928:	681b      	ldr	r3, [r3, #0]
 80a492a:	685a      	ldr	r2, [r3, #4]
 80a492c:	6843      	ldr	r3, [r0, #4]
 80a492e:	5cd0      	ldrb	r0, [r2, r3]
        if (c == '-' || (c >= '0' && c <= '9')) {
 80a4930:	282d      	cmp	r0, #45	; 0x2d
 80a4932:	d012      	beq.n	80a495a <_ZNK5spark9JSONValue4typeEv+0x4a>
 80a4934:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 80a4938:	2b09      	cmp	r3, #9
 80a493a:	d90e      	bls.n	80a495a <_ZNK5spark9JSONValue4typeEv+0x4a>
        } else if (c == 't' || c == 'f') { // Literal names are always in lower case
 80a493c:	2874      	cmp	r0, #116	; 0x74
 80a493e:	d00e      	beq.n	80a495e <_ZNK5spark9JSONValue4typeEv+0x4e>
 80a4940:	2866      	cmp	r0, #102	; 0x66
 80a4942:	d00c      	beq.n	80a495e <_ZNK5spark9JSONValue4typeEv+0x4e>
        return JSON_TYPE_INVALID;
 80a4944:	f1a0 036e 	sub.w	r3, r0, #110	; 0x6e
 80a4948:	4258      	negs	r0, r3
 80a494a:	4158      	adcs	r0, r3
 80a494c:	4770      	bx	lr
        return JSON_TYPE_OBJECT;
 80a494e:	2006      	movs	r0, #6
 80a4950:	4770      	bx	lr
        return JSON_TYPE_INVALID;
 80a4952:	2000      	movs	r0, #0
 80a4954:	4770      	bx	lr
        return JSON_TYPE_STRING;
 80a4956:	2004      	movs	r0, #4
 80a4958:	4770      	bx	lr
            return JSON_TYPE_NUMBER;
 80a495a:	2003      	movs	r0, #3
 80a495c:	4770      	bx	lr
            return JSON_TYPE_BOOL;
 80a495e:	2002      	movs	r0, #2
}
 80a4960:	4770      	bx	lr

080a4962 <_ZNK5spark9JSONValue5toIntEv>:
int spark::JSONValue::toInt() const {
 80a4962:	b510      	push	{r4, lr}
 80a4964:	4604      	mov	r4, r0
    switch (type()) {
 80a4966:	f7ff ffd3 	bl	80a4910 <_ZNK5spark9JSONValue4typeEv>
 80a496a:	2802      	cmp	r0, #2
 80a496c:	d00e      	beq.n	80a498c <_ZNK5spark9JSONValue5toIntEv+0x2a>
 80a496e:	1ec3      	subs	r3, r0, #3
 80a4970:	b2db      	uxtb	r3, r3
 80a4972:	2b01      	cmp	r3, #1
 80a4974:	d814      	bhi.n	80a49a0 <_ZNK5spark9JSONValue5toIntEv+0x3e>
        const char* const s = d_->json + t_->start;
 80a4976:	6822      	ldr	r2, [r4, #0]
 80a4978:	68a3      	ldr	r3, [r4, #8]
 80a497a:	6850      	ldr	r0, [r2, #4]
 80a497c:	685b      	ldr	r3, [r3, #4]
        return strtol(s, nullptr, 10);
 80a497e:	220a      	movs	r2, #10
}
 80a4980:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return strtol(s, nullptr, 10);
 80a4984:	2100      	movs	r1, #0
 80a4986:	4418      	add	r0, r3
 80a4988:	f003 b8ee 	b.w	80a7b68 <strtol>
        const char* const s = d_->json + t_->start;
 80a498c:	6822      	ldr	r2, [r4, #0]
 80a498e:	68a3      	ldr	r3, [r4, #8]
        return *s == 't';
 80a4990:	6852      	ldr	r2, [r2, #4]
 80a4992:	685b      	ldr	r3, [r3, #4]
 80a4994:	5cd0      	ldrb	r0, [r2, r3]
 80a4996:	f1a0 0374 	sub.w	r3, r0, #116	; 0x74
 80a499a:	4258      	negs	r0, r3
 80a499c:	4158      	adcs	r0, r3
}
 80a499e:	bd10      	pop	{r4, pc}
    switch (type()) {
 80a49a0:	2000      	movs	r0, #0
 80a49a2:	e7fc      	b.n	80a499e <_ZNK5spark9JSONValue5toIntEv+0x3c>

080a49a4 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:
spark::JSONString::JSONString(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a49a4:	460b      	mov	r3, r1
 80a49a6:	4611      	mov	r1, r2
      : _M_ptr(0), _M_refcount()
 80a49a8:	2200      	movs	r2, #0
 80a49aa:	b510      	push	{r4, lr}
 80a49ac:	4604      	mov	r4, r0
      constexpr __shared_count() noexcept : _M_pi(0)
 80a49ae:	e9c0 2200 	strd	r2, r2, [r0]
        n_(0) {
 80a49b2:	480d      	ldr	r0, [pc, #52]	; (80a49e8 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x44>)
 80a49b4:	e9c4 0202 	strd	r0, r2, [r4, #8]
    if (t && (t->type == JSMN_STRING || t->type == JSMN_PRIMITIVE)) {
 80a49b8:	b1a3      	cbz	r3, 80a49e4 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x40>
 80a49ba:	781a      	ldrb	r2, [r3, #0]
 80a49bc:	2a03      	cmp	r2, #3
 80a49be:	d006      	beq.n	80a49ce <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x2a>
 80a49c0:	b982      	cbnz	r2, 80a49e4 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x40>
        if (t->type != JSMN_PRIMITIVE || d->json[t->start] != 'n') { // Nulls are treated as empty strings
 80a49c2:	680a      	ldr	r2, [r1, #0]
 80a49c4:	6850      	ldr	r0, [r2, #4]
 80a49c6:	685a      	ldr	r2, [r3, #4]
 80a49c8:	5c82      	ldrb	r2, [r0, r2]
 80a49ca:	2a6e      	cmp	r2, #110	; 0x6e
 80a49cc:	d007      	beq.n	80a49de <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x3a>
            s_ = d->json + t->start;
 80a49ce:	680a      	ldr	r2, [r1, #0]
 80a49d0:	6858      	ldr	r0, [r3, #4]
 80a49d2:	6852      	ldr	r2, [r2, #4]
            n_ = t->end - t->start;
 80a49d4:	689b      	ldr	r3, [r3, #8]
            s_ = d->json + t->start;
 80a49d6:	4402      	add	r2, r0
            n_ = t->end - t->start;
 80a49d8:	1a1b      	subs	r3, r3, r0
            s_ = d->json + t->start;
 80a49da:	60a2      	str	r2, [r4, #8]
            n_ = t->end - t->start;
 80a49dc:	60e3      	str	r3, [r4, #12]
 80a49de:	4620      	mov	r0, r4
 80a49e0:	f7ff ff71 	bl	80a48c6 <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_>
}
 80a49e4:	4620      	mov	r0, r4
 80a49e6:	bd10      	pop	{r4, pc}
 80a49e8:	080a7ecd 	.word	0x080a7ecd

080a49ec <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:
spark::JSONObjectIterator::JSONObjectIterator(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a49ec:	b538      	push	{r3, r4, r5, lr}
      : _M_ptr(0), _M_refcount()
 80a49ee:	2500      	movs	r5, #0
 80a49f0:	460b      	mov	r3, r1
 80a49f2:	4604      	mov	r4, r0
 80a49f4:	4611      	mov	r1, r2
      constexpr __shared_count() noexcept : _M_pi(0)
 80a49f6:	e9c0 5500 	strd	r5, r5, [r0]
        n_(0) {
 80a49fa:	e9c0 5502 	strd	r5, r5, [r0, #8]
 80a49fe:	e9c0 5504 	strd	r5, r5, [r0, #16]
    if (t && t->type == JSMN_OBJECT) {
 80a4a02:	b14b      	cbz	r3, 80a4a18 <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x2c>
 80a4a04:	781a      	ldrb	r2, [r3, #0]
 80a4a06:	2a01      	cmp	r2, #1
 80a4a08:	d106      	bne.n	80a4a18 <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x2c>
        t_ = t + 1; // First property's name
 80a4a0a:	f103 0210 	add.w	r2, r3, #16
        n_ = t->size; // Number of properties
 80a4a0e:	68db      	ldr	r3, [r3, #12]
        t_ = t + 1; // First property's name
 80a4a10:	6082      	str	r2, [r0, #8]
        n_ = t->size; // Number of properties
 80a4a12:	6143      	str	r3, [r0, #20]
 80a4a14:	f7ff ff57 	bl	80a48c6 <_ZNSt12__shared_ptrIN5spark6detail8JSONDataELN9__gnu_cxx12_Lock_policyE0EEaSERKS5_>
}
 80a4a18:	4620      	mov	r0, r4
 80a4a1a:	bd38      	pop	{r3, r4, r5, pc}

080a4a1c <_ZN5spark18JSONObjectIterator4nextEv>:
bool spark::JSONObjectIterator::next() {
 80a4a1c:	b510      	push	{r4, lr}
    if (!n_) {
 80a4a1e:	6943      	ldr	r3, [r0, #20]
bool spark::JSONObjectIterator::next() {
 80a4a20:	4604      	mov	r4, r0
    if (!n_) {
 80a4a22:	b163      	cbz	r3, 80a4a3e <_ZN5spark18JSONObjectIterator4nextEv+0x22>
    k_ = t_; // Name
 80a4a24:	6880      	ldr	r0, [r0, #8]
    --n_;
 80a4a26:	3b01      	subs	r3, #1
    k_ = t_; // Name
 80a4a28:	60e0      	str	r0, [r4, #12]
    ++t_;
 80a4a2a:	3010      	adds	r0, #16
 80a4a2c:	60a0      	str	r0, [r4, #8]
    v_ = t_; // Value
 80a4a2e:	6120      	str	r0, [r4, #16]
    --n_;
 80a4a30:	6163      	str	r3, [r4, #20]
    if (n_) {
 80a4a32:	b113      	cbz	r3, 80a4a3a <_ZN5spark18JSONObjectIterator4nextEv+0x1e>
        t_ = skipToken(t_);
 80a4a34:	f7ff feda 	bl	80a47ec <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t>
 80a4a38:	60a0      	str	r0, [r4, #8]
    return true;
 80a4a3a:	2001      	movs	r0, #1
 80a4a3c:	e000      	b.n	80a4a40 <_ZN5spark18JSONObjectIterator4nextEv+0x24>
        return false;
 80a4a3e:	4618      	mov	r0, r3
}
 80a4a40:	bd10      	pop	{r4, pc}

080a4a42 <_ZN5spark10JSONWriter9endObjectEv>:
spark::JSONWriter& spark::JSONWriter::endObject() {
 80a4a42:	b510      	push	{r4, lr}
    write('}');
 80a4a44:	217d      	movs	r1, #125	; 0x7d
spark::JSONWriter& spark::JSONWriter::endObject() {
 80a4a46:	4604      	mov	r4, r0
    write('}');
 80a4a48:	f7ff ff31 	bl	80a48ae <_ZN5spark10JSONWriter5writeEc>
    state_ = NEXT;
 80a4a4c:	2301      	movs	r3, #1
}
 80a4a4e:	4620      	mov	r0, r4
    state_ = NEXT;
 80a4a50:	7123      	strb	r3, [r4, #4]
}
 80a4a52:	bd10      	pop	{r4, pc}

080a4a54 <_ZN5spark10JSONWriter14writeSeparatorEv>:

void spark::JSONWriter::writeSeparator() {
 80a4a54:	b508      	push	{r3, lr}
    switch (state_) {
 80a4a56:	7903      	ldrb	r3, [r0, #4]
 80a4a58:	2b01      	cmp	r3, #1
 80a4a5a:	d002      	beq.n	80a4a62 <_ZN5spark10JSONWriter14writeSeparatorEv+0xe>
 80a4a5c:	2b02      	cmp	r3, #2
 80a4a5e:	d004      	beq.n	80a4a6a <_ZN5spark10JSONWriter14writeSeparatorEv+0x16>
        write(':');
        break;
    default:
        break;
    }
}
 80a4a60:	bd08      	pop	{r3, pc}
        write(',');
 80a4a62:	212c      	movs	r1, #44	; 0x2c
        write(':');
 80a4a64:	f7ff ff23 	bl	80a48ae <_ZN5spark10JSONWriter5writeEc>
}
 80a4a68:	e7fa      	b.n	80a4a60 <_ZN5spark10JSONWriter14writeSeparatorEv+0xc>
        write(':');
 80a4a6a:	213a      	movs	r1, #58	; 0x3a
 80a4a6c:	e7fa      	b.n	80a4a64 <_ZN5spark10JSONWriter14writeSeparatorEv+0x10>

080a4a6e <_ZN5spark10JSONWriter11beginObjectEv>:
spark::JSONWriter& spark::JSONWriter::beginObject() {
 80a4a6e:	b510      	push	{r4, lr}
 80a4a70:	4604      	mov	r4, r0
    writeSeparator();
 80a4a72:	f7ff ffef 	bl	80a4a54 <_ZN5spark10JSONWriter14writeSeparatorEv>
    write('{');
 80a4a76:	4620      	mov	r0, r4
 80a4a78:	217b      	movs	r1, #123	; 0x7b
 80a4a7a:	f7ff ff18 	bl	80a48ae <_ZN5spark10JSONWriter5writeEc>
    state_ = BEGIN;
 80a4a7e:	2300      	movs	r3, #0
}
 80a4a80:	4620      	mov	r0, r4
    state_ = BEGIN;
 80a4a82:	7123      	strb	r3, [r4, #4]
}
 80a4a84:	bd10      	pop	{r4, pc}
	...

080a4a88 <_ZN5spark10JSONWriter5valueEi>:
spark::JSONWriter& spark::JSONWriter::value(int val) {
 80a4a88:	b538      	push	{r3, r4, r5, lr}
 80a4a8a:	4604      	mov	r4, r0
 80a4a8c:	460d      	mov	r5, r1
    writeSeparator();
 80a4a8e:	f7ff ffe1 	bl	80a4a54 <_ZN5spark10JSONWriter14writeSeparatorEv>
    printf("%d", val);
 80a4a92:	6823      	ldr	r3, [r4, #0]
 80a4a94:	4620      	mov	r0, r4
 80a4a96:	462a      	mov	r2, r5
 80a4a98:	68db      	ldr	r3, [r3, #12]
 80a4a9a:	4903      	ldr	r1, [pc, #12]	; (80a4aa8 <_ZN5spark10JSONWriter5valueEi+0x20>)
 80a4a9c:	4798      	blx	r3
    state_ = NEXT;
 80a4a9e:	2301      	movs	r3, #1
}
 80a4aa0:	4620      	mov	r0, r4
    state_ = NEXT;
 80a4aa2:	7123      	strb	r3, [r4, #4]
}
 80a4aa4:	bd38      	pop	{r3, r4, r5, pc}
 80a4aa6:	bf00      	nop
 80a4aa8:	080a7e68 	.word	0x080a7e68

080a4aac <_ZN5spark10JSONWriter5valueEj>:
spark::JSONWriter& spark::JSONWriter::value(unsigned val) {
 80a4aac:	b538      	push	{r3, r4, r5, lr}
 80a4aae:	4604      	mov	r4, r0
 80a4ab0:	460d      	mov	r5, r1
    writeSeparator();
 80a4ab2:	f7ff ffcf 	bl	80a4a54 <_ZN5spark10JSONWriter14writeSeparatorEv>
    printf("%u", val);
 80a4ab6:	6823      	ldr	r3, [r4, #0]
 80a4ab8:	4620      	mov	r0, r4
 80a4aba:	462a      	mov	r2, r5
 80a4abc:	68db      	ldr	r3, [r3, #12]
 80a4abe:	4903      	ldr	r1, [pc, #12]	; (80a4acc <_ZN5spark10JSONWriter5valueEj+0x20>)
 80a4ac0:	4798      	blx	r3
    state_ = NEXT;
 80a4ac2:	2301      	movs	r3, #1
}
 80a4ac4:	4620      	mov	r0, r4
    state_ = NEXT;
 80a4ac6:	7123      	strb	r3, [r4, #4]
}
 80a4ac8:	bd38      	pop	{r3, r4, r5, pc}
 80a4aca:	bf00      	nop
 80a4acc:	080a7e6b 	.word	0x080a7e6b

080a4ad0 <_ZN5spark10JSONWriter12writeEscapedEPKcj>:

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a4ad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a4ad4:	460d      	mov	r5, r1
 80a4ad6:	4617      	mov	r7, r2
    write('"');
 80a4ad8:	2122      	movs	r1, #34	; 0x22
void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a4ada:	4604      	mov	r4, r0
    write('"');
 80a4adc:	f7ff fee7 	bl	80a48ae <_ZN5spark10JSONWriter5writeEc>
    const char* const end = str + size;
 80a4ae0:	4629      	mov	r1, r5
            case 0x0d: // Carriage return
                write('r');
                break;
            default:
                // All other control characters are written in hex, e.g. "\u001f"
                printf("u%04x", (unsigned)c);
 80a4ae2:	f8df 8098 	ldr.w	r8, [pc, #152]	; 80a4b7c <_ZN5spark10JSONWriter12writeEscapedEPKcj+0xac>
    const char* const end = str + size;
 80a4ae6:	442f      	add	r7, r5
    while (s != end) {
 80a4ae8:	42bd      	cmp	r5, r7
 80a4aea:	462a      	mov	r2, r5
 80a4aec:	d038      	beq.n	80a4b60 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x90>
        const char c = *s;
 80a4aee:	f815 6b01 	ldrb.w	r6, [r5], #1
        if (c == '"' || c == '\\' || (c >= 0 && c <= 0x1f)) {
 80a4af2:	2e22      	cmp	r6, #34	; 0x22
 80a4af4:	d003      	beq.n	80a4afe <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2e>
 80a4af6:	2e5c      	cmp	r6, #92	; 0x5c
 80a4af8:	d001      	beq.n	80a4afe <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2e>
 80a4afa:	2e1f      	cmp	r6, #31
 80a4afc:	d8f4      	bhi.n	80a4ae8 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x18>
            write(str, s - str); // Write preceeding characters
 80a4afe:	6823      	ldr	r3, [r4, #0]
 80a4b00:	1a52      	subs	r2, r2, r1
 80a4b02:	4620      	mov	r0, r4
 80a4b04:	689b      	ldr	r3, [r3, #8]
 80a4b06:	4798      	blx	r3
            write('\\');
 80a4b08:	215c      	movs	r1, #92	; 0x5c
 80a4b0a:	4620      	mov	r0, r4
 80a4b0c:	f7ff fecf 	bl	80a48ae <_ZN5spark10JSONWriter5writeEc>
            switch (c) {
 80a4b10:	2e0d      	cmp	r6, #13
 80a4b12:	d80a      	bhi.n	80a4b2a <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x5a>
 80a4b14:	2e07      	cmp	r6, #7
 80a4b16:	d91c      	bls.n	80a4b52 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x82>
 80a4b18:	f1a6 0308 	sub.w	r3, r6, #8
 80a4b1c:	2b05      	cmp	r3, #5
 80a4b1e:	d818      	bhi.n	80a4b52 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x82>
 80a4b20:	e8df f003 	tbb	[pc, r3]
 80a4b24:	17110f0d 	.word	0x17110f0d
 80a4b28:	1513      	.short	0x1513
 80a4b2a:	2e22      	cmp	r6, #34	; 0x22
 80a4b2c:	d001      	beq.n	80a4b32 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x62>
 80a4b2e:	2e5c      	cmp	r6, #92	; 0x5c
 80a4b30:	d10f      	bne.n	80a4b52 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x82>
                write(c);
 80a4b32:	4631      	mov	r1, r6
                write('b');
 80a4b34:	4620      	mov	r0, r4
 80a4b36:	f7ff feba 	bl	80a48ae <_ZN5spark10JSONWriter5writeEc>
                break;
            }
            str = s + 1;
 80a4b3a:	4629      	mov	r1, r5
    while (s != end) {
 80a4b3c:	e7d4      	b.n	80a4ae8 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x18>
                write('b');
 80a4b3e:	2162      	movs	r1, #98	; 0x62
 80a4b40:	e7f8      	b.n	80a4b34 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x64>
                write('t');
 80a4b42:	2174      	movs	r1, #116	; 0x74
 80a4b44:	e7f6      	b.n	80a4b34 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x64>
                write('n');
 80a4b46:	216e      	movs	r1, #110	; 0x6e
 80a4b48:	e7f4      	b.n	80a4b34 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x64>
                write('f');
 80a4b4a:	2166      	movs	r1, #102	; 0x66
 80a4b4c:	e7f2      	b.n	80a4b34 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x64>
                write('r');
 80a4b4e:	2172      	movs	r1, #114	; 0x72
 80a4b50:	e7f0      	b.n	80a4b34 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x64>
                printf("u%04x", (unsigned)c);
 80a4b52:	6823      	ldr	r3, [r4, #0]
 80a4b54:	4632      	mov	r2, r6
 80a4b56:	4641      	mov	r1, r8
 80a4b58:	4620      	mov	r0, r4
 80a4b5a:	68db      	ldr	r3, [r3, #12]
 80a4b5c:	4798      	blx	r3
                break;
 80a4b5e:	e7ec      	b.n	80a4b3a <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x6a>
        }
        ++s;
    }
    if (s != str) {
 80a4b60:	428d      	cmp	r5, r1
 80a4b62:	d004      	beq.n	80a4b6e <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x9e>
        write(str, s - str); // Write remaining characters
 80a4b64:	6823      	ldr	r3, [r4, #0]
 80a4b66:	4620      	mov	r0, r4
 80a4b68:	689b      	ldr	r3, [r3, #8]
 80a4b6a:	1a6a      	subs	r2, r5, r1
 80a4b6c:	4798      	blx	r3
    }
    write('"');
 80a4b6e:	2122      	movs	r1, #34	; 0x22
 80a4b70:	4620      	mov	r0, r4
 80a4b72:	f7ff fe9c 	bl	80a48ae <_ZN5spark10JSONWriter5writeEc>
}
 80a4b76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a4b7a:	bf00      	nop
 80a4b7c:	080a7e6e 	.word	0x080a7e6e

080a4b80 <_ZN5spark10JSONWriter4nameEPKcj>:
spark::JSONWriter& spark::JSONWriter::name(const char *name, size_t size) {
 80a4b80:	b570      	push	{r4, r5, r6, lr}
 80a4b82:	4604      	mov	r4, r0
 80a4b84:	460d      	mov	r5, r1
 80a4b86:	4616      	mov	r6, r2
    writeSeparator();
 80a4b88:	f7ff ff64 	bl	80a4a54 <_ZN5spark10JSONWriter14writeSeparatorEv>
    writeEscaped(name, size);
 80a4b8c:	4620      	mov	r0, r4
 80a4b8e:	4632      	mov	r2, r6
 80a4b90:	4629      	mov	r1, r5
 80a4b92:	f7ff ff9d 	bl	80a4ad0 <_ZN5spark10JSONWriter12writeEscapedEPKcj>
    state_ = VALUE;
 80a4b96:	2302      	movs	r3, #2
}
 80a4b98:	4620      	mov	r0, r4
    state_ = VALUE;
 80a4b9a:	7123      	strb	r3, [r4, #4]
}
 80a4b9c:	bd70      	pop	{r4, r5, r6, pc}

080a4b9e <_ZN5spark10JSONWriter5valueEPKcj>:
spark::JSONWriter& spark::JSONWriter::value(const char *val, size_t size) {
 80a4b9e:	b570      	push	{r4, r5, r6, lr}
 80a4ba0:	4604      	mov	r4, r0
 80a4ba2:	460d      	mov	r5, r1
 80a4ba4:	4616      	mov	r6, r2
    writeSeparator();
 80a4ba6:	f7ff ff55 	bl	80a4a54 <_ZN5spark10JSONWriter14writeSeparatorEv>
    writeEscaped(val, size);
 80a4baa:	4620      	mov	r0, r4
 80a4bac:	4632      	mov	r2, r6
 80a4bae:	4629      	mov	r1, r5
 80a4bb0:	f7ff ff8e 	bl	80a4ad0 <_ZN5spark10JSONWriter12writeEscapedEPKcj>
    state_ = NEXT;
 80a4bb4:	2301      	movs	r3, #1
}
 80a4bb6:	4620      	mov	r0, r4
    state_ = NEXT;
 80a4bb8:	7123      	strb	r3, [r4, #4]
}
 80a4bba:	bd70      	pop	{r4, r5, r6, pc}

080a4bbc <_ZN5spark16JSONStreamWriter5writeEPKcj>:
inline Print* spark::JSONStreamWriter::stream() const {
    return &strm_;
}

inline void spark::JSONStreamWriter::write(const char *data, size_t size) {
    strm_.write((const uint8_t*)data, size);
 80a4bbc:	6880      	ldr	r0, [r0, #8]
 80a4bbe:	6803      	ldr	r3, [r0, #0]
 80a4bc0:	68db      	ldr	r3, [r3, #12]
 80a4bc2:	4718      	bx	r3

080a4bc4 <_ZN5spark20JSONStreamLogHandler5writeEPKcj>:
}

// spark::JSONStreamLogHandler
inline void spark::JSONStreamLogHandler::write(const char *data, size_t size) {
    // This handler doesn't support direct logging
}
 80a4bc4:	4770      	bx	lr

080a4bc6 <_ZN5spark17LogHandlerFactory14destroyHandlerEPNS_10LogHandlerE>:

#if Wiring_LogConfig

// spark::LogHandlerFactory
inline void spark::LogHandlerFactory::destroyHandler(LogHandler *handler) {
    delete handler;
 80a4bc6:	4608      	mov	r0, r1
 80a4bc8:	b111      	cbz	r1, 80a4bd0 <_ZN5spark17LogHandlerFactory14destroyHandlerEPNS_10LogHandlerE+0xa>
 80a4bca:	680b      	ldr	r3, [r1, #0]
 80a4bcc:	685b      	ldr	r3, [r3, #4]
 80a4bce:	4718      	bx	r3
}
 80a4bd0:	4770      	bx	lr

080a4bd2 <__tcf_0>:
    }
    return nullptr; // Unknown handler type
}

spark::DefaultLogHandlerFactory* spark::DefaultLogHandlerFactory::instance() {
    static DefaultLogHandlerFactory factory;
 80a4bd2:	4770      	bx	lr

080a4bd4 <_ZN5spark26DefaultOutputStreamFactoryD1Ev>:
class DefaultOutputStreamFactory: public OutputStreamFactory {
 80a4bd4:	4770      	bx	lr

080a4bd6 <_ZN5spark24DefaultLogHandlerFactoryD1Ev>:
class DefaultLogHandlerFactory: public LogHandlerFactory {
 80a4bd6:	4770      	bx	lr

080a4bd8 <_ZN5spark16JSONStreamWriterD1Ev>:
class JSONStreamWriter: public JSONWriter {
 80a4bd8:	4770      	bx	lr

080a4bda <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>:
const char* nextSubcategoryName(const char* &category, size_t &size) {
 80a4bda:	b538      	push	{r3, r4, r5, lr}
 80a4bdc:	4604      	mov	r4, r0
 80a4bde:	460d      	mov	r5, r1
    const char *s = strchrnul(category, '.');
 80a4be0:	6800      	ldr	r0, [r0, #0]
 80a4be2:	212e      	movs	r1, #46	; 0x2e
 80a4be4:	f002 fed5 	bl	80a7992 <strchrnul>
    size = s - category;
 80a4be8:	6823      	ldr	r3, [r4, #0]
    const char *s = strchrnul(category, '.');
 80a4bea:	4602      	mov	r2, r0
    size = s - category;
 80a4bec:	1ac0      	subs	r0, r0, r3
 80a4bee:	6028      	str	r0, [r5, #0]
    if (size) {
 80a4bf0:	b120      	cbz	r0, 80a4bfc <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj+0x22>
        if (*s) {
 80a4bf2:	7813      	ldrb	r3, [r2, #0]
 80a4bf4:	b103      	cbz	r3, 80a4bf8 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj+0x1e>
            ++s;
 80a4bf6:	3201      	adds	r2, #1
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a4bf8:	6820      	ldr	r0, [r4, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a4bfa:	6022      	str	r2, [r4, #0]
}
 80a4bfc:	bd38      	pop	{r3, r4, r5, pc}

080a4bfe <_ZN5spark16JSONStreamWriterD0Ev>:
 80a4bfe:	b510      	push	{r4, lr}
 80a4c00:	4604      	mov	r4, r0
 80a4c02:	210c      	movs	r1, #12
 80a4c04:	f001 fe24 	bl	80a6850 <_ZdlPvj>
 80a4c08:	4620      	mov	r0, r4
 80a4c0a:	bd10      	pop	{r4, pc}

080a4c0c <_ZN5spark24DefaultLogHandlerFactoryD0Ev>:
 80a4c0c:	b510      	push	{r4, lr}
 80a4c0e:	4604      	mov	r4, r0
 80a4c10:	2104      	movs	r1, #4
 80a4c12:	f001 fe1d 	bl	80a6850 <_ZdlPvj>
 80a4c16:	4620      	mov	r0, r4
 80a4c18:	bd10      	pop	{r4, pc}

080a4c1a <_ZN5spark26DefaultOutputStreamFactoryD0Ev>:
class DefaultOutputStreamFactory: public OutputStreamFactory {
 80a4c1a:	b510      	push	{r4, lr}
 80a4c1c:	4604      	mov	r4, r0
 80a4c1e:	2104      	movs	r1, #4
 80a4c20:	f001 fe16 	bl	80a6850 <_ZdlPvj>
 80a4c24:	4620      	mov	r0, r4
 80a4c26:	bd10      	pop	{r4, pc}

080a4c28 <_ZNK5spark10JSONStringeqEPKc.isra.0>:
inline bool spark::JSONString::operator==(const char *str) const {
 80a4c28:	b508      	push	{r3, lr}
    return strcmp(s_, str) == 0;
 80a4c2a:	f002 febc 	bl	80a79a6 <strcmp>
}
 80a4c2e:	fab0 f080 	clz	r0, r0
 80a4c32:	0940      	lsrs	r0, r0, #5
 80a4c34:	bd08      	pop	{r3, pc}

080a4c36 <__tcf_1>:
 80a4c36:	4770      	bx	lr

080a4c38 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print>:
    }
#endif // PLATFORM_ID != 3
    return nullptr;
}

void spark::DefaultOutputStreamFactory::destroyStream(Print *stream) {
 80a4c38:	b510      	push	{r4, lr}
 80a4c3a:	460c      	mov	r4, r1
#if PLATFORM_ID != 3
    if (stream == &Serial) {
 80a4c3c:	f001 fb60 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a4c40:	4284      	cmp	r4, r0
 80a4c42:	d105      	bne.n	80a4c50 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x18>
        // FIXME: Uninitializing Serial detaches a Gen 3 device from the host
#if !HAL_PLATFORM_NRF52840
        Serial.end();
 80a4c44:	f001 fb5c 	bl	80a6300 <_Z16_fetch_usbserialv>
        Serial1.end();
        return;
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
}
 80a4c48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        USBSerial1.end();
 80a4c4c:	f001 bb3e 	b.w	80a62cc <_ZN9USBSerial3endEv>
    if (stream == &USBSerial1) {
 80a4c50:	f001 fb90 	bl	80a6374 <_Z17_fetch_usbserial1v>
 80a4c54:	4284      	cmp	r4, r0
 80a4c56:	d102      	bne.n	80a4c5e <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x26>
        USBSerial1.end();
 80a4c58:	f001 fb8c 	bl	80a6374 <_Z17_fetch_usbserial1v>
 80a4c5c:	e7f4      	b.n	80a4c48 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x10>
    if (stream == &Serial1) {
 80a4c5e:	f001 fabb 	bl	80a61d8 <_Z22__fetch_global_Serial1v>
 80a4c62:	4284      	cmp	r4, r0
 80a4c64:	d105      	bne.n	80a4c72 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x3a>
        Serial1.end();
 80a4c66:	f001 fab7 	bl	80a61d8 <_Z22__fetch_global_Serial1v>
}
 80a4c6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        Serial1.end();
 80a4c6e:	f001 bab0 	b.w	80a61d2 <_ZN11USARTSerial3endEv>

// spark::OutputStreamFactory
inline void spark::OutputStreamFactory::destroyStream(Print *stream) {
    delete stream;
 80a4c72:	b12c      	cbz	r4, 80a4c80 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x48>
 80a4c74:	6823      	ldr	r3, [r4, #0]
 80a4c76:	4620      	mov	r0, r4
}
 80a4c78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a4c7c:	685b      	ldr	r3, [r3, #4]
 80a4c7e:	4718      	bx	r3
 80a4c80:	bd10      	pop	{r4, pc}

080a4c82 <_ZN5spark10JSONWriter5valueEPKc>:
inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
 80a4c82:	b538      	push	{r3, r4, r5, lr}
 80a4c84:	4605      	mov	r5, r0
    return value(val, strlen(val));
 80a4c86:	4608      	mov	r0, r1
inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
 80a4c88:	460c      	mov	r4, r1
    return value(val, strlen(val));
 80a4c8a:	f002 fe9e 	bl	80a79ca <strlen>
 80a4c8e:	4621      	mov	r1, r4
 80a4c90:	4602      	mov	r2, r0
 80a4c92:	4628      	mov	r0, r5
}
 80a4c94:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return value(val, strlen(val));
 80a4c98:	f7ff bf81 	b.w	80a4b9e <_ZN5spark10JSONWriter5valueEPKcj>

080a4c9c <_ZN5spark16StreamLogHandler5writeEPKc>:
inline void spark::StreamLogHandler::write(const char *str) {
 80a4c9c:	b570      	push	{r4, r5, r6, lr}
 80a4c9e:	4604      	mov	r4, r0
    write(str, strlen(str));
 80a4ca0:	4608      	mov	r0, r1
inline void spark::StreamLogHandler::write(const char *str) {
 80a4ca2:	460d      	mov	r5, r1
    write(str, strlen(str));
 80a4ca4:	f002 fe91 	bl	80a79ca <strlen>
 80a4ca8:	6823      	ldr	r3, [r4, #0]
 80a4caa:	4602      	mov	r2, r0
 80a4cac:	4629      	mov	r1, r5
 80a4cae:	4620      	mov	r0, r4
}
 80a4cb0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    write(str, strlen(str));
 80a4cb4:	68db      	ldr	r3, [r3, #12]
 80a4cb6:	4718      	bx	r3

080a4cb8 <_ZN5spark16StreamLogHandler5writeEc>:
inline void spark::StreamLogHandler::write(char c) {
 80a4cb8:	b507      	push	{r0, r1, r2, lr}
    write(&c, 1);
 80a4cba:	6803      	ldr	r3, [r0, #0]
inline void spark::StreamLogHandler::write(char c) {
 80a4cbc:	f88d 1007 	strb.w	r1, [sp, #7]
    write(&c, 1);
 80a4cc0:	2201      	movs	r2, #1
 80a4cc2:	68db      	ldr	r3, [r3, #12]
 80a4cc4:	f10d 0107 	add.w	r1, sp, #7
 80a4cc8:	4798      	blx	r3
}
 80a4cca:	b003      	add	sp, #12
 80a4ccc:	f85d fb04 	ldr.w	pc, [sp], #4

080a4cd0 <_ZN5spark16StreamLogHandler6printfEPKcz>:
inline void spark::StreamLogHandler::printf(const char *fmt, ...) {
 80a4cd0:	b40e      	push	{r1, r2, r3}
 80a4cd2:	b503      	push	{r0, r1, lr}
 80a4cd4:	ab03      	add	r3, sp, #12
 80a4cd6:	f853 2b04 	ldr.w	r2, [r3], #4
    stream_->vprintf(false, fmt, args);
 80a4cda:	2100      	movs	r1, #0
 80a4cdc:	6a00      	ldr	r0, [r0, #32]
    va_start(args, fmt);
 80a4cde:	9301      	str	r3, [sp, #4]
    stream_->vprintf(false, fmt, args);
 80a4ce0:	f000 fff2 	bl	80a5cc8 <_ZN5Print7vprintfEbPKcSt9__va_list>
}
 80a4ce4:	b002      	add	sp, #8
 80a4ce6:	f85d eb04 	ldr.w	lr, [sp], #4
 80a4cea:	b003      	add	sp, #12
 80a4cec:	4770      	bx	lr
	...

080a4cf0 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>:
int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
 80a4cf0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return data_ + size_;
}

template<typename T, typename AllocatorT>
const T* spark::Vector<T, AllocatorT>::end() const {
    return data_ + size_;
 80a4cf4:	f04f 0814 	mov.w	r8, #20
 80a4cf8:	e9d0 9500 	ldrd	r9, r5, [r0]
 80a4cfc:	4617      	mov	r7, r2
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
 80a4cfe:	464c      	mov	r4, r9
 80a4d00:	fb08 f505 	mul.w	r5, r8, r5
 80a4d04:	9300      	str	r3, [sp, #0]
 80a4d06:	10ab      	asrs	r3, r5, #2
 80a4d08:	4d17      	ldr	r5, [pc, #92]	; (80a4d68 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x78>)
 80a4d0a:	435d      	muls	r5, r3
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 80a4d0c:	2d00      	cmp	r5, #0
 80a4d0e:	dd23      	ble.n	80a4d58 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x68>
	{
	  _DistanceType __half = __len >> 1;
 80a4d10:	106e      	asrs	r6, r5, #1
      if (__builtin_constant_p(__n) && __n == 1)
	++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
	--__i;
      else
	__i += __n;
 80a4d12:	fb08 f006 	mul.w	r0, r8, r6
 80a4d16:	eb04 0a00 	add.w	sl, r4, r0
                const int cmp = strncmp(node.name, value.first, std::min<size_t>(node.size, value.second));
 80a4d1a:	f8ba b004 	ldrh.w	fp, [sl, #4]
 80a4d1e:	463a      	mov	r2, r7
 80a4d20:	455f      	cmp	r7, fp
 80a4d22:	bf28      	it	cs
 80a4d24:	465a      	movcs	r2, fp
 80a4d26:	5820      	ldr	r0, [r4, r0]
 80a4d28:	9101      	str	r1, [sp, #4]
 80a4d2a:	f002 fe69 	bl	80a7a00 <strncmp>
                if (cmp == 0) {
 80a4d2e:	2301      	movs	r3, #1
 80a4d30:	9901      	ldr	r1, [sp, #4]
 80a4d32:	b978      	cbnz	r0, 80a4d54 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x64>
                    if (node.size == value.second) { // Lengths are equal
 80a4d34:	455f      	cmp	r7, fp
 80a4d36:	d103      	bne.n	80a4d40 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x50>
                        found = true; // Allows caller code to avoid extra call to strncmp()
 80a4d38:	9a00      	ldr	r2, [sp, #0]
 80a4d3a:	7013      	strb	r3, [r2, #0]
int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
 80a4d3c:	4635      	mov	r5, r6
 80a4d3e:	e7e5      	b.n	80a4d0c <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x1c>
                    return node.size < value.second;
 80a4d40:	bf8c      	ite	hi
 80a4d42:	2001      	movhi	r0, #1
 80a4d44:	2000      	movls	r0, #0
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__middle, __val))
 80a4d46:	2800      	cmp	r0, #0
 80a4d48:	d0f8      	beq.n	80a4d3c <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x4c>
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
 80a4d4a:	1bae      	subs	r6, r5, r6
	      ++__first;
 80a4d4c:	f10a 0414 	add.w	r4, sl, #20
	      __len = __len - __half - 1;
 80a4d50:	3e01      	subs	r6, #1
 80a4d52:	e7f3      	b.n	80a4d3c <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x4c>
                return cmp < 0;
 80a4d54:	0fc0      	lsrs	r0, r0, #31
 80a4d56:	e7f6      	b.n	80a4d46 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x56>
      return __last - __first;
 80a4d58:	eba4 0409 	sub.w	r4, r4, r9
}
 80a4d5c:	4802      	ldr	r0, [pc, #8]	; (80a4d68 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x78>)
 80a4d5e:	10a4      	asrs	r4, r4, #2
 80a4d60:	4360      	muls	r0, r4
 80a4d62:	b003      	add	sp, #12
 80a4d64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4d68:	cccccccd 	.word	0xcccccccd

080a4d6c <_ZNK5spark6detail9LogFilter5levelEPKc>:
LogLevel spark::detail::LogFilter::level(const char *category) const {
 80a4d6c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    if (!nodes_.isEmpty() && category) {
 80a4d6e:	6903      	ldr	r3, [r0, #16]
    LogLevel level = level_; // Default level
 80a4d70:	7e06      	ldrb	r6, [r0, #24]
LogLevel spark::detail::LogFilter::level(const char *category) const {
 80a4d72:	9101      	str	r1, [sp, #4]
    if (!nodes_.isEmpty() && category) {
 80a4d74:	b303      	cbz	r3, 80a4db8 <_ZNK5spark6detail9LogFilter5levelEPKc+0x4c>
 80a4d76:	b1f9      	cbz	r1, 80a4db8 <_ZNK5spark6detail9LogFilter5levelEPKc+0x4c>
        size_t size = 0; // Name length
 80a4d78:	2500      	movs	r5, #0
        const Vector<Node> *pNodes = &nodes_; // Root nodes
 80a4d7a:	f100 040c 	add.w	r4, r0, #12
        size_t size = 0; // Name length
 80a4d7e:	9503      	str	r5, [sp, #12]
        while ((name = nextSubcategoryName(category, size))) {
 80a4d80:	a903      	add	r1, sp, #12
 80a4d82:	a801      	add	r0, sp, #4
 80a4d84:	f7ff ff29 	bl	80a4bda <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>
 80a4d88:	4601      	mov	r1, r0
 80a4d8a:	b1a8      	cbz	r0, 80a4db8 <_ZNK5spark6detail9LogFilter5levelEPKc+0x4c>
            const int index = nodeIndex(*pNodes, name, size, found);
 80a4d8c:	f10d 030b 	add.w	r3, sp, #11
 80a4d90:	4620      	mov	r0, r4
 80a4d92:	9a03      	ldr	r2, [sp, #12]
            bool found = false;
 80a4d94:	f88d 500b 	strb.w	r5, [sp, #11]
            const int index = nodeIndex(*pNodes, name, size, found);
 80a4d98:	f7ff ffaa 	bl	80a4cf0 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>
            if (!found) {
 80a4d9c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80a4da0:	b153      	cbz	r3, 80a4db8 <_ZNK5spark6detail9LogFilter5levelEPKc+0x4c>
    return data_[i];
 80a4da2:	2314      	movs	r3, #20
 80a4da4:	6824      	ldr	r4, [r4, #0]
 80a4da6:	fb03 4400 	mla	r4, r3, r0, r4
            if (node.level >= 0) {
 80a4daa:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
            pNodes = &node.nodes;
 80a4dae:	3408      	adds	r4, #8
            if (node.level >= 0) {
 80a4db0:	2b00      	cmp	r3, #0
                level = (LogLevel)node.level;
 80a4db2:	bfa8      	it	ge
 80a4db4:	b2de      	uxtbge	r6, r3
        while ((name = nextSubcategoryName(category, size))) {
 80a4db6:	e7e3      	b.n	80a4d80 <_ZNK5spark6detail9LogFilter5levelEPKc+0x14>
}
 80a4db8:	4630      	mov	r0, r6
 80a4dba:	b004      	add	sp, #16
 80a4dbc:	bd70      	pop	{r4, r5, r6, pc}
	...

080a4dc0 <_ZN5spark24DefaultLogHandlerFactory8instanceEv>:
spark::DefaultLogHandlerFactory* spark::DefaultLogHandlerFactory::instance() {
 80a4dc0:	b510      	push	{r4, lr}
    static DefaultLogHandlerFactory factory;
 80a4dc2:	4c09      	ldr	r4, [pc, #36]	; (80a4de8 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x28>)
 80a4dc4:	7823      	ldrb	r3, [r4, #0]
 80a4dc6:	f3bf 8f5b 	dmb	ish
 80a4dca:	07db      	lsls	r3, r3, #31
 80a4dcc:	d409      	bmi.n	80a4de2 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x22>
 80a4dce:	4620      	mov	r0, r4
 80a4dd0:	f7fb f972 	bl	80a00b8 <__cxa_guard_acquire>
 80a4dd4:	b128      	cbz	r0, 80a4de2 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x22>
 80a4dd6:	4620      	mov	r0, r4
 80a4dd8:	f7fb f973 	bl	80a00c2 <__cxa_guard_release>
 80a4ddc:	4803      	ldr	r0, [pc, #12]	; (80a4dec <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x2c>)
 80a4dde:	f002 fd2f 	bl	80a7840 <atexit>
}
 80a4de2:	4803      	ldr	r0, [pc, #12]	; (80a4df0 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x30>)
 80a4de4:	bd10      	pop	{r4, pc}
 80a4de6:	bf00      	nop
 80a4de8:	2000162c 	.word	0x2000162c
 80a4dec:	080a4bd3 	.word	0x080a4bd3
 80a4df0:	20000014 	.word	0x20000014

080a4df4 <_ZN5spark26DefaultOutputStreamFactory8instanceEv>:

spark::DefaultOutputStreamFactory* spark::DefaultOutputStreamFactory::instance() {
 80a4df4:	b510      	push	{r4, lr}
    static DefaultOutputStreamFactory factory;
 80a4df6:	4c09      	ldr	r4, [pc, #36]	; (80a4e1c <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x28>)
 80a4df8:	7823      	ldrb	r3, [r4, #0]
 80a4dfa:	f3bf 8f5b 	dmb	ish
 80a4dfe:	07db      	lsls	r3, r3, #31
 80a4e00:	d409      	bmi.n	80a4e16 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x22>
 80a4e02:	4620      	mov	r0, r4
 80a4e04:	f7fb f958 	bl	80a00b8 <__cxa_guard_acquire>
 80a4e08:	b128      	cbz	r0, 80a4e16 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x22>
 80a4e0a:	4620      	mov	r0, r4
 80a4e0c:	f7fb f959 	bl	80a00c2 <__cxa_guard_release>
 80a4e10:	4803      	ldr	r0, [pc, #12]	; (80a4e20 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x2c>)
 80a4e12:	f002 fd15 	bl	80a7840 <atexit>
    return &factory;
}
 80a4e16:	4803      	ldr	r0, [pc, #12]	; (80a4e24 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x30>)
 80a4e18:	bd10      	pop	{r4, pc}
 80a4e1a:	bf00      	nop
 80a4e1c:	20001630 	.word	0x20001630
 80a4e20:	080a4c37 	.word	0x080a4c37
 80a4e24:	20000018 	.word	0x20000018

080a4e28 <_ZN5spark10LogManagerC1Ev>:
    Print *stream;
};

#endif // Wiring_LogConfig

spark::LogManager::LogManager() {
 80a4e28:	b538      	push	{r3, r4, r5, lr}
        capacity_(0) {
 80a4e2a:	2500      	movs	r5, #0
 80a4e2c:	4604      	mov	r4, r0
 80a4e2e:	e9c0 5500 	strd	r5, r5, [r0]
 80a4e32:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80a4e36:	6085      	str	r5, [r0, #8]
 80a4e38:	6185      	str	r5, [r0, #24]
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
 80a4e3a:	f840 5f24 	str.w	r5, [r0, #36]!
    {
        os_mutex_recursive_create(&handle_);
 80a4e3e:	f7ff f94f 	bl	80a40e0 <os_mutex_recursive_create>
#if Wiring_LogConfig
    handlerFactory_ = DefaultLogHandlerFactory::instance();
 80a4e42:	f7ff ffbd 	bl	80a4dc0 <_ZN5spark24DefaultLogHandlerFactory8instanceEv>
 80a4e46:	61e0      	str	r0, [r4, #28]
    streamFactory_ = DefaultOutputStreamFactory::instance();
 80a4e48:	f7ff ffd4 	bl	80a4df4 <_ZN5spark26DefaultOutputStreamFactory8instanceEv>
#endif
    outputActive_ = false;
 80a4e4c:	7325      	strb	r5, [r4, #12]
    streamFactory_ = DefaultOutputStreamFactory::instance();
 80a4e4e:	6220      	str	r0, [r4, #32]
}
 80a4e50:	4620      	mov	r0, r4
 80a4e52:	bd38      	pop	{r3, r4, r5, pc}

080a4e54 <_ZN5spark10LogManager8instanceEv>:
            resetSystemCallbacks();
        }
    }
}

spark::LogManager* spark::LogManager::instance() {
 80a4e54:	b510      	push	{r4, lr}
    static LogManager mgr;
 80a4e56:	4c0a      	ldr	r4, [pc, #40]	; (80a4e80 <_ZN5spark10LogManager8instanceEv+0x2c>)
 80a4e58:	7823      	ldrb	r3, [r4, #0]
 80a4e5a:	f3bf 8f5b 	dmb	ish
 80a4e5e:	07db      	lsls	r3, r3, #31
 80a4e60:	d40c      	bmi.n	80a4e7c <_ZN5spark10LogManager8instanceEv+0x28>
 80a4e62:	4620      	mov	r0, r4
 80a4e64:	f7fb f928 	bl	80a00b8 <__cxa_guard_acquire>
 80a4e68:	b140      	cbz	r0, 80a4e7c <_ZN5spark10LogManager8instanceEv+0x28>
 80a4e6a:	4806      	ldr	r0, [pc, #24]	; (80a4e84 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a4e6c:	f7ff ffdc 	bl	80a4e28 <_ZN5spark10LogManagerC1Ev>
 80a4e70:	4620      	mov	r0, r4
 80a4e72:	f7fb f926 	bl	80a00c2 <__cxa_guard_release>
 80a4e76:	4804      	ldr	r0, [pc, #16]	; (80a4e88 <_ZN5spark10LogManager8instanceEv+0x34>)
 80a4e78:	f002 fce2 	bl	80a7840 <atexit>
    return &mgr;
}
 80a4e7c:	4801      	ldr	r0, [pc, #4]	; (80a4e84 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a4e7e:	bd10      	pop	{r4, pc}
 80a4e80:	20001628 	.word	0x20001628
 80a4e84:	20001638 	.word	0x20001638
 80a4e88:	080a5351 	.word	0x080a5351

080a4e8c <_ZN5spark10LogManager18setSystemCallbacksEv>:
}

#endif // Wiring_LogConfig

void spark::LogManager::setSystemCallbacks() {
    log_set_callbacks(logMessage, logWrite, logEnabled, nullptr);
 80a4e8c:	2300      	movs	r3, #0
 80a4e8e:	4a02      	ldr	r2, [pc, #8]	; (80a4e98 <_ZN5spark10LogManager18setSystemCallbacksEv+0xc>)
 80a4e90:	4902      	ldr	r1, [pc, #8]	; (80a4e9c <_ZN5spark10LogManager18setSystemCallbacksEv+0x10>)
 80a4e92:	4803      	ldr	r0, [pc, #12]	; (80a4ea0 <_ZN5spark10LogManager18setSystemCallbacksEv+0x14>)
 80a4e94:	f7ff bae6 	b.w	80a4464 <log_set_callbacks>
 80a4e98:	080a51dd 	.word	0x080a51dd
 80a4e9c:	080a5169 	.word	0x080a5169
 80a4ea0:	080a50e9 	.word	0x080a50e9

080a4ea4 <_ZN5spark10LogManager20resetSystemCallbacksEv>:
}

void spark::LogManager::resetSystemCallbacks() {
    log_set_callbacks(nullptr, nullptr, nullptr, nullptr);
 80a4ea4:	2300      	movs	r3, #0
 80a4ea6:	461a      	mov	r2, r3
 80a4ea8:	4619      	mov	r1, r3
 80a4eaa:	4618      	mov	r0, r3
 80a4eac:	f7ff bada 	b.w	80a4464 <log_set_callbacks>

080a4eb0 <_ZNK5spark18JSONObjectIterator5valueEv>:
inline spark::JSONValue spark::JSONObjectIterator::value() const {
 80a4eb0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4eb2:	4604      	mov	r4, r0
    return JSONValue(v_, d_);
 80a4eb4:	690d      	ldr	r5, [r1, #16]
	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
		     element_type* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a4eb6:	f851 3b04 	ldr.w	r3, [r1], #4
 80a4eba:	a801      	add	r0, sp, #4
 80a4ebc:	9300      	str	r3, [sp, #0]
 80a4ebe:	f7ff fbec 	bl	80a469a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a4ec2:	466a      	mov	r2, sp
 80a4ec4:	4629      	mov	r1, r5
 80a4ec6:	4620      	mov	r0, r4
 80a4ec8:	f7ff fd14 	bl	80a48f4 <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a4ecc:	a801      	add	r0, sp, #4
 80a4ece:	f7ff fbce 	bl	80a466e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a4ed2:	4620      	mov	r0, r4
 80a4ed4:	b003      	add	sp, #12
 80a4ed6:	bd30      	pop	{r4, r5, pc}

080a4ed8 <_ZN5spark18JSONObjectIteratorC1ERKNS_9JSONValueE>:
inline spark::JSONObjectIterator::JSONObjectIterator(const JSONValue &value) :
 80a4ed8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4eda:	4604      	mov	r4, r0
        JSONObjectIterator(value.t_, value.d_) {
 80a4edc:	688d      	ldr	r5, [r1, #8]
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a4ede:	f851 3b04 	ldr.w	r3, [r1], #4
 80a4ee2:	a801      	add	r0, sp, #4
 80a4ee4:	9300      	str	r3, [sp, #0]
 80a4ee6:	f7ff fbd8 	bl	80a469a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a4eea:	466a      	mov	r2, sp
 80a4eec:	4629      	mov	r1, r5
 80a4eee:	4620      	mov	r0, r4
 80a4ef0:	f7ff fd7c 	bl	80a49ec <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      ~__shared_ptr() = default;
 80a4ef4:	a801      	add	r0, sp, #4
 80a4ef6:	f7ff fbba 	bl	80a466e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a4efa:	4620      	mov	r0, r4
 80a4efc:	b003      	add	sp, #12
 80a4efe:	bd30      	pop	{r4, r5, pc}

080a4f00 <_ZNK5spark18JSONObjectIterator4nameEv>:
inline spark::JSONString spark::JSONObjectIterator::name() const {
 80a4f00:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4f02:	4604      	mov	r4, r0
    return JSONString(k_, d_);
 80a4f04:	68cd      	ldr	r5, [r1, #12]
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a4f06:	f851 3b04 	ldr.w	r3, [r1], #4
 80a4f0a:	a801      	add	r0, sp, #4
 80a4f0c:	9300      	str	r3, [sp, #0]
 80a4f0e:	f7ff fbc4 	bl	80a469a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a4f12:	466a      	mov	r2, sp
 80a4f14:	4629      	mov	r1, r5
 80a4f16:	4620      	mov	r0, r4
 80a4f18:	f7ff fd44 	bl	80a49a4 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      ~__shared_ptr() = default;
 80a4f1c:	a801      	add	r0, sp, #4
 80a4f1e:	f7ff fba6 	bl	80a466e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a4f22:	4620      	mov	r0, r4
 80a4f24:	b003      	add	sp, #12
 80a4f26:	bd30      	pop	{r4, r5, pc}

080a4f28 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi>:
void spark::DefaultOutputStreamFactory::getParams(const JSONValue &params, int *baudRate) {
 80a4f28:	b570      	push	{r4, r5, r6, lr}
 80a4f2a:	b08a      	sub	sp, #40	; 0x28
 80a4f2c:	460d      	mov	r5, r1
    JSONObjectIterator it(params);
 80a4f2e:	4601      	mov	r1, r0
 80a4f30:	a804      	add	r0, sp, #16
 80a4f32:	f7ff ffd1 	bl	80a4ed8 <_ZN5spark18JSONObjectIteratorC1ERKNS_9JSONValueE>
        if (it.name() == "baud" && baudRate) {
 80a4f36:	4e14      	ldr	r6, [pc, #80]	; (80a4f88 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x60>)
    while (it.next()) {
 80a4f38:	a804      	add	r0, sp, #16
 80a4f3a:	f7ff fd6f 	bl	80a4a1c <_ZN5spark18JSONObjectIterator4nextEv>
 80a4f3e:	b1e8      	cbz	r0, 80a4f7c <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x54>
        if (it.name() == "baud" && baudRate) {
 80a4f40:	4668      	mov	r0, sp
 80a4f42:	a904      	add	r1, sp, #16
 80a4f44:	f7ff ffdc 	bl	80a4f00 <_ZNK5spark18JSONObjectIterator4nameEv>
 80a4f48:	4631      	mov	r1, r6
 80a4f4a:	9802      	ldr	r0, [sp, #8]
 80a4f4c:	f7ff fe6c 	bl	80a4c28 <_ZNK5spark10JSONStringeqEPKc.isra.0>
 80a4f50:	4604      	mov	r4, r0
 80a4f52:	b110      	cbz	r0, 80a4f5a <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x32>
 80a4f54:	1e2c      	subs	r4, r5, #0
 80a4f56:	bf18      	it	ne
 80a4f58:	2401      	movne	r4, #1
 80a4f5a:	a801      	add	r0, sp, #4
 80a4f5c:	f7ff fb87 	bl	80a466e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a4f60:	2c00      	cmp	r4, #0
 80a4f62:	d0e9      	beq.n	80a4f38 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x10>
            *baudRate = it.value().toInt();
 80a4f64:	4668      	mov	r0, sp
 80a4f66:	a904      	add	r1, sp, #16
 80a4f68:	f7ff ffa2 	bl	80a4eb0 <_ZNK5spark18JSONObjectIterator5valueEv>
 80a4f6c:	4668      	mov	r0, sp
 80a4f6e:	f7ff fcf8 	bl	80a4962 <_ZNK5spark9JSONValue5toIntEv>
 80a4f72:	6028      	str	r0, [r5, #0]
 80a4f74:	a801      	add	r0, sp, #4
 80a4f76:	f7ff fb7a 	bl	80a466e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a4f7a:	e7dd      	b.n	80a4f38 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x10>
 80a4f7c:	a805      	add	r0, sp, #20
 80a4f7e:	f7ff fb76 	bl	80a466e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a4f82:	b00a      	add	sp, #40	; 0x28
 80a4f84:	bd70      	pop	{r4, r5, r6, pc}
 80a4f86:	bf00      	nop
 80a4f88:	080a7e74 	.word	0x080a7e74

080a4f8c <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE>:
Print* spark::DefaultOutputStreamFactory::createStream(const char *type, const JSONValue &params) {
 80a4f8c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4f8e:	460c      	mov	r4, r1
    if (strcmp(type, "Serial") == 0) {
 80a4f90:	4919      	ldr	r1, [pc, #100]	; (80a4ff8 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x6c>)
 80a4f92:	4620      	mov	r0, r4
Print* spark::DefaultOutputStreamFactory::createStream(const char *type, const JSONValue &params) {
 80a4f94:	4615      	mov	r5, r2
    if (strcmp(type, "Serial") == 0) {
 80a4f96:	f002 fd06 	bl	80a79a6 <strcmp>
 80a4f9a:	b948      	cbnz	r0, 80a4fb0 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x24>
        Serial.begin();
 80a4f9c:	f001 f9b0 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a4fa0:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a4fa4:	f001 f98e 	bl	80a62c4 <_ZN9USBSerial5beginEl>
        return &Serial;
 80a4fa8:	f001 f9aa 	bl	80a6300 <_Z16_fetch_usbserialv>
}
 80a4fac:	b003      	add	sp, #12
 80a4fae:	bd30      	pop	{r4, r5, pc}
    if (strcmp(type, "USBSerial1") == 0) {
 80a4fb0:	4620      	mov	r0, r4
 80a4fb2:	4912      	ldr	r1, [pc, #72]	; (80a4ffc <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x70>)
 80a4fb4:	f002 fcf7 	bl	80a79a6 <strcmp>
 80a4fb8:	b940      	cbnz	r0, 80a4fcc <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x40>
        USBSerial1.begin();
 80a4fba:	f001 f9db 	bl	80a6374 <_Z17_fetch_usbserial1v>
 80a4fbe:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a4fc2:	f001 f97f 	bl	80a62c4 <_ZN9USBSerial5beginEl>
        return &USBSerial1;
 80a4fc6:	f001 f9d5 	bl	80a6374 <_Z17_fetch_usbserial1v>
 80a4fca:	e7ef      	b.n	80a4fac <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x20>
    if (strcmp(type, "Serial1") == 0) {
 80a4fcc:	4620      	mov	r0, r4
 80a4fce:	490c      	ldr	r1, [pc, #48]	; (80a5000 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x74>)
 80a4fd0:	f002 fce9 	bl	80a79a6 <strcmp>
 80a4fd4:	b970      	cbnz	r0, 80a4ff4 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x68>
        int baud = 9600;
 80a4fd6:	f44f 5316 	mov.w	r3, #9600	; 0x2580
        getParams(params, &baud);
 80a4fda:	a901      	add	r1, sp, #4
 80a4fdc:	4628      	mov	r0, r5
        int baud = 9600;
 80a4fde:	9301      	str	r3, [sp, #4]
        getParams(params, &baud);
 80a4fe0:	f7ff ffa2 	bl	80a4f28 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi>
        Serial1.begin(baud);
 80a4fe4:	f001 f8f8 	bl	80a61d8 <_Z22__fetch_global_Serial1v>
 80a4fe8:	9901      	ldr	r1, [sp, #4]
 80a4fea:	f001 f8ef 	bl	80a61cc <_ZN11USARTSerial5beginEm>
        return &Serial1;
 80a4fee:	f001 f8f3 	bl	80a61d8 <_Z22__fetch_global_Serial1v>
 80a4ff2:	e7db      	b.n	80a4fac <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x20>
    return nullptr;
 80a4ff4:	2000      	movs	r0, #0
 80a4ff6:	e7d9      	b.n	80a4fac <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x20>
 80a4ff8:	080a7e79 	.word	0x080a7e79
 80a4ffc:	080a7e80 	.word	0x080a7e80
 80a5000:	080a7e83 	.word	0x080a7e83

080a5004 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a5004:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
 80a5006:	2614      	movs	r6, #20
 80a5008:	e9d0 5300 	ldrd	r5, r3, [r0]
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a500c:	4604      	mov	r4, r0
    destruct(data_, data_ + size_);
 80a500e:	fb06 5603 	mla	r6, r6, r3, r5
        for (; p != end; ++p) {
 80a5012:	42ae      	cmp	r6, r5
 80a5014:	d005      	beq.n	80a5022 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev+0x1e>
struct spark::detail::LogFilter::Node {
 80a5016:	f105 0008 	add.w	r0, r5, #8
 80a501a:	f7ff fff3 	bl	80a5004 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a501e:	3514      	adds	r5, #20
 80a5020:	e7f7      	b.n	80a5012 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev+0xe>
    ::free(ptr);
 80a5022:	6820      	ldr	r0, [r4, #0]
 80a5024:	f7ff fac2 	bl	80a45ac <free>
}
 80a5028:	4620      	mov	r0, r4
 80a502a:	bd70      	pop	{r4, r5, r6, pc}

080a502c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a502c:	b570      	push	{r4, r5, r6, lr}
 80a502e:	4604      	mov	r4, r0
    destruct(data_, data_ + size_);
 80a5030:	e9d0 5300 	ldrd	r5, r3, [r0]
 80a5034:	eb05 1603 	add.w	r6, r5, r3, lsl #4
        for (; p != end; ++p) {
 80a5038:	42ae      	cmp	r6, r5
 80a503a:	d004      	beq.n	80a5046 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0x1a>
            p->~T();
 80a503c:	4628      	mov	r0, r5
 80a503e:	f000 ffb4 	bl	80a5faa <_ZN6StringD1Ev>
        for (; p != end; ++p) {
 80a5042:	3510      	adds	r5, #16
 80a5044:	e7f8      	b.n	80a5038 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0xc>
    ::free(ptr);
 80a5046:	6820      	ldr	r0, [r4, #0]
 80a5048:	f7ff fab0 	bl	80a45ac <free>
}
 80a504c:	4620      	mov	r0, r4
 80a504e:	bd70      	pop	{r4, r5, r6, pc}

080a5050 <_ZN5spark6detail9LogFilterD1Ev>:
spark::detail::LogFilter::~LogFilter() {
 80a5050:	b510      	push	{r4, lr}
 80a5052:	4604      	mov	r4, r0
 80a5054:	300c      	adds	r0, #12
 80a5056:	f7ff ffd5 	bl	80a5004 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a505a:	4620      	mov	r0, r4
 80a505c:	f7ff ffe6 	bl	80a502c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
}
 80a5060:	4620      	mov	r0, r4
 80a5062:	bd10      	pop	{r4, pc}

080a5064 <_ZN5spark16StreamLogHandlerD1Ev>:
class StreamLogHandler: public LogHandler {
 80a5064:	b510      	push	{r4, lr}
 80a5066:	4604      	mov	r4, r0
    virtual ~LogHandler() = default;
 80a5068:	4b03      	ldr	r3, [pc, #12]	; (80a5078 <_ZN5spark16StreamLogHandlerD1Ev+0x14>)
 80a506a:	f840 3b04 	str.w	r3, [r0], #4
 80a506e:	f7ff ffef 	bl	80a5050 <_ZN5spark6detail9LogFilterD1Ev>
class StreamLogHandler: public LogHandler {
 80a5072:	4620      	mov	r0, r4
 80a5074:	bd10      	pop	{r4, pc}
 80a5076:	bf00      	nop
 80a5078:	080a7dc8 	.word	0x080a7dc8

080a507c <_ZN5spark16StreamLogHandlerD0Ev>:
 80a507c:	b510      	push	{r4, lr}
 80a507e:	4604      	mov	r4, r0
 80a5080:	f7ff fff0 	bl	80a5064 <_ZN5spark16StreamLogHandlerD1Ev>
 80a5084:	4620      	mov	r0, r4
 80a5086:	2124      	movs	r1, #36	; 0x24
 80a5088:	f001 fbe2 	bl	80a6850 <_ZdlPvj>
 80a508c:	4620      	mov	r0, r4
 80a508e:	bd10      	pop	{r4, pc}

080a5090 <_ZN5spark20JSONStreamLogHandlerD1Ev>:
class JSONStreamLogHandler: public StreamLogHandler {
 80a5090:	b510      	push	{r4, lr}
 80a5092:	4604      	mov	r4, r0
 80a5094:	4b02      	ldr	r3, [pc, #8]	; (80a50a0 <_ZN5spark20JSONStreamLogHandlerD1Ev+0x10>)
 80a5096:	6003      	str	r3, [r0, #0]
 80a5098:	f7ff ffe4 	bl	80a5064 <_ZN5spark16StreamLogHandlerD1Ev>
 80a509c:	4620      	mov	r0, r4
 80a509e:	bd10      	pop	{r4, pc}
 80a50a0:	080a7f20 	.word	0x080a7f20

080a50a4 <_ZN5spark20JSONStreamLogHandlerD0Ev>:
 80a50a4:	b510      	push	{r4, lr}
 80a50a6:	4604      	mov	r4, r0
 80a50a8:	f7ff fff2 	bl	80a5090 <_ZN5spark20JSONStreamLogHandlerD1Ev>
 80a50ac:	4620      	mov	r0, r4
 80a50ae:	2124      	movs	r1, #36	; 0x24
 80a50b0:	f001 fbce 	bl	80a6850 <_ZdlPvj>
 80a50b4:	4620      	mov	r0, r4
 80a50b6:	bd10      	pop	{r4, pc}

080a50b8 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>:
        capacity_(0) {
 80a50b8:	2200      	movs	r2, #0
 80a50ba:	e9c0 2200 	strd	r2, r2, [r0]
 80a50be:	6082      	str	r2, [r0, #8]
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
 80a50c0:	b510      	push	{r4, lr}
      __a = _GLIBCXX_MOVE(__b);
 80a50c2:	680c      	ldr	r4, [r1, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a50c4:	600a      	str	r2, [r1, #0]
      __a = _GLIBCXX_MOVE(__b);
 80a50c6:	6004      	str	r4, [r0, #0]
 80a50c8:	684c      	ldr	r4, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a50ca:	604a      	str	r2, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a50cc:	6044      	str	r4, [r0, #4]
 80a50ce:	688c      	ldr	r4, [r1, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a50d0:	608a      	str	r2, [r1, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a50d2:	6084      	str	r4, [r0, #8]
}
 80a50d4:	bd10      	pop	{r4, pc}

080a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>:
      { _M_device.lock(); }

      lock_guard(mutex_type& __m, adopt_lock_t) noexcept : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
 80a50d6:	b510      	push	{r4, lr}
 80a50d8:	4604      	mov	r4, r0
      { _M_device.unlock(); }
 80a50da:	6803      	ldr	r3, [r0, #0]
    }

    void lock() { os_mutex_recursive_lock(handle_); }
    bool trylock() { return os_mutex_recursive_trylock(handle_)==0; }
    bool try_lock() { return trylock(); }
    void unlock() { os_mutex_recursive_unlock(handle_); }
 80a50dc:	6818      	ldr	r0, [r3, #0]
 80a50de:	f7ff f817 	bl	80a4110 <os_mutex_recursive_unlock>
 80a50e2:	4620      	mov	r0, r4
 80a50e4:	bd10      	pop	{r4, pc}
	...

080a50e8 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv>:
}

void spark::LogManager::logMessage(const char *msg, int level, const char *category, const LogAttributes *attr, void *reserved) {
 80a50e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a50ec:	b087      	sub	sp, #28
 80a50ee:	9303      	str	r3, [sp, #12]
#endif /* nRF52840 */

#if defined(STM32F10X_MD) || defined(STM32F10X_HD) || defined(STM32F2XX) || defined(nRF52840)
static inline bool HAL_IsISR() 
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) != 0;
 80a50f0:	4b1c      	ldr	r3, [pc, #112]	; (80a5164 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x7c>)
 80a50f2:	4680      	mov	r8, r0
 80a50f4:	685b      	ldr	r3, [r3, #4]
 80a50f6:	4689      	mov	r9, r1
 80a50f8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80a50fc:	4616      	mov	r6, r2
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a50fe:	b96b      	cbnz	r3, 80a511c <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x34>
        return;
    }
#endif
    LogManager *that = instance();
 80a5100:	f7ff fea8 	bl	80a4e54 <_ZN5spark10LogManager8instanceEv>
 80a5104:	4604      	mov	r4, r0
    LOG_WITH_LOCK(that->mutex_) {
 80a5106:	f100 0324 	add.w	r3, r0, #36	; 0x24
    void lock() { os_mutex_recursive_lock(handle_); }
 80a510a:	6a40      	ldr	r0, [r0, #36]	; 0x24
      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a510c:	9305      	str	r3, [sp, #20]
 80a510e:	f7fe fff7 	bl	80a4100 <os_mutex_recursive_lock>
        // prevent re-entry
        if (that->isActive()) {
 80a5112:	7b23      	ldrb	r3, [r4, #12]
 80a5114:	b12b      	cbz	r3, 80a5122 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x3a>
    LOG_WITH_LOCK(that->mutex_) {
 80a5116:	a805      	add	r0, sp, #20
 80a5118:	f7ff ffdd 	bl	80a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        for (LogHandler *handler: that->activeHandlers_) {
            handler->message(msg, (LogLevel)level, category, *attr);
        }
        that->setActive(false);
    }
}
 80a511c:	b007      	add	sp, #28
 80a511e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a5122:	2301      	movs	r3, #1
            handler->message(msg, (LogLevel)level, category, *attr);
 80a5124:	fa5f f989 	uxtb.w	r9, r9
    outputActive_ = outputActive;
 80a5128:	7323      	strb	r3, [r4, #12]
    return data_ + size_;
 80a512a:	e9d4 5300 	ldrd	r5, r3, [r4]
 80a512e:	eb05 0a83 	add.w	sl, r5, r3, lsl #2
        for (LogHandler *handler: that->activeHandlers_) {
 80a5132:	45aa      	cmp	sl, r5
 80a5134:	d012      	beq.n	80a515c <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x74>
 80a5136:	f855 7b04 	ldr.w	r7, [r5], #4
    if (level >= filter_.level(category)) {
 80a513a:	4631      	mov	r1, r6
 80a513c:	1d38      	adds	r0, r7, #4
 80a513e:	f7ff fe15 	bl	80a4d6c <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a5142:	4581      	cmp	r9, r0
 80a5144:	d3f5      	bcc.n	80a5132 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x4a>
        logMessage(msg, level, category, attr);
 80a5146:	9a03      	ldr	r2, [sp, #12]
 80a5148:	683b      	ldr	r3, [r7, #0]
 80a514a:	9200      	str	r2, [sp, #0]
 80a514c:	f8d3 b008 	ldr.w	fp, [r3, #8]
 80a5150:	464a      	mov	r2, r9
 80a5152:	4633      	mov	r3, r6
 80a5154:	4641      	mov	r1, r8
 80a5156:	4638      	mov	r0, r7
 80a5158:	47d8      	blx	fp
 80a515a:	e7ea      	b.n	80a5132 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x4a>
    outputActive_ = outputActive;
 80a515c:	2300      	movs	r3, #0
 80a515e:	7323      	strb	r3, [r4, #12]
 80a5160:	e7d9      	b.n	80a5116 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x2e>
 80a5162:	bf00      	nop
 80a5164:	e000ed00 	.word	0xe000ed00

080a5168 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv>:
void spark::LogManager::logWrite(const char *data, size_t size, int level, const char *category, void *reserved) {
 80a5168:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a516c:	469b      	mov	fp, r3
 80a516e:	4b1a      	ldr	r3, [pc, #104]	; (80a51d8 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x70>)
 80a5170:	4680      	mov	r8, r0
 80a5172:	685b      	ldr	r3, [r3, #4]
 80a5174:	4689      	mov	r9, r1
 80a5176:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80a517a:	4616      	mov	r6, r2
    if (HAL_IsISR()) {
 80a517c:	b96b      	cbnz	r3, 80a519a <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x32>
    LogManager *that = instance();
 80a517e:	f7ff fe69 	bl	80a4e54 <_ZN5spark10LogManager8instanceEv>
 80a5182:	4604      	mov	r4, r0
    LOG_WITH_LOCK(that->mutex_) {
 80a5184:	f100 0324 	add.w	r3, r0, #36	; 0x24
 80a5188:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80a518a:	9301      	str	r3, [sp, #4]
 80a518c:	f7fe ffb8 	bl	80a4100 <os_mutex_recursive_lock>
        if (that->isActive()) {
 80a5190:	7b23      	ldrb	r3, [r4, #12]
 80a5192:	b12b      	cbz	r3, 80a51a0 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x38>
    LOG_WITH_LOCK(that->mutex_) {
 80a5194:	a801      	add	r0, sp, #4
 80a5196:	f7ff ff9e 	bl	80a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
}
 80a519a:	b003      	add	sp, #12
 80a519c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    outputActive_ = outputActive;
 80a51a0:	2301      	movs	r3, #1
    if (level >= filter_.level(category)) {
 80a51a2:	b2f6      	uxtb	r6, r6
 80a51a4:	7323      	strb	r3, [r4, #12]
 80a51a6:	e9d4 5300 	ldrd	r5, r3, [r4]
 80a51aa:	eb05 0a83 	add.w	sl, r5, r3, lsl #2
        for (LogHandler *handler: that->activeHandlers_) {
 80a51ae:	4555      	cmp	r5, sl
 80a51b0:	d00e      	beq.n	80a51d0 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x68>
 80a51b2:	f855 7b04 	ldr.w	r7, [r5], #4
 80a51b6:	4659      	mov	r1, fp
 80a51b8:	1d38      	adds	r0, r7, #4
 80a51ba:	f7ff fdd7 	bl	80a4d6c <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a51be:	4286      	cmp	r6, r0
 80a51c0:	d3f5      	bcc.n	80a51ae <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x46>
        write(data, size);
 80a51c2:	683b      	ldr	r3, [r7, #0]
 80a51c4:	464a      	mov	r2, r9
 80a51c6:	4641      	mov	r1, r8
 80a51c8:	4638      	mov	r0, r7
 80a51ca:	68db      	ldr	r3, [r3, #12]
 80a51cc:	4798      	blx	r3
 80a51ce:	e7ee      	b.n	80a51ae <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x46>
    outputActive_ = outputActive;
 80a51d0:	2300      	movs	r3, #0
 80a51d2:	7323      	strb	r3, [r4, #12]
 80a51d4:	e7de      	b.n	80a5194 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x2c>
 80a51d6:	bf00      	nop
 80a51d8:	e000ed00 	.word	0xe000ed00

080a51dc <_ZN5spark10LogManager10logEnabledEiPKcPv>:
int spark::LogManager::logEnabled(int level, const char *category, void *reserved) {
 80a51dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a51e0:	4b16      	ldr	r3, [pc, #88]	; (80a523c <_ZN5spark10LogManager10logEnabledEiPKcPv+0x60>)
 80a51e2:	4605      	mov	r5, r0
 80a51e4:	685b      	ldr	r3, [r3, #4]
 80a51e6:	460f      	mov	r7, r1
 80a51e8:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (HAL_IsISR()) {
 80a51ec:	bb1b      	cbnz	r3, 80a5236 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x5a>
    LogManager *that = instance();
 80a51ee:	f7ff fe31 	bl	80a4e54 <_ZN5spark10LogManager8instanceEv>
 80a51f2:	4604      	mov	r4, r0
    LOG_WITH_LOCK(that->mutex_) {
 80a51f4:	f100 0324 	add.w	r3, r0, #36	; 0x24
 80a51f8:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80a51fa:	9301      	str	r3, [sp, #4]
 80a51fc:	f7fe ff80 	bl	80a4100 <os_mutex_recursive_lock>
 80a5200:	e9d4 6300 	ldrd	r6, r3, [r4]
    int minLevel = LOG_LEVEL_NONE;
 80a5204:	2446      	movs	r4, #70	; 0x46
 80a5206:	eb06 0883 	add.w	r8, r6, r3, lsl #2
        for (LogHandler *handler: that->activeHandlers_) {
 80a520a:	45b0      	cmp	r8, r6
 80a520c:	d109      	bne.n	80a5222 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x46>
    LOG_WITH_LOCK(that->mutex_) {
 80a520e:	a801      	add	r0, sp, #4
 80a5210:	f7ff ff61 	bl	80a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
    return (level >= minLevel);
 80a5214:	42a5      	cmp	r5, r4
 80a5216:	bfb4      	ite	lt
 80a5218:	2000      	movlt	r0, #0
 80a521a:	2001      	movge	r0, #1
}
 80a521c:	b002      	add	sp, #8
 80a521e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return filter_.level(category);
 80a5222:	f856 0b04 	ldr.w	r0, [r6], #4
 80a5226:	4639      	mov	r1, r7
 80a5228:	3004      	adds	r0, #4
 80a522a:	f7ff fd9f 	bl	80a4d6c <_ZNK5spark6detail9LogFilter5levelEPKc>
            if (level < minLevel) {
 80a522e:	4284      	cmp	r4, r0
 80a5230:	bfa8      	it	ge
 80a5232:	4604      	movge	r4, r0
        for (LogHandler *handler: that->activeHandlers_) {
 80a5234:	e7e9      	b.n	80a520a <_ZN5spark10LogManager10logEnabledEiPKcPv+0x2e>
        return 0;
 80a5236:	2000      	movs	r0, #0
 80a5238:	e7f0      	b.n	80a521c <_ZN5spark10LogManager10logEnabledEiPKcPv+0x40>
 80a523a:	bf00      	nop
 80a523c:	e000ed00 	.word	0xe000ed00

080a5240 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>:
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
 80a5240:	460b      	mov	r3, r1
 80a5242:	b570      	push	{r4, r5, r6, lr}
 80a5244:	4604      	mov	r4, r0
    T* const p = find(data_, data_ + size_, value);
 80a5246:	c805      	ldmia	r0, {r0, r2}
 80a5248:	eb00 0282 	add.w	r2, r0, r2, lsl #2
        for (; p != end; ++p) {
 80a524c:	4282      	cmp	r2, r0
 80a524e:	d007      	beq.n	80a5260 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0x20>
 80a5250:	4601      	mov	r1, r0
            if (*p == value) {
 80a5252:	681d      	ldr	r5, [r3, #0]
 80a5254:	f851 6b04 	ldr.w	r6, [r1], #4
 80a5258:	42ae      	cmp	r6, r5
 80a525a:	d003      	beq.n	80a5264 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0x24>
 80a525c:	4608      	mov	r0, r1
 80a525e:	e7f5      	b.n	80a524c <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0xc>
        return false;
 80a5260:	2000      	movs	r0, #0
}
 80a5262:	bd70      	pop	{r4, r5, r6, pc}
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a5264:	1a52      	subs	r2, r2, r1
 80a5266:	f002 fb0d 	bl	80a7884 <memmove>
    --size_;
 80a526a:	6863      	ldr	r3, [r4, #4]
    return true;
 80a526c:	2001      	movs	r0, #1
    --size_;
 80a526e:	3b01      	subs	r3, #1
 80a5270:	6063      	str	r3, [r4, #4]
    return true;
 80a5272:	e7f6      	b.n	80a5262 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0x22>

080a5274 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE>:
void spark::LogManager::removeHandler(LogHandler *handler) {
 80a5274:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80a5276:	4604      	mov	r4, r0
    LOG_WITH_LOCK(mutex_) {
 80a5278:	f100 0324 	add.w	r3, r0, #36	; 0x24
 80a527c:	6a40      	ldr	r0, [r0, #36]	; 0x24
void spark::LogManager::removeHandler(LogHandler *handler) {
 80a527e:	9101      	str	r1, [sp, #4]
 80a5280:	9303      	str	r3, [sp, #12]
 80a5282:	f7fe ff3d 	bl	80a4100 <os_mutex_recursive_lock>
        if (activeHandlers_.removeOne(handler) && activeHandlers_.isEmpty()) {
 80a5286:	4620      	mov	r0, r4
 80a5288:	a901      	add	r1, sp, #4
 80a528a:	f7ff ffd9 	bl	80a5240 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>
 80a528e:	b118      	cbz	r0, 80a5298 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x24>
 80a5290:	6863      	ldr	r3, [r4, #4]
 80a5292:	b90b      	cbnz	r3, 80a5298 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x24>
            resetSystemCallbacks();
 80a5294:	f7ff fe06 	bl	80a4ea4 <_ZN5spark10LogManager20resetSystemCallbacksEv>
    LOG_WITH_LOCK(mutex_) {
 80a5298:	a803      	add	r0, sp, #12
 80a529a:	f7ff ff1c 	bl	80a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
}
 80a529e:	b004      	add	sp, #16
 80a52a0:	bd10      	pop	{r4, pc}

080a52a2 <_ZN5spark10LogManager22destroyFactoryHandlersEv>:
    return data_ + size_;
 80a52a2:	2318      	movs	r3, #24
void spark::LogManager::destroyFactoryHandlers() {
 80a52a4:	b570      	push	{r4, r5, r6, lr}
 80a52a6:	4604      	mov	r4, r0
 80a52a8:	e9d0 5604 	ldrd	r5, r6, [r0, #16]
 80a52ac:	fb03 5606 	mla	r6, r3, r6, r5
    for (const FactoryHandler &h: factoryHandlers_) {
 80a52b0:	42ae      	cmp	r6, r5
 80a52b2:	d015      	beq.n	80a52e0 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x3e>
        activeHandlers_.removeOne(h.handler);
 80a52b4:	4620      	mov	r0, r4
 80a52b6:	f105 0110 	add.w	r1, r5, #16
 80a52ba:	f7ff ffc1 	bl	80a5240 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>
        if (activeHandlers_.isEmpty()) {
 80a52be:	6863      	ldr	r3, [r4, #4]
 80a52c0:	b90b      	cbnz	r3, 80a52c6 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x24>
            resetSystemCallbacks();
 80a52c2:	f7ff fdef 	bl	80a4ea4 <_ZN5spark10LogManager20resetSystemCallbacksEv>
        handlerFactory_->destroyHandler(h.handler);
 80a52c6:	69e0      	ldr	r0, [r4, #28]
 80a52c8:	6929      	ldr	r1, [r5, #16]
 80a52ca:	6803      	ldr	r3, [r0, #0]
 80a52cc:	68db      	ldr	r3, [r3, #12]
 80a52ce:	4798      	blx	r3
        if (h.stream) {
 80a52d0:	6969      	ldr	r1, [r5, #20]
 80a52d2:	b119      	cbz	r1, 80a52dc <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x3a>
            streamFactory_->destroyStream(h.stream);
 80a52d4:	6a20      	ldr	r0, [r4, #32]
 80a52d6:	6803      	ldr	r3, [r0, #0]
 80a52d8:	68db      	ldr	r3, [r3, #12]
 80a52da:	4798      	blx	r3
    for (const FactoryHandler &h: factoryHandlers_) {
 80a52dc:	3518      	adds	r5, #24
 80a52de:	e7e7      	b.n	80a52b0 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0xe>
    destruct(data_, data_ + size_);
 80a52e0:	2618      	movs	r6, #24
 80a52e2:	e9d4 5304 	ldrd	r5, r3, [r4, #16]
 80a52e6:	fb06 5603 	mla	r6, r6, r3, r5
        for (; p != end; ++p) {
 80a52ea:	42ae      	cmp	r6, r5
 80a52ec:	d004      	beq.n	80a52f8 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x56>
struct spark::LogManager::FactoryHandler {
 80a52ee:	4628      	mov	r0, r5
 80a52f0:	f000 fe5b 	bl	80a5faa <_ZN6StringD1Ev>
 80a52f4:	3518      	adds	r5, #24
 80a52f6:	e7f8      	b.n	80a52ea <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x48>
    size_ = 0;
 80a52f8:	2300      	movs	r3, #0
 80a52fa:	6163      	str	r3, [r4, #20]
}
 80a52fc:	bd70      	pop	{r4, r5, r6, pc}

080a52fe <_ZN5spark10LogManagerD1Ev>:
spark::LogManager::~LogManager() {
 80a52fe:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a5300:	4604      	mov	r4, r0
    resetSystemCallbacks();
 80a5302:	f7ff fdcf 	bl	80a4ea4 <_ZN5spark10LogManager20resetSystemCallbacksEv>
    LOG_WITH_LOCK(mutex_) {
 80a5306:	f104 0324 	add.w	r3, r4, #36	; 0x24
 80a530a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a530c:	9301      	str	r3, [sp, #4]
 80a530e:	f7fe fef7 	bl	80a4100 <os_mutex_recursive_lock>
         destroyFactoryHandlers();
 80a5312:	4620      	mov	r0, r4
 80a5314:	f7ff ffc5 	bl	80a52a2 <_ZN5spark10LogManager22destroyFactoryHandlersEv>
    LOG_WITH_LOCK(mutex_) {
 80a5318:	a801      	add	r0, sp, #4
 80a531a:	f7ff fedc 	bl	80a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        if (handle_) {
 80a531e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a5320:	b108      	cbz	r0, 80a5326 <_ZN5spark10LogManagerD1Ev+0x28>
            os_mutex_recursive_destroy(handle_);
 80a5322:	f7fe fee5 	bl	80a40f0 <os_mutex_recursive_destroy>
    destruct(data_, data_ + size_);
 80a5326:	e9d4 5304 	ldrd	r5, r3, [r4, #16]
 80a532a:	2618      	movs	r6, #24
 80a532c:	fb06 5603 	mla	r6, r6, r3, r5
        for (; p != end; ++p) {
 80a5330:	42ae      	cmp	r6, r5
 80a5332:	d004      	beq.n	80a533e <_ZN5spark10LogManagerD1Ev+0x40>
struct spark::LogManager::FactoryHandler {
 80a5334:	4628      	mov	r0, r5
 80a5336:	f000 fe38 	bl	80a5faa <_ZN6StringD1Ev>
 80a533a:	3518      	adds	r5, #24
 80a533c:	e7f8      	b.n	80a5330 <_ZN5spark10LogManagerD1Ev+0x32>
    ::free(ptr);
 80a533e:	6920      	ldr	r0, [r4, #16]
 80a5340:	f7ff f934 	bl	80a45ac <free>
 80a5344:	6820      	ldr	r0, [r4, #0]
 80a5346:	f7ff f931 	bl	80a45ac <free>
}
 80a534a:	4620      	mov	r0, r4
 80a534c:	b002      	add	sp, #8
 80a534e:	bd70      	pop	{r4, r5, r6, pc}

080a5350 <__tcf_2>:
    static LogManager mgr;
 80a5350:	4801      	ldr	r0, [pc, #4]	; (80a5358 <__tcf_2+0x8>)
 80a5352:	f7ff bfd4 	b.w	80a52fe <_ZN5spark10LogManagerD1Ev>
 80a5356:	bf00      	nop
 80a5358:	20001638 	.word	0x20001638

080a535c <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>:
        if (dest > p && dest < end) {
 80a535c:	4288      	cmp	r0, r1
    static void move(T* dest, T* p, T* end) {
 80a535e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a5360:	4606      	mov	r6, r0
 80a5362:	460c      	mov	r4, r1
 80a5364:	4615      	mov	r5, r2
        if (dest > p && dest < end) {
 80a5366:	d927      	bls.n	80a53b8 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x5c>
 80a5368:	4290      	cmp	r0, r2
 80a536a:	d226      	bcs.n	80a53ba <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x5e>
        capacity_(0) {
 80a536c:	2600      	movs	r6, #0
            --end;
 80a536e:	f1a2 0514 	sub.w	r5, r2, #20
            dest += end - p - 1;
 80a5372:	1a6c      	subs	r4, r5, r1
 80a5374:	f1a1 0714 	sub.w	r7, r1, #20
 80a5378:	4404      	add	r4, r0
            for (; end != p; --end, --dest) {
 80a537a:	42af      	cmp	r7, r5
 80a537c:	d03d      	beq.n	80a53fa <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x9e>
                new(dest) T(std::move(*end));
 80a537e:	b1a4      	cbz	r4, 80a53aa <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x4e>
struct spark::detail::LogFilter::Node {
 80a5380:	682b      	ldr	r3, [r5, #0]
 80a5382:	6023      	str	r3, [r4, #0]
 80a5384:	88ab      	ldrh	r3, [r5, #4]
 80a5386:	80a3      	strh	r3, [r4, #4]
 80a5388:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
        capacity_(0) {
 80a538c:	e9c4 6602 	strd	r6, r6, [r4, #8]
 80a5390:	6126      	str	r6, [r4, #16]
 80a5392:	80e3      	strh	r3, [r4, #6]
 80a5394:	68ab      	ldr	r3, [r5, #8]
 80a5396:	60a3      	str	r3, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a5398:	60ae      	str	r6, [r5, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a539a:	68e3      	ldr	r3, [r4, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a539c:	68ea      	ldr	r2, [r5, #12]
 80a539e:	60e2      	str	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a53a0:	60eb      	str	r3, [r5, #12]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a53a2:	6923      	ldr	r3, [r4, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a53a4:	692a      	ldr	r2, [r5, #16]
 80a53a6:	6122      	str	r2, [r4, #16]
      __b = _GLIBCXX_MOVE(__tmp);
 80a53a8:	612b      	str	r3, [r5, #16]
 80a53aa:	f105 0008 	add.w	r0, r5, #8
 80a53ae:	f7ff fe29 	bl	80a5004 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
            for (; end != p; --end, --dest) {
 80a53b2:	3d14      	subs	r5, #20
 80a53b4:	3c14      	subs	r4, #20
 80a53b6:	e7e0      	b.n	80a537a <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x1e>
        } else if (dest != p) {
 80a53b8:	d01f      	beq.n	80a53fa <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x9e>
        capacity_(0) {
 80a53ba:	2700      	movs	r7, #0
            for (; p != end; ++p, ++dest) {
 80a53bc:	42ac      	cmp	r4, r5
 80a53be:	d01c      	beq.n	80a53fa <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x9e>
                new(dest) T(std::move(*p));
 80a53c0:	b1a6      	cbz	r6, 80a53ec <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x90>
 80a53c2:	6823      	ldr	r3, [r4, #0]
 80a53c4:	6033      	str	r3, [r6, #0]
 80a53c6:	88a3      	ldrh	r3, [r4, #4]
 80a53c8:	80b3      	strh	r3, [r6, #4]
 80a53ca:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
        capacity_(0) {
 80a53ce:	e9c6 7702 	strd	r7, r7, [r6, #8]
 80a53d2:	6137      	str	r7, [r6, #16]
 80a53d4:	80f3      	strh	r3, [r6, #6]
      __a = _GLIBCXX_MOVE(__b);
 80a53d6:	68a3      	ldr	r3, [r4, #8]
 80a53d8:	60b3      	str	r3, [r6, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a53da:	60a7      	str	r7, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a53dc:	68f3      	ldr	r3, [r6, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a53de:	68e2      	ldr	r2, [r4, #12]
 80a53e0:	60f2      	str	r2, [r6, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a53e2:	60e3      	str	r3, [r4, #12]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a53e4:	6933      	ldr	r3, [r6, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a53e6:	6922      	ldr	r2, [r4, #16]
 80a53e8:	6132      	str	r2, [r6, #16]
      __b = _GLIBCXX_MOVE(__tmp);
 80a53ea:	6123      	str	r3, [r4, #16]
 80a53ec:	f104 0008 	add.w	r0, r4, #8
 80a53f0:	f7ff fe08 	bl	80a5004 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
            for (; p != end; ++p, ++dest) {
 80a53f4:	3414      	adds	r4, #20
 80a53f6:	3614      	adds	r6, #20
 80a53f8:	e7e0      	b.n	80a53bc <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x60>
    }
 80a53fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a53fc <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_>:
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a53fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a53fe:	e9d0 5301 	ldrd	r5, r3, [r0, #4]
 80a5402:	429d      	cmp	r5, r3
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a5404:	4604      	mov	r4, r0
 80a5406:	460e      	mov	r6, r1
 80a5408:	4617      	mov	r7, r2
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a540a:	db0d      	blt.n	80a5428 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x2c>
 80a540c:	3501      	adds	r5, #1
        if (n > 0) {
 80a540e:	2d00      	cmp	r5, #0
 80a5410:	6800      	ldr	r0, [r0, #0]
 80a5412:	dd04      	ble.n	80a541e <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x22>
    return ::realloc(ptr, size);
 80a5414:	00a9      	lsls	r1, r5, #2
 80a5416:	f7ff f8d1 	bl	80a45bc <realloc>
            if (!d) {
 80a541a:	b918      	cbnz	r0, 80a5424 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x28>
}
 80a541c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ::free(ptr);
 80a541e:	f7ff f8c5 	bl	80a45ac <free>
        T* d = nullptr;
 80a5422:	2000      	movs	r0, #0
        data_ = d;
 80a5424:	6020      	str	r0, [r4, #0]
        capacity_ = n;
 80a5426:	60a5      	str	r5, [r4, #8]
    T* const p = data_ + i;
 80a5428:	6825      	ldr	r5, [r4, #0]
    move(p + 1, p, data_ + size_);
 80a542a:	6862      	ldr	r2, [r4, #4]
    T* const p = data_ + i;
 80a542c:	eb05 0186 	add.w	r1, r5, r6, lsl #2
    move(p + 1, p, data_ + size_);
 80a5430:	0092      	lsls	r2, r2, #2
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a5432:	eba2 0286 	sub.w	r2, r2, r6, lsl #2
 80a5436:	1d08      	adds	r0, r1, #4
 80a5438:	f002 fa24 	bl	80a7884 <memmove>
    new(p) T(std::move(value));
 80a543c:	f845 7026 	str.w	r7, [r5, r6, lsl #2]
    ++size_;
 80a5440:	6863      	ldr	r3, [r4, #4]
    return true;
 80a5442:	2001      	movs	r0, #1
    ++size_;
 80a5444:	3301      	adds	r3, #1
 80a5446:	6063      	str	r3, [r4, #4]
    return true;
 80a5448:	e7e8      	b.n	80a541c <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x20>

080a544a <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE>:
bool spark::LogManager::addHandler(LogHandler *handler) {
 80a544a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a544c:	4604      	mov	r4, r0
    LOG_WITH_LOCK(mutex_) {
 80a544e:	f100 0324 	add.w	r3, r0, #36	; 0x24
    void lock() { os_mutex_recursive_lock(handle_); }
 80a5452:	6a40      	ldr	r0, [r0, #36]	; 0x24
bool spark::LogManager::addHandler(LogHandler *handler) {
 80a5454:	460d      	mov	r5, r1
 80a5456:	9301      	str	r3, [sp, #4]
 80a5458:	f7fe fe52 	bl	80a4100 <os_mutex_recursive_lock>
    return find(data_, data_ + size_, value);
 80a545c:	e9d4 3100 	ldrd	r3, r1, [r4]
 80a5460:	eb03 0081 	add.w	r0, r3, r1, lsl #2
        for (; p != end; ++p) {
 80a5464:	4283      	cmp	r3, r0
 80a5466:	461a      	mov	r2, r3
 80a5468:	d00a      	beq.n	80a5480 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x36>
            if (*p == value) {
 80a546a:	6812      	ldr	r2, [r2, #0]
 80a546c:	3304      	adds	r3, #4
 80a546e:	42aa      	cmp	r2, r5
 80a5470:	d1f8      	bne.n	80a5464 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x1a>
    LOG_WITH_LOCK(mutex_) {
 80a5472:	a801      	add	r0, sp, #4
 80a5474:	f7ff fe2f 	bl	80a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
            return false;
 80a5478:	2500      	movs	r5, #0
}
 80a547a:	4628      	mov	r0, r5
 80a547c:	b003      	add	sp, #12
 80a547e:	bd30      	pop	{r4, r5, pc}
    return insert(size_, std::move(value));
 80a5480:	462a      	mov	r2, r5
 80a5482:	4620      	mov	r0, r4
 80a5484:	f7ff ffba 	bl	80a53fc <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_>
        if (activeHandlers_.contains(handler) || !activeHandlers_.append(handler)) {
 80a5488:	4605      	mov	r5, r0
 80a548a:	2800      	cmp	r0, #0
 80a548c:	d0f1      	beq.n	80a5472 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x28>
        if (activeHandlers_.size() == 1) {
 80a548e:	6863      	ldr	r3, [r4, #4]
 80a5490:	2b01      	cmp	r3, #1
 80a5492:	d101      	bne.n	80a5498 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x4e>
            setSystemCallbacks();
 80a5494:	f7ff fcfa 	bl	80a4e8c <_ZN5spark10LogManager18setSystemCallbacksEv>
    LOG_WITH_LOCK(mutex_) {
 80a5498:	a801      	add	r0, sp, #4
 80a549a:	f7ff fe1c 	bl	80a50d6 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
 80a549e:	e7ec      	b.n	80a547a <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x30>

080a54a0 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>:
        if (dest > p && dest < end) {
 80a54a0:	4288      	cmp	r0, r1
    static void move(T* dest, T* p, T* end) {
 80a54a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a54a4:	4604      	mov	r4, r0
 80a54a6:	460d      	mov	r5, r1
 80a54a8:	4616      	mov	r6, r2
        if (dest > p && dest < end) {
 80a54aa:	d914      	bls.n	80a54d6 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x36>
 80a54ac:	4290      	cmp	r0, r2
 80a54ae:	d213      	bcs.n	80a54d8 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x38>
            --end;
 80a54b0:	f1a2 0610 	sub.w	r6, r2, #16
            dest += end - p - 1;
 80a54b4:	1a75      	subs	r5, r6, r1
 80a54b6:	f1a1 0710 	sub.w	r7, r1, #16
 80a54ba:	442c      	add	r4, r5
            for (; end != p; --end, --dest) {
 80a54bc:	42b7      	cmp	r7, r6
 80a54be:	d018      	beq.n	80a54f2 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
                new(dest) T(std::move(*end));
 80a54c0:	b11c      	cbz	r4, 80a54ca <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x2a>
 80a54c2:	4631      	mov	r1, r6
 80a54c4:	4620      	mov	r0, r4
 80a54c6:	f000 fdea 	bl	80a609e <_ZN6StringC1EOS_>
                end->~T();
 80a54ca:	4630      	mov	r0, r6
 80a54cc:	f000 fd6d 	bl	80a5faa <_ZN6StringD1Ev>
            for (; end != p; --end, --dest) {
 80a54d0:	3e10      	subs	r6, #16
 80a54d2:	3c10      	subs	r4, #16
 80a54d4:	e7f2      	b.n	80a54bc <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x1c>
        } else if (dest != p) {
 80a54d6:	d00c      	beq.n	80a54f2 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
            for (; p != end; ++p, ++dest) {
 80a54d8:	42b5      	cmp	r5, r6
 80a54da:	d00a      	beq.n	80a54f2 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
                new(dest) T(std::move(*p));
 80a54dc:	b11c      	cbz	r4, 80a54e6 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x46>
 80a54de:	4629      	mov	r1, r5
 80a54e0:	4620      	mov	r0, r4
 80a54e2:	f000 fddc 	bl	80a609e <_ZN6StringC1EOS_>
                p->~T();
 80a54e6:	4628      	mov	r0, r5
 80a54e8:	f000 fd5f 	bl	80a5faa <_ZN6StringD1Ev>
            for (; p != end; ++p, ++dest) {
 80a54ec:	3510      	adds	r5, #16
 80a54ee:	3410      	adds	r4, #16
 80a54f0:	e7f2      	b.n	80a54d8 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x38>
    }
 80a54f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a54f4 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>:
    bool realloc(int n) {
 80a54f4:	b570      	push	{r4, r5, r6, lr}
        if (n > 0) {
 80a54f6:	1e0e      	subs	r6, r1, #0
    bool realloc(int n) {
 80a54f8:	4605      	mov	r5, r0
        if (n > 0) {
 80a54fa:	dd11      	ble.n	80a5520 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x2c>
    return ::malloc(size);
 80a54fc:	0130      	lsls	r0, r6, #4
 80a54fe:	f7ff f84d 	bl	80a459c <malloc>
            if (!d) {
 80a5502:	4604      	mov	r4, r0
 80a5504:	b158      	cbz	r0, 80a551e <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x2a>
            move(d, data_, data_ + size_);
 80a5506:	e9d5 1200 	ldrd	r1, r2, [r5]
 80a550a:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 80a550e:	f7ff ffc7 	bl	80a54a0 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
    ::free(ptr);
 80a5512:	6828      	ldr	r0, [r5, #0]
 80a5514:	f7ff f84a 	bl	80a45ac <free>
        return true;
 80a5518:	2001      	movs	r0, #1
        data_ = d;
 80a551a:	602c      	str	r4, [r5, #0]
        capacity_ = n;
 80a551c:	60ae      	str	r6, [r5, #8]
    }
 80a551e:	bd70      	pop	{r4, r5, r6, pc}
        T* d = nullptr;
 80a5520:	2400      	movs	r4, #0
 80a5522:	e7f6      	b.n	80a5512 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x1e>

080a5524 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>:
spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a5524:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a5528:	4691      	mov	r9, r2
        capacity_(0) {
 80a552a:	2300      	movs	r3, #0
        level_(LOG_LEVEL_NONE) { // Fallback level that will be used in case of construction errors
 80a552c:	2246      	movs	r2, #70	; 0x46
spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a552e:	b097      	sub	sp, #92	; 0x5c
 80a5530:	9103      	str	r1, [sp, #12]
    if (!cats.reserve(filters.size())) {
 80a5532:	f8d9 1004 	ldr.w	r1, [r9, #4]
spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a5536:	4604      	mov	r4, r0
    if (n > capacity_ && !realloc(n)) {
 80a5538:	4299      	cmp	r1, r3
        capacity_(0) {
 80a553a:	e9c0 3300 	strd	r3, r3, [r0]
 80a553e:	e9c0 3302 	strd	r3, r3, [r0, #8]
 80a5542:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80a5546:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
        level_(LOG_LEVEL_NONE) { // Fallback level that will be used in case of construction errors
 80a554a:	7602      	strb	r2, [r0, #24]
 80a554c:	930c      	str	r3, [sp, #48]	; 0x30
    if (n > capacity_ && !realloc(n)) {
 80a554e:	dc23      	bgt.n	80a5598 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x74>
    return data_ + size_;
 80a5550:	e9d9 5700 	ldrd	r5, r7, [r9]
 80a5554:	2314      	movs	r3, #20
 80a5556:	fb03 5707 	mla	r7, r3, r7, r5
    for (LogCategoryFilter &filter: filters) {
 80a555a:	42af      	cmp	r7, r5
 80a555c:	d03b      	beq.n	80a55d6 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xb2>
        cats.append(std::move(filter.cat_));
 80a555e:	4629      	mov	r1, r5
 80a5560:	a80d      	add	r0, sp, #52	; 0x34
 80a5562:	f000 fd9c 	bl	80a609e <_ZN6StringC1EOS_>
    return insert(size_, std::move(value));
 80a5566:	a90d      	add	r1, sp, #52	; 0x34
 80a5568:	a811      	add	r0, sp, #68	; 0x44
 80a556a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 80a556c:	f000 fd97 	bl	80a609e <_ZN6StringC1EOS_>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a5570:	e9dd 130b 	ldrd	r1, r3, [sp, #44]	; 0x2c
 80a5574:	4299      	cmp	r1, r3
 80a5576:	da1b      	bge.n	80a55b0 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x8c>
    T* const p = data_ + i;
 80a5578:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    move(p + 1, p, data_ + size_);
 80a557a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    T* const p = data_ + i;
 80a557c:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    move(p + 1, p, data_ + size_);
 80a5580:	4631      	mov	r1, r6
 80a5582:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 80a5586:	f106 0010 	add.w	r0, r6, #16
 80a558a:	f7ff ff89 	bl	80a54a0 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
    new(p) T(std::move(value));
 80a558e:	b9ee      	cbnz	r6, 80a55cc <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xa8>
    ++size_;
 80a5590:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80a5592:	3301      	adds	r3, #1
 80a5594:	930b      	str	r3, [sp, #44]	; 0x2c
    return true;
 80a5596:	e011      	b.n	80a55bc <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x98>
    if (n > capacity_ && !realloc(n)) {
 80a5598:	a80a      	add	r0, sp, #40	; 0x28
 80a559a:	f7ff ffab 	bl	80a54f4 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a559e:	2800      	cmp	r0, #0
 80a55a0:	d1d6      	bne.n	80a5550 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x2c>
    Vector<String> cats;
 80a55a2:	a80a      	add	r0, sp, #40	; 0x28
 80a55a4:	f7ff fd42 	bl	80a502c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
}
 80a55a8:	4620      	mov	r0, r4
 80a55aa:	b017      	add	sp, #92	; 0x5c
 80a55ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a55b0:	3101      	adds	r1, #1
 80a55b2:	a80a      	add	r0, sp, #40	; 0x28
 80a55b4:	f7ff ff9e 	bl	80a54f4 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a55b8:	2800      	cmp	r0, #0
 80a55ba:	d1dd      	bne.n	80a5578 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x54>
    return insert(size_, std::move(value));
 80a55bc:	a811      	add	r0, sp, #68	; 0x44
 80a55be:	f000 fcf4 	bl	80a5faa <_ZN6StringD1Ev>
        cats.append(std::move(filter.cat_));
 80a55c2:	a80d      	add	r0, sp, #52	; 0x34
 80a55c4:	f000 fcf1 	bl	80a5faa <_ZN6StringD1Ev>
    for (LogCategoryFilter &filter: filters) {
 80a55c8:	3514      	adds	r5, #20
 80a55ca:	e7c6      	b.n	80a555a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x36>
    new(p) T(std::move(value));
 80a55cc:	4630      	mov	r0, r6
 80a55ce:	a911      	add	r1, sp, #68	; 0x44
 80a55d0:	f000 fd65 	bl	80a609e <_ZN6StringC1EOS_>
 80a55d4:	e7dc      	b.n	80a5590 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x6c>
        capacity_(0) {
 80a55d6:	2600      	movs	r6, #0
 80a55d8:	f04f 0a14 	mov.w	sl, #20
        size_t size = 0; // Name length
 80a55dc:	4637      	mov	r7, r6
 80a55de:	e9cd 660d 	strd	r6, r6, [sp, #52]	; 0x34
 80a55e2:	960f      	str	r6, [sp, #60]	; 0x3c
    for (int i = 0; i < cats.size(); ++i) {
 80a55e4:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 80a55e8:	429e      	cmp	r6, r3
 80a55ea:	f280 8097 	bge.w	80a571c <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1f8>
        const char *category = cats.at(i).c_str();
 80a55ee:	0133      	lsls	r3, r6, #4
 80a55f0:	58d3      	ldr	r3, [r2, r3]
 80a55f2:	9308      	str	r3, [sp, #32]
        if (!category) {
 80a55f4:	b90b      	cbnz	r3, 80a55fa <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xd6>
    for (int i = 0; i < cats.size(); ++i) {
 80a55f6:	3601      	adds	r6, #1
 80a55f8:	e7f4      	b.n	80a55e4 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xc0>
        size_t size = 0; // Name length
 80a55fa:	fb0a f306 	mul.w	r3, sl, r6
 80a55fe:	9709      	str	r7, [sp, #36]	; 0x24
 80a5600:	9302      	str	r3, [sp, #8]
        Vector<Node> *pNodes = &nodes; // Root nodes
 80a5602:	ad0d      	add	r5, sp, #52	; 0x34
        while ((name = nextSubcategoryName(category, size))) {
 80a5604:	a909      	add	r1, sp, #36	; 0x24
 80a5606:	a808      	add	r0, sp, #32
 80a5608:	f7ff fae7 	bl	80a4bda <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>
 80a560c:	4683      	mov	fp, r0
 80a560e:	2800      	cmp	r0, #0
 80a5610:	d0f1      	beq.n	80a55f6 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xd2>
            const int index = nodeIndex(*pNodes, name, size, found);
 80a5612:	4601      	mov	r1, r0
 80a5614:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80a5616:	4628      	mov	r0, r5
 80a5618:	f10d 031f 	add.w	r3, sp, #31
            bool found = false;
 80a561c:	f88d 701f 	strb.w	r7, [sp, #31]
            const int index = nodeIndex(*pNodes, name, size, found);
 80a5620:	f7ff fb66 	bl	80a4cf0 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a5624:	f89d 801f 	ldrb.w	r8, [sp, #31]
            const int index = nodeIndex(*pNodes, name, size, found);
 80a5628:	9001      	str	r0, [sp, #4]
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a562a:	f1b8 0f00 	cmp.w	r8, #0
 80a562e:	d166      	bne.n	80a56fe <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1da>
 80a5630:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 80a5634:	e9cd 8813 	strd	r8, r8, [sp, #76]	; 0x4c
            level(-1) {
 80a5638:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
 80a563c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80a5640:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
 80a5644:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
 80a5648:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a564c:	e9d5 3201 	ldrd	r3, r2, [r5, #4]
 80a5650:	4293      	cmp	r3, r2
 80a5652:	db1a      	blt.n	80a568a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x166>
 80a5654:	f103 0b01 	add.w	fp, r3, #1
        if (n > 0) {
 80a5658:	f1bb 0f00 	cmp.w	fp, #0
 80a565c:	dd4a      	ble.n	80a56f4 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d0>
    return ::malloc(size);
 80a565e:	fb0a f00b 	mul.w	r0, sl, fp
 80a5662:	f7fe ff9b 	bl	80a459c <malloc>
            if (!d) {
 80a5666:	9004      	str	r0, [sp, #16]
 80a5668:	2800      	cmp	r0, #0
 80a566a:	d045      	beq.n	80a56f8 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d4>
            move(d, data_, data_ + size_);
 80a566c:	e9d5 1200 	ldrd	r1, r2, [r5]
 80a5670:	fb0a 1202 	mla	r2, sl, r2, r1
 80a5674:	f7ff fe72 	bl	80a535c <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>
 80a5678:	9b04      	ldr	r3, [sp, #16]
    ::free(ptr);
 80a567a:	6828      	ldr	r0, [r5, #0]
 80a567c:	9304      	str	r3, [sp, #16]
 80a567e:	f7fe ff95 	bl	80a45ac <free>
        data_ = d;
 80a5682:	9b04      	ldr	r3, [sp, #16]
        capacity_ = n;
 80a5684:	f8c5 b008 	str.w	fp, [r5, #8]
        data_ = d;
 80a5688:	602b      	str	r3, [r5, #0]
    T* const p = data_ + i;
 80a568a:	9b01      	ldr	r3, [sp, #4]
 80a568c:	f8d5 b000 	ldr.w	fp, [r5]
 80a5690:	fb0a f303 	mul.w	r3, sl, r3
    move(p + 1, p, data_ + size_);
 80a5694:	686a      	ldr	r2, [r5, #4]
    T* const p = data_ + i;
 80a5696:	eb0b 0103 	add.w	r1, fp, r3
    move(p + 1, p, data_ + size_);
 80a569a:	f101 0014 	add.w	r0, r1, #20
 80a569e:	fb0a b202 	mla	r2, sl, r2, fp
 80a56a2:	9104      	str	r1, [sp, #16]
    T* const p = data_ + i;
 80a56a4:	9305      	str	r3, [sp, #20]
    move(p + 1, p, data_ + size_);
 80a56a6:	f7ff fe59 	bl	80a535c <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>
    new(p) T(std::move(value));
 80a56aa:	9904      	ldr	r1, [sp, #16]
 80a56ac:	b1a9      	cbz	r1, 80a56da <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1b6>
struct spark::detail::LogFilter::Node {
 80a56ae:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80a56b0:	9b05      	ldr	r3, [sp, #20]
 80a56b2:	f84b 2003 	str.w	r2, [fp, r3]
 80a56b6:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 80a56ba:	808b      	strh	r3, [r1, #4]
 80a56bc:	f9bd 304a 	ldrsh.w	r3, [sp, #74]	; 0x4a
        capacity_(0) {
 80a56c0:	e9c1 7702 	strd	r7, r7, [r1, #8]
 80a56c4:	610f      	str	r7, [r1, #16]
 80a56c6:	80cb      	strh	r3, [r1, #6]
      __a = _GLIBCXX_MOVE(__b);
 80a56c8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80a56ca:	608b      	str	r3, [r1, #8]
 80a56cc:	9b14      	ldr	r3, [sp, #80]	; 0x50
      __b = _GLIBCXX_MOVE(__tmp);
 80a56ce:	9713      	str	r7, [sp, #76]	; 0x4c
      __a = _GLIBCXX_MOVE(__b);
 80a56d0:	60cb      	str	r3, [r1, #12]
 80a56d2:	9b15      	ldr	r3, [sp, #84]	; 0x54
      __b = _GLIBCXX_MOVE(__tmp);
 80a56d4:	9714      	str	r7, [sp, #80]	; 0x50
      __a = _GLIBCXX_MOVE(__b);
 80a56d6:	610b      	str	r3, [r1, #16]
      __b = _GLIBCXX_MOVE(__tmp);
 80a56d8:	9715      	str	r7, [sp, #84]	; 0x54
    ++size_;
 80a56da:	686b      	ldr	r3, [r5, #4]
 80a56dc:	3301      	adds	r3, #1
 80a56de:	606b      	str	r3, [r5, #4]
 80a56e0:	a813      	add	r0, sp, #76	; 0x4c
 80a56e2:	f7ff fc8f 	bl	80a5004 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a56e6:	f1b8 0f00 	cmp.w	r8, #0
 80a56ea:	d008      	beq.n	80a56fe <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1da>
    Vector<Node> nodes;
 80a56ec:	a80d      	add	r0, sp, #52	; 0x34
 80a56ee:	f7ff fc89 	bl	80a5004 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a56f2:	e756      	b.n	80a55a2 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x7e>
        T* d = nullptr;
 80a56f4:	4643      	mov	r3, r8
 80a56f6:	e7c0      	b.n	80a567a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x156>
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a56f8:	f04f 0801 	mov.w	r8, #1
 80a56fc:	e7f0      	b.n	80a56e0 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1bc>
    return data_[i];
 80a56fe:	9b01      	ldr	r3, [sp, #4]
 80a5700:	682d      	ldr	r5, [r5, #0]
 80a5702:	fb0a 5503 	mla	r5, sl, r3, r5
            if (!*category) { // Check if it's last subcategory
 80a5706:	9b08      	ldr	r3, [sp, #32]
 80a5708:	781b      	ldrb	r3, [r3, #0]
 80a570a:	b92b      	cbnz	r3, 80a5718 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1f4>
                node.level = filters.at(i).level_;
 80a570c:	f8d9 3000 	ldr.w	r3, [r9]
 80a5710:	9a02      	ldr	r2, [sp, #8]
 80a5712:	4413      	add	r3, r2
 80a5714:	7c1b      	ldrb	r3, [r3, #16]
 80a5716:	80eb      	strh	r3, [r5, #6]
            pNodes = &node.nodes;
 80a5718:	3508      	adds	r5, #8
        while ((name = nextSubcategoryName(category, size))) {
 80a571a:	e773      	b.n	80a5604 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xe0>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a571c:	6821      	ldr	r1, [r4, #0]
      __a = _GLIBCXX_MOVE(__b);
 80a571e:	6022      	str	r2, [r4, #0]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a5720:	6862      	ldr	r2, [r4, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a5722:	6063      	str	r3, [r4, #4]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a5724:	68a3      	ldr	r3, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a5726:	920b      	str	r2, [sp, #44]	; 0x2c
      __a = _GLIBCXX_MOVE(__b);
 80a5728:	9a0c      	ldr	r2, [sp, #48]	; 0x30
      __b = _GLIBCXX_MOVE(__tmp);
 80a572a:	930c      	str	r3, [sp, #48]	; 0x30
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a572c:	68e3      	ldr	r3, [r4, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a572e:	60a2      	str	r2, [r4, #8]
 80a5730:	9a0d      	ldr	r2, [sp, #52]	; 0x34
      __b = _GLIBCXX_MOVE(__tmp);
 80a5732:	930d      	str	r3, [sp, #52]	; 0x34
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a5734:	6923      	ldr	r3, [r4, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a5736:	60e2      	str	r2, [r4, #12]
 80a5738:	9a0e      	ldr	r2, [sp, #56]	; 0x38
      __b = _GLIBCXX_MOVE(__tmp);
 80a573a:	930e      	str	r3, [sp, #56]	; 0x38
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a573c:	6963      	ldr	r3, [r4, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a573e:	6122      	str	r2, [r4, #16]
 80a5740:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
      __b = _GLIBCXX_MOVE(__tmp);
 80a5742:	930f      	str	r3, [sp, #60]	; 0x3c
    level_ = level;
 80a5744:	9b03      	ldr	r3, [sp, #12]
 80a5746:	910a      	str	r1, [sp, #40]	; 0x28
      __a = _GLIBCXX_MOVE(__b);
 80a5748:	6162      	str	r2, [r4, #20]
 80a574a:	7623      	strb	r3, [r4, #24]
 80a574c:	e7ce      	b.n	80a56ec <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1c8>
	...

080a5750 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>:
inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
 80a5750:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
        filter_(level, filters) {
 80a5752:	4605      	mov	r5, r0
inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
 80a5754:	460e      	mov	r6, r1
 80a5756:	4604      	mov	r4, r0
        filter_(level, filters) {
 80a5758:	4b08      	ldr	r3, [pc, #32]	; (80a577c <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x2c>)
 80a575a:	4611      	mov	r1, r2
 80a575c:	f845 3b04 	str.w	r3, [r5], #4
 80a5760:	a801      	add	r0, sp, #4
 80a5762:	f7fb fc8d 	bl	80a1080 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a5766:	4631      	mov	r1, r6
 80a5768:	aa01      	add	r2, sp, #4
 80a576a:	4628      	mov	r0, r5
 80a576c:	f7ff feda 	bl	80a5524 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a5770:	a801      	add	r0, sp, #4
 80a5772:	f7fb fb67 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
}
 80a5776:	4620      	mov	r0, r4
 80a5778:	b004      	add	sp, #16
 80a577a:	bd70      	pop	{r4, r5, r6, pc}
 80a577c:	080a7dc8 	.word	0x080a7dc8

080a5780 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE>:
            Print *stream, const JSONValue &params) {
 80a5780:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5782:	460f      	mov	r7, r1
 80a5784:	b087      	sub	sp, #28
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
 80a5786:	4638      	mov	r0, r7
 80a5788:	4925      	ldr	r1, [pc, #148]	; (80a5820 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa0>)
            Print *stream, const JSONValue &params) {
 80a578a:	4616      	mov	r6, r2
 80a578c:	461d      	mov	r5, r3
 80a578e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
 80a5790:	f002 f909 	bl	80a79a6 <strcmp>
 80a5794:	bb00      	cbnz	r0, 80a57d8 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x58>
        if (!stream) {
 80a5796:	b1e4      	cbz	r4, 80a57d2 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x52>
        return new(std::nothrow) JSONStreamLogHandler(*stream, level, std::move(filters));
 80a5798:	4629      	mov	r1, r5
 80a579a:	4668      	mov	r0, sp
 80a579c:	f7ff fc8c 	bl	80a50b8 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
 80a57a0:	2024      	movs	r0, #36	; 0x24
 80a57a2:	4920      	ldr	r1, [pc, #128]	; (80a5824 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa4>)
 80a57a4:	f001 f856 	bl	80a6854 <_ZnwjRKSt9nothrow_t>
 80a57a8:	4605      	mov	r5, r0
 80a57aa:	b170      	cbz	r0, 80a57ca <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x4a>
        stream_(&stream) {
 80a57ac:	4669      	mov	r1, sp
 80a57ae:	a803      	add	r0, sp, #12
 80a57b0:	f7fb fc66 	bl	80a1080 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a57b4:	4631      	mov	r1, r6
 80a57b6:	aa03      	add	r2, sp, #12
 80a57b8:	4628      	mov	r0, r5
 80a57ba:	f7ff ffc9 	bl	80a5750 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a57be:	a803      	add	r0, sp, #12
 80a57c0:	f7fb fb40 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
    using StreamLogHandler::StreamLogHandler;
 80a57c4:	4b18      	ldr	r3, [pc, #96]	; (80a5828 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa8>)
        stream_(&stream) {
 80a57c6:	622c      	str	r4, [r5, #32]
    using StreamLogHandler::StreamLogHandler;
 80a57c8:	602b      	str	r3, [r5, #0]
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
 80a57ca:	4668      	mov	r0, sp
 80a57cc:	f7fb fb3a 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a57d0:	462c      	mov	r4, r5
}
 80a57d2:	4620      	mov	r0, r4
 80a57d4:	b007      	add	sp, #28
 80a57d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    } else if (strcmp(type, "StreamLogHandler") == 0) {
 80a57d8:	4638      	mov	r0, r7
 80a57da:	4914      	ldr	r1, [pc, #80]	; (80a582c <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xac>)
 80a57dc:	f002 f8e3 	bl	80a79a6 <strcmp>
 80a57e0:	b9e0      	cbnz	r0, 80a581c <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x9c>
        if (!stream) {
 80a57e2:	2c00      	cmp	r4, #0
 80a57e4:	d0f5      	beq.n	80a57d2 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x52>
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
 80a57e6:	4629      	mov	r1, r5
 80a57e8:	4668      	mov	r0, sp
 80a57ea:	f7ff fc65 	bl	80a50b8 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
 80a57ee:	2024      	movs	r0, #36	; 0x24
 80a57f0:	490c      	ldr	r1, [pc, #48]	; (80a5824 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa4>)
 80a57f2:	f001 f82f 	bl	80a6854 <_ZnwjRKSt9nothrow_t>
 80a57f6:	4605      	mov	r5, r0
 80a57f8:	2800      	cmp	r0, #0
 80a57fa:	d0e6      	beq.n	80a57ca <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x4a>
        stream_(&stream) {
 80a57fc:	4669      	mov	r1, sp
 80a57fe:	a803      	add	r0, sp, #12
 80a5800:	f7fb fc3e 	bl	80a1080 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a5804:	4631      	mov	r1, r6
 80a5806:	aa03      	add	r2, sp, #12
 80a5808:	4628      	mov	r0, r5
 80a580a:	f7ff ffa1 	bl	80a5750 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a580e:	a803      	add	r0, sp, #12
 80a5810:	f7fb fb18 	bl	80a0e44 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a5814:	4b06      	ldr	r3, [pc, #24]	; (80a5830 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb0>)
 80a5816:	622c      	str	r4, [r5, #32]
 80a5818:	602b      	str	r3, [r5, #0]
}
 80a581a:	e7d6      	b.n	80a57ca <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x4a>
            return nullptr; // Output stream is not specified
 80a581c:	2400      	movs	r4, #0
 80a581e:	e7d8      	b.n	80a57d2 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x52>
 80a5820:	080a7e8b 	.word	0x080a7e8b
 80a5824:	080a805c 	.word	0x080a805c
 80a5828:	080a7f20 	.word	0x080a7f20
 80a582c:	080a7e8f 	.word	0x080a7e8f
 80a5830:	080a7f08 	.word	0x080a7f08

080a5834 <_GLOBAL__sub_I__ZN5spark3LogE>:
        name_(name) {
 80a5834:	4b01      	ldr	r3, [pc, #4]	; (80a583c <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a5836:	4a02      	ldr	r2, [pc, #8]	; (80a5840 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a5838:	601a      	str	r2, [r3, #0]
#if Wiring_LogConfig

// spark::
void spark::logProcessControlRequest(ctrl_request* req) {
    JSONRequestHandler::process(req);
}
 80a583a:	4770      	bx	lr
 80a583c:	20001634 	.word	0x20001634
 80a5840:	080a7da5 	.word	0x080a7da5

080a5844 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes>:
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a5844:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a5848:	9d08      	ldr	r5, [sp, #32]
    if (stream_ == &Serial && Network.listening()) {
 80a584a:	f8d0 9020 	ldr.w	r9, [r0, #32]
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a584e:	4604      	mov	r4, r0
 80a5850:	460e      	mov	r6, r1
 80a5852:	4617      	mov	r7, r2
 80a5854:	4698      	mov	r8, r3
    if (stream_ == &Serial && Network.listening()) {
 80a5856:	f000 fd53 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a585a:	4581      	cmp	r9, r0
 80a585c:	d04d      	beq.n	80a58fa <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb6>
    if (attr.has_time) {
 80a585e:	792b      	ldrb	r3, [r5, #4]
 80a5860:	0719      	lsls	r1, r3, #28
 80a5862:	d504      	bpl.n	80a586e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x2a>
        printf("%010u ", (unsigned)attr.time);
 80a5864:	4620      	mov	r0, r4
 80a5866:	696a      	ldr	r2, [r5, #20]
 80a5868:	4954      	ldr	r1, [pc, #336]	; (80a59bc <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x178>)
 80a586a:	f7ff fa31 	bl	80a4cd0 <_ZN5spark16StreamLogHandler6printfEPKcz>
    if (category) {
 80a586e:	f1b8 0f00 	cmp.w	r8, #0
 80a5872:	d00d      	beq.n	80a5890 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x4c>
        write('[');
 80a5874:	215b      	movs	r1, #91	; 0x5b
 80a5876:	4620      	mov	r0, r4
 80a5878:	f7ff fa1e 	bl	80a4cb8 <_ZN5spark16StreamLogHandler5writeEc>
        write(category);
 80a587c:	4641      	mov	r1, r8
 80a587e:	4620      	mov	r0, r4
 80a5880:	f7ff fa0c 	bl	80a4c9c <_ZN5spark16StreamLogHandler5writeEPKc>
        write("] ", 2);
 80a5884:	6823      	ldr	r3, [r4, #0]
 80a5886:	2202      	movs	r2, #2
 80a5888:	4620      	mov	r0, r4
 80a588a:	68db      	ldr	r3, [r3, #12]
 80a588c:	494c      	ldr	r1, [pc, #304]	; (80a59c0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x17c>)
 80a588e:	4798      	blx	r3
    if (attr.has_file) {
 80a5890:	792b      	ldrb	r3, [r5, #4]
 80a5892:	07da      	lsls	r2, r3, #31
 80a5894:	d524      	bpl.n	80a58e0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x9c>
        s = extractFileName(attr.file); // Strip directory path
 80a5896:	f8d5 8008 	ldr.w	r8, [r5, #8]
    const char *s1 = strrchr(s, '/');
 80a589a:	212f      	movs	r1, #47	; 0x2f
 80a589c:	4640      	mov	r0, r8
 80a589e:	f002 f8d4 	bl	80a7a4a <strrchr>
    if (s1) {
 80a58a2:	b108      	cbz	r0, 80a58a8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x64>
        return s1 + 1;
 80a58a4:	f100 0801 	add.w	r8, r0, #1
        write(s); // File name
 80a58a8:	4641      	mov	r1, r8
 80a58aa:	4620      	mov	r0, r4
 80a58ac:	f7ff f9f6 	bl	80a4c9c <_ZN5spark16StreamLogHandler5writeEPKc>
        if (attr.has_line) {
 80a58b0:	792b      	ldrb	r3, [r5, #4]
 80a58b2:	079b      	lsls	r3, r3, #30
 80a58b4:	d508      	bpl.n	80a58c8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x84>
            write(':');
 80a58b6:	213a      	movs	r1, #58	; 0x3a
 80a58b8:	4620      	mov	r0, r4
 80a58ba:	f7ff f9fd 	bl	80a4cb8 <_ZN5spark16StreamLogHandler5writeEc>
            printf("%d", (int)attr.line); // Line number
 80a58be:	4620      	mov	r0, r4
 80a58c0:	68ea      	ldr	r2, [r5, #12]
 80a58c2:	4940      	ldr	r1, [pc, #256]	; (80a59c4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x180>)
 80a58c4:	f7ff fa04 	bl	80a4cd0 <_ZN5spark16StreamLogHandler6printfEPKcz>
        if (attr.has_function) {
 80a58c8:	792a      	ldrb	r2, [r5, #4]
 80a58ca:	6823      	ldr	r3, [r4, #0]
 80a58cc:	f012 0f04 	tst.w	r2, #4
            write(": ", 2);
 80a58d0:	4620      	mov	r0, r4
            write(", ", 2);
 80a58d2:	f04f 0202 	mov.w	r2, #2
 80a58d6:	68db      	ldr	r3, [r3, #12]
 80a58d8:	bf14      	ite	ne
 80a58da:	493b      	ldrne	r1, [pc, #236]	; (80a59c8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x184>)
            write(": ", 2);
 80a58dc:	493b      	ldreq	r1, [pc, #236]	; (80a59cc <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x188>)
 80a58de:	4798      	blx	r3
    if (attr.has_function) {
 80a58e0:	792b      	ldrb	r3, [r5, #4]
 80a58e2:	0758      	lsls	r0, r3, #29
 80a58e4:	d51d      	bpl.n	80a5922 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xde>
        s = extractFuncName(attr.function, &n); // Strip argument and return types
 80a58e6:	6929      	ldr	r1, [r5, #16]
const char* extractFuncName(const char *s, size_t *size) {
 80a58e8:	460b      	mov	r3, r1
 80a58ea:	461a      	mov	r2, r3
    for (; *s; ++s) {
 80a58ec:	f813 0b01 	ldrb.w	r0, [r3], #1
 80a58f0:	b160      	cbz	r0, 80a590c <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc8>
        if (*s == ' ') {
 80a58f2:	2820      	cmp	r0, #32
 80a58f4:	d108      	bne.n	80a5908 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc4>
            s1 = s + 1; // Skip return type
 80a58f6:	4619      	mov	r1, r3
 80a58f8:	e7f7      	b.n	80a58ea <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xa6>
    if (stream_ == &Serial && Network.listening()) {
 80a58fa:	4835      	ldr	r0, [pc, #212]	; (80a59d0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x18c>)
 80a58fc:	f000 f967 	bl	80a5bce <_ZN5spark12NetworkClass9listeningEv>
 80a5900:	2800      	cmp	r0, #0
 80a5902:	d0ac      	beq.n	80a585e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1a>
}
 80a5904:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        } else if (*s == '(') {
 80a5908:	2828      	cmp	r0, #40	; 0x28
 80a590a:	d1ee      	bne.n	80a58ea <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xa6>
        write(s, n);
 80a590c:	6823      	ldr	r3, [r4, #0]
 80a590e:	1a52      	subs	r2, r2, r1
 80a5910:	4620      	mov	r0, r4
 80a5912:	68db      	ldr	r3, [r3, #12]
 80a5914:	4798      	blx	r3
        write("(): ", 4);
 80a5916:	6823      	ldr	r3, [r4, #0]
 80a5918:	2204      	movs	r2, #4
 80a591a:	4620      	mov	r0, r4
 80a591c:	68db      	ldr	r3, [r3, #12]
 80a591e:	492d      	ldr	r1, [pc, #180]	; (80a59d4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x190>)
 80a5920:	4798      	blx	r3
    return log_level_name(level, nullptr);
 80a5922:	2100      	movs	r1, #0
 80a5924:	4638      	mov	r0, r7
 80a5926:	f7fe fd95 	bl	80a4454 <log_level_name>
 80a592a:	4601      	mov	r1, r0
    write(s);
 80a592c:	4620      	mov	r0, r4
 80a592e:	f7ff f9b5 	bl	80a4c9c <_ZN5spark16StreamLogHandler5writeEPKc>
    write(": ", 2);
 80a5932:	6823      	ldr	r3, [r4, #0]
 80a5934:	2202      	movs	r2, #2
 80a5936:	4620      	mov	r0, r4
 80a5938:	68db      	ldr	r3, [r3, #12]
 80a593a:	4924      	ldr	r1, [pc, #144]	; (80a59cc <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x188>)
 80a593c:	4798      	blx	r3
    if (msg) {
 80a593e:	b11e      	cbz	r6, 80a5948 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x104>
        write(msg);
 80a5940:	4631      	mov	r1, r6
 80a5942:	4620      	mov	r0, r4
 80a5944:	f7ff f9aa 	bl	80a4c9c <_ZN5spark16StreamLogHandler5writeEPKc>
    if (attr.has_code || attr.has_details) {
 80a5948:	792b      	ldrb	r3, [r5, #4]
 80a594a:	f013 0f30 	tst.w	r3, #48	; 0x30
 80a594e:	d02c      	beq.n	80a59aa <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x166>
        write(" [", 2);
 80a5950:	6823      	ldr	r3, [r4, #0]
 80a5952:	4921      	ldr	r1, [pc, #132]	; (80a59d8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x194>)
 80a5954:	68db      	ldr	r3, [r3, #12]
 80a5956:	2202      	movs	r2, #2
 80a5958:	4620      	mov	r0, r4
 80a595a:	4798      	blx	r3
        if (attr.has_code) {
 80a595c:	792b      	ldrb	r3, [r5, #4]
 80a595e:	06d9      	lsls	r1, r3, #27
 80a5960:	d50a      	bpl.n	80a5978 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x134>
            write("code = ", 7);
 80a5962:	6823      	ldr	r3, [r4, #0]
 80a5964:	2207      	movs	r2, #7
 80a5966:	4620      	mov	r0, r4
 80a5968:	491c      	ldr	r1, [pc, #112]	; (80a59dc <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x198>)
 80a596a:	68db      	ldr	r3, [r3, #12]
 80a596c:	4798      	blx	r3
            printf("%" PRIiPTR, (intptr_t)attr.code);
 80a596e:	4620      	mov	r0, r4
 80a5970:	69aa      	ldr	r2, [r5, #24]
 80a5972:	491b      	ldr	r1, [pc, #108]	; (80a59e0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x19c>)
 80a5974:	f7ff f9ac 	bl	80a4cd0 <_ZN5spark16StreamLogHandler6printfEPKcz>
        if (attr.has_details) {
 80a5978:	792b      	ldrb	r3, [r5, #4]
 80a597a:	069a      	lsls	r2, r3, #26
 80a597c:	d511      	bpl.n	80a59a2 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x15e>
            if (attr.has_code) {
 80a597e:	06db      	lsls	r3, r3, #27
 80a5980:	d505      	bpl.n	80a598e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x14a>
                write(", ", 2);
 80a5982:	6823      	ldr	r3, [r4, #0]
 80a5984:	2202      	movs	r2, #2
 80a5986:	4620      	mov	r0, r4
 80a5988:	68db      	ldr	r3, [r3, #12]
 80a598a:	490f      	ldr	r1, [pc, #60]	; (80a59c8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x184>)
 80a598c:	4798      	blx	r3
            write("details = ", 10);
 80a598e:	6823      	ldr	r3, [r4, #0]
 80a5990:	4620      	mov	r0, r4
 80a5992:	4914      	ldr	r1, [pc, #80]	; (80a59e4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1a0>)
 80a5994:	220a      	movs	r2, #10
 80a5996:	68db      	ldr	r3, [r3, #12]
 80a5998:	4798      	blx	r3
            write(attr.details);
 80a599a:	4620      	mov	r0, r4
 80a599c:	69e9      	ldr	r1, [r5, #28]
 80a599e:	f7ff f97d 	bl	80a4c9c <_ZN5spark16StreamLogHandler5writeEPKc>
        write(']');
 80a59a2:	215d      	movs	r1, #93	; 0x5d
 80a59a4:	4620      	mov	r0, r4
 80a59a6:	f7ff f987 	bl	80a4cb8 <_ZN5spark16StreamLogHandler5writeEc>
    write("\r\n", 2);
 80a59aa:	6823      	ldr	r3, [r4, #0]
 80a59ac:	4620      	mov	r0, r4
}
 80a59ae:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    write("\r\n", 2);
 80a59b2:	2202      	movs	r2, #2
 80a59b4:	68db      	ldr	r3, [r3, #12]
 80a59b6:	490c      	ldr	r1, [pc, #48]	; (80a59e8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1a4>)
 80a59b8:	4718      	bx	r3
 80a59ba:	bf00      	nop
 80a59bc:	080a7ea0 	.word	0x080a7ea0
 80a59c0:	080a7ea7 	.word	0x080a7ea7
 80a59c4:	080a7e68 	.word	0x080a7e68
 80a59c8:	080a7eaa 	.word	0x080a7eaa
 80a59cc:	080a7eaf 	.word	0x080a7eaf
 80a59d0:	20001660 	.word	0x20001660
 80a59d4:	080a7ead 	.word	0x080a7ead
 80a59d8:	080a7eb2 	.word	0x080a7eb2
 80a59dc:	080a7eb5 	.word	0x080a7eb5
 80a59e0:	080a7ebd 	.word	0x080a7ebd
 80a59e4:	080a7ec0 	.word	0x080a7ec0
 80a59e8:	080a7ecb 	.word	0x080a7ecb

080a59ec <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes>:
void spark::JSONStreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a59ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a59f0:	b085      	sub	sp, #20
    if (this->stream() == &Serial && Network.listening()) {
 80a59f2:	f8d0 9020 	ldr.w	r9, [r0, #32]
void spark::JSONStreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a59f6:	4605      	mov	r5, r0
 80a59f8:	460f      	mov	r7, r1
 80a59fa:	4690      	mov	r8, r2
 80a59fc:	461e      	mov	r6, r3
 80a59fe:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    if (this->stream() == &Serial && Network.listening()) {
 80a5a00:	f000 fc7e 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a5a04:	4581      	cmp	r9, r0
 80a5a06:	d105      	bne.n	80a5a14 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x28>
 80a5a08:	4849      	ldr	r0, [pc, #292]	; (80a5b30 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x144>)
 80a5a0a:	f000 f8e0 	bl	80a5bce <_ZN5spark12NetworkClass9listeningEv>
 80a5a0e:	2800      	cmp	r0, #0
 80a5a10:	f040 808a 	bne.w	80a5b28 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x13c>
        state_(BEGIN) {
 80a5a14:	f04f 0900 	mov.w	r9, #0
    JSONStreamWriter json(*this->stream());
 80a5a18:	6a2b      	ldr	r3, [r5, #32]
        strm_(stream) {
 80a5a1a:	4a46      	ldr	r2, [pc, #280]	; (80a5b34 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x148>)
    json.beginObject();
 80a5a1c:	a801      	add	r0, sp, #4
 80a5a1e:	9201      	str	r2, [sp, #4]
 80a5a20:	9303      	str	r3, [sp, #12]
        state_(BEGIN) {
 80a5a22:	f88d 9008 	strb.w	r9, [sp, #8]
 80a5a26:	f7ff f822 	bl	80a4a6e <_ZN5spark10JSONWriter11beginObjectEv>
 80a5a2a:	4649      	mov	r1, r9
 80a5a2c:	4640      	mov	r0, r8
 80a5a2e:	f7fe fd11 	bl	80a4454 <log_level_name>
 80a5a32:	4680      	mov	r8, r0
    json.name("l", 1).value(s);
 80a5a34:	4940      	ldr	r1, [pc, #256]	; (80a5b38 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x14c>)
 80a5a36:	2201      	movs	r2, #1
 80a5a38:	a801      	add	r0, sp, #4
 80a5a3a:	f7ff f8a1 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5a3e:	4641      	mov	r1, r8
 80a5a40:	f7ff f91f 	bl	80a4c82 <_ZN5spark10JSONWriter5valueEPKc>
    if (msg) {
 80a5a44:	b13f      	cbz	r7, 80a5a56 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x6a>
        json.name("m", 1).value(msg);
 80a5a46:	493d      	ldr	r1, [pc, #244]	; (80a5b3c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x150>)
 80a5a48:	2201      	movs	r2, #1
 80a5a4a:	a801      	add	r0, sp, #4
 80a5a4c:	f7ff f898 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5a50:	4639      	mov	r1, r7
 80a5a52:	f7ff f916 	bl	80a4c82 <_ZN5spark10JSONWriter5valueEPKc>
    if (category) {
 80a5a56:	b13e      	cbz	r6, 80a5a68 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x7c>
        json.name("c", 1).value(category);
 80a5a58:	4939      	ldr	r1, [pc, #228]	; (80a5b40 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x154>)
 80a5a5a:	2201      	movs	r2, #1
 80a5a5c:	a801      	add	r0, sp, #4
 80a5a5e:	f7ff f88f 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5a62:	4631      	mov	r1, r6
 80a5a64:	f7ff f90d 	bl	80a4c82 <_ZN5spark10JSONWriter5valueEPKc>
    if (attr.has_file) {
 80a5a68:	7923      	ldrb	r3, [r4, #4]
 80a5a6a:	07df      	lsls	r7, r3, #31
 80a5a6c:	d50e      	bpl.n	80a5a8c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xa0>
        s = extractFileName(attr.file); // Strip directory path
 80a5a6e:	68a6      	ldr	r6, [r4, #8]
    const char *s1 = strrchr(s, '/');
 80a5a70:	212f      	movs	r1, #47	; 0x2f
 80a5a72:	4630      	mov	r0, r6
 80a5a74:	f001 ffe9 	bl	80a7a4a <strrchr>
    if (s1) {
 80a5a78:	b100      	cbz	r0, 80a5a7c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x90>
        return s1 + 1;
 80a5a7a:	1c46      	adds	r6, r0, #1
        json.name("f", 1).value(s);
 80a5a7c:	4931      	ldr	r1, [pc, #196]	; (80a5b44 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x158>)
 80a5a7e:	2201      	movs	r2, #1
 80a5a80:	a801      	add	r0, sp, #4
 80a5a82:	f7ff f87d 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5a86:	4631      	mov	r1, r6
 80a5a88:	f7ff f8fb 	bl	80a4c82 <_ZN5spark10JSONWriter5valueEPKc>
    if (attr.has_line) {
 80a5a8c:	7923      	ldrb	r3, [r4, #4]
 80a5a8e:	079e      	lsls	r6, r3, #30
 80a5a90:	d507      	bpl.n	80a5aa2 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb6>
        json.name("ln", 2).value(attr.line);
 80a5a92:	492d      	ldr	r1, [pc, #180]	; (80a5b48 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x15c>)
 80a5a94:	2202      	movs	r2, #2
 80a5a96:	a801      	add	r0, sp, #4
 80a5a98:	f7ff f872 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5a9c:	68e1      	ldr	r1, [r4, #12]
 80a5a9e:	f7fe fff3 	bl	80a4a88 <_ZN5spark10JSONWriter5valueEi>
    if (attr.has_function) {
 80a5aa2:	7923      	ldrb	r3, [r4, #4]
 80a5aa4:	0758      	lsls	r0, r3, #29
 80a5aa6:	d514      	bpl.n	80a5ad2 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xe6>
        s = extractFuncName(attr.function, &n); // Strip argument and return types
 80a5aa8:	6926      	ldr	r6, [r4, #16]
const char* extractFuncName(const char *s, size_t *size) {
 80a5aaa:	4633      	mov	r3, r6
 80a5aac:	461f      	mov	r7, r3
    for (; *s; ++s) {
 80a5aae:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a5ab2:	b12a      	cbz	r2, 80a5ac0 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xd4>
        if (*s == ' ') {
 80a5ab4:	2a20      	cmp	r2, #32
 80a5ab6:	d101      	bne.n	80a5abc <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xd0>
            s1 = s + 1; // Skip return type
 80a5ab8:	461e      	mov	r6, r3
 80a5aba:	e7f7      	b.n	80a5aac <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc0>
        } else if (*s == '(') {
 80a5abc:	2a28      	cmp	r2, #40	; 0x28
 80a5abe:	d1f5      	bne.n	80a5aac <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc0>
        json.name("fn", 2).value(s, n);
 80a5ac0:	2202      	movs	r2, #2
 80a5ac2:	4922      	ldr	r1, [pc, #136]	; (80a5b4c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x160>)
 80a5ac4:	a801      	add	r0, sp, #4
 80a5ac6:	f7ff f85b 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5aca:	4631      	mov	r1, r6
 80a5acc:	1bba      	subs	r2, r7, r6
 80a5ace:	f7ff f866 	bl	80a4b9e <_ZN5spark10JSONWriter5valueEPKcj>
    if (attr.has_time) {
 80a5ad2:	7923      	ldrb	r3, [r4, #4]
 80a5ad4:	0719      	lsls	r1, r3, #28
 80a5ad6:	d507      	bpl.n	80a5ae8 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xfc>
        json.name("t", 1).value((unsigned)attr.time);
 80a5ad8:	491d      	ldr	r1, [pc, #116]	; (80a5b50 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x164>)
 80a5ada:	2201      	movs	r2, #1
 80a5adc:	a801      	add	r0, sp, #4
 80a5ade:	f7ff f84f 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5ae2:	6961      	ldr	r1, [r4, #20]
 80a5ae4:	f7fe ffe2 	bl	80a4aac <_ZN5spark10JSONWriter5valueEj>
    if (attr.has_code) {
 80a5ae8:	7923      	ldrb	r3, [r4, #4]
 80a5aea:	06da      	lsls	r2, r3, #27
 80a5aec:	d508      	bpl.n	80a5b00 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x114>
        json.name("code", 4).value((int)attr.code);
 80a5aee:	2204      	movs	r2, #4
 80a5af0:	4918      	ldr	r1, [pc, #96]	; (80a5b54 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x168>)
 80a5af2:	eb0d 0002 	add.w	r0, sp, r2
 80a5af6:	f7ff f843 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5afa:	69a1      	ldr	r1, [r4, #24]
 80a5afc:	f7fe ffc4 	bl	80a4a88 <_ZN5spark10JSONWriter5valueEi>
    if (attr.has_details) {
 80a5b00:	7923      	ldrb	r3, [r4, #4]
 80a5b02:	069b      	lsls	r3, r3, #26
 80a5b04:	d507      	bpl.n	80a5b16 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x12a>
        json.name("detail", 6).value(attr.details);
 80a5b06:	4914      	ldr	r1, [pc, #80]	; (80a5b58 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x16c>)
 80a5b08:	2206      	movs	r2, #6
 80a5b0a:	a801      	add	r0, sp, #4
 80a5b0c:	f7ff f838 	bl	80a4b80 <_ZN5spark10JSONWriter4nameEPKcj>
 80a5b10:	69e1      	ldr	r1, [r4, #28]
 80a5b12:	f7ff f8b6 	bl	80a4c82 <_ZN5spark10JSONWriter5valueEPKc>
    json.endObject();
 80a5b16:	a801      	add	r0, sp, #4
 80a5b18:	f7fe ff93 	bl	80a4a42 <_ZN5spark10JSONWriter9endObjectEv>
    this->stream()->write((const uint8_t*)"\r\n", 2);
 80a5b1c:	6a28      	ldr	r0, [r5, #32]
 80a5b1e:	2202      	movs	r2, #2
 80a5b20:	6803      	ldr	r3, [r0, #0]
 80a5b22:	490e      	ldr	r1, [pc, #56]	; (80a5b5c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x170>)
 80a5b24:	68db      	ldr	r3, [r3, #12]
 80a5b26:	4798      	blx	r3
}
 80a5b28:	b005      	add	sp, #20
 80a5b2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a5b2e:	bf00      	nop
 80a5b30:	20001660 	.word	0x20001660
 80a5b34:	080a7ef0 	.word	0x080a7ef0
 80a5b38:	080a7e7e 	.word	0x080a7e7e
 80a5b3c:	080a7ece 	.word	0x080a7ece
 80a5b40:	080a7ed0 	.word	0x080a7ed0
 80a5b44:	080a7ed2 	.word	0x080a7ed2
 80a5b48:	080a7ed4 	.word	0x080a7ed4
 80a5b4c:	080a7ed7 	.word	0x080a7ed7
 80a5b50:	080a7eda 	.word	0x080a7eda
 80a5b54:	080a7edc 	.word	0x080a7edc
 80a5b58:	080a7ee1 	.word	0x080a7ee1
 80a5b5c:	080a7ecb 	.word	0x080a7ecb

080a5b60 <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a5b60:	2300      	movs	r3, #0
 80a5b62:	6840      	ldr	r0, [r0, #4]
 80a5b64:	461a      	mov	r2, r3
 80a5b66:	f7fe bcb9 	b.w	80a44dc <network_connect>

080a5b6a <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a5b6a:	2200      	movs	r2, #0
 80a5b6c:	2102      	movs	r1, #2
 80a5b6e:	6840      	ldr	r0, [r0, #4]
 80a5b70:	f7fe bcc4 	b.w	80a44fc <network_disconnect>

080a5b74 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a5b74:	2200      	movs	r2, #0
 80a5b76:	6840      	ldr	r0, [r0, #4]
 80a5b78:	4611      	mov	r1, r2
 80a5b7a:	f7fe bcb7 	b.w	80a44ec <network_connecting>

080a5b7e <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a5b7e:	2200      	movs	r2, #0
 80a5b80:	6840      	ldr	r0, [r0, #4]
 80a5b82:	4611      	mov	r1, r2
 80a5b84:	f7fe bcc2 	b.w	80a450c <network_ready>

080a5b88 <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a5b88:	2300      	movs	r3, #0
 80a5b8a:	6840      	ldr	r0, [r0, #4]
 80a5b8c:	461a      	mov	r2, r3
 80a5b8e:	4619      	mov	r1, r3
 80a5b90:	f7fe bcc4 	b.w	80a451c <network_on>

080a5b94 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a5b94:	2300      	movs	r3, #0
 80a5b96:	6840      	ldr	r0, [r0, #4]
 80a5b98:	461a      	mov	r2, r3
 80a5b9a:	4619      	mov	r1, r3
 80a5b9c:	f7fe bcc6 	b.w	80a452c <network_off>

080a5ba0 <_ZN5spark12NetworkClass4isOnEv>:
}

bool NetworkClass::isOn() {
    return network_is_on(*this, nullptr);
 80a5ba0:	2100      	movs	r1, #0
 80a5ba2:	6840      	ldr	r0, [r0, #4]
 80a5ba4:	f7fe bcea 	b.w	80a457c <network_is_on>

080a5ba8 <_ZN5spark12NetworkClass5isOffEv>:
}

bool NetworkClass::isOff() {
    return network_is_off(*this, nullptr);
 80a5ba8:	2100      	movs	r1, #0
 80a5baa:	6840      	ldr	r0, [r0, #4]
 80a5bac:	f7fe bcee 	b.w	80a458c <network_is_off>

080a5bb0 <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a5bb0:	2200      	movs	r2, #0
 80a5bb2:	6840      	ldr	r0, [r0, #4]
 80a5bb4:	f081 0101 	eor.w	r1, r1, #1
 80a5bb8:	f7fe bcc0 	b.w	80a453c <network_listen>

080a5bbc <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a5bbc:	2200      	movs	r2, #0
 80a5bbe:	6840      	ldr	r0, [r0, #4]
 80a5bc0:	f7fe bccc 	b.w	80a455c <network_set_listen_timeout>

080a5bc4 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a5bc4:	2200      	movs	r2, #0
 80a5bc6:	6840      	ldr	r0, [r0, #4]
 80a5bc8:	4611      	mov	r1, r2
 80a5bca:	f7fe bccf 	b.w	80a456c <network_get_listen_timeout>

080a5bce <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a5bce:	2200      	movs	r2, #0
 80a5bd0:	6840      	ldr	r0, [r0, #4]
 80a5bd2:	4611      	mov	r1, r2
 80a5bd4:	f7fe bcba 	b.w	80a454c <network_listening>

080a5bd8 <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a5bd8:	b570      	push	{r4, r5, r6, lr}
 80a5bda:	4615      	mov	r5, r2
 80a5bdc:	b08e      	sub	sp, #56	; 0x38
 80a5bde:	4604      	mov	r4, r0
    IPAddress addr;
 80a5be0:	a808      	add	r0, sp, #32
 80a5be2:	f7fe fdc1 	bl	80a4768 <_ZN9IPAddressC1Ev>
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
    {
        HAL_IPAddress ip = {};
 80a5be6:	2211      	movs	r2, #17
 80a5be8:	2100      	movs	r1, #0
 80a5bea:	a803      	add	r0, sp, #12
 80a5bec:	f001 fe64 	bl	80a78b8 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a5bf0:	2600      	movs	r6, #0
 80a5bf2:	4628      	mov	r0, r5
 80a5bf4:	f001 fee9 	bl	80a79ca <strlen>
 80a5bf8:	4b0a      	ldr	r3, [pc, #40]	; (80a5c24 <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a5bfa:	9600      	str	r6, [sp, #0]
 80a5bfc:	b281      	uxth	r1, r0
 80a5bfe:	685b      	ldr	r3, [r3, #4]
 80a5c00:	4628      	mov	r0, r5
 80a5c02:	aa03      	add	r2, sp, #12
 80a5c04:	f7fe fc06 	bl	80a4414 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a5c08:	b130      	cbz	r0, 80a5c18 <_ZN5spark12NetworkClass7resolveEPKc+0x40>
 80a5c0a:	4631      	mov	r1, r6
 80a5c0c:	4620      	mov	r0, r4
 80a5c0e:	f7fe fdcb 	bl	80a47a8 <_ZN9IPAddressC1Em>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a5c12:	4620      	mov	r0, r4
 80a5c14:	b00e      	add	sp, #56	; 0x38
 80a5c16:	bd70      	pop	{r4, r5, r6, pc}
 80a5c18:	4620      	mov	r0, r4
 80a5c1a:	a903      	add	r1, sp, #12
 80a5c1c:	f7fe fdb2 	bl	80a4784 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    virtual ~IPAddress() {}
 80a5c20:	e7f7      	b.n	80a5c12 <_ZN5spark12NetworkClass7resolveEPKc+0x3a>
 80a5c22:	bf00      	nop
 80a5c24:	20001ae0 	.word	0x20001ae0

080a5c28 <_GLOBAL__sub_I__ZN5spark7NetworkE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a5c28:	4b02      	ldr	r3, [pc, #8]	; (80a5c34 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a5c2a:	4a03      	ldr	r2, [pc, #12]	; (80a5c38 <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a5c2c:	601a      	str	r2, [r3, #0]
 80a5c2e:	2200      	movs	r2, #0
 80a5c30:	605a      	str	r2, [r3, #4]

} // spark
 80a5c32:	4770      	bx	lr
 80a5c34:	20001660 	.word	0x20001660
 80a5c38:	080a7f68 	.word	0x080a7f68

080a5c3c <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a5c3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a5c3e:	4606      	mov	r6, r0
 80a5c40:	460d      	mov	r5, r1
  size_t n = 0;
 80a5c42:	2400      	movs	r4, #0
 80a5c44:	188f      	adds	r7, r1, r2
  while (size--) {
 80a5c46:	42bd      	cmp	r5, r7
 80a5c48:	d00c      	beq.n	80a5c64 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a5c4a:	6833      	ldr	r3, [r6, #0]
 80a5c4c:	4630      	mov	r0, r6
 80a5c4e:	689b      	ldr	r3, [r3, #8]
 80a5c50:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a5c54:	4798      	blx	r3
     if (chunk>=0)
 80a5c56:	1e03      	subs	r3, r0, #0
 80a5c58:	db01      	blt.n	80a5c5e <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a5c5a:	441c      	add	r4, r3
  while (size--) {
 80a5c5c:	e7f3      	b.n	80a5c46 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a5c5e:	2c00      	cmp	r4, #0
 80a5c60:	bf08      	it	eq
 80a5c62:	461c      	moveq	r4, r3
             n = chunk;
         break;
     }
  }
  return n;
}
 80a5c64:	4620      	mov	r0, r4
 80a5c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a5c68 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
 80a5c68:	b508      	push	{r3, lr}
  return write(str);
 80a5c6a:	f7fc fa46 	bl	80a20fa <_ZN5Print5writeEPKc>
}
 80a5c6e:	bd08      	pop	{r3, pc}

080a5c70 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
 80a5c70:	6803      	ldr	r3, [r0, #0]
 80a5c72:	689b      	ldr	r3, [r3, #8]
 80a5c74:	4718      	bx	r3

080a5c76 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a5c76:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a5c78:	210d      	movs	r1, #13
{
 80a5c7a:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a5c7c:	f7ff fff8 	bl	80a5c70 <_ZN5Print5printEc>
  n += print('\n');
 80a5c80:	210a      	movs	r1, #10
  size_t n = print('\r');
 80a5c82:	4604      	mov	r4, r0
  n += print('\n');
 80a5c84:	4628      	mov	r0, r5
 80a5c86:	f7ff fff3 	bl	80a5c70 <_ZN5Print5printEc>
  return n;
}
 80a5c8a:	4420      	add	r0, r4
 80a5c8c:	bd38      	pop	{r3, r4, r5, pc}

080a5c8e <_ZN5Print11printNumberEmh>:

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a5c8e:	2300      	movs	r3, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a5c90:	2a01      	cmp	r2, #1
 80a5c92:	bf98      	it	ls
 80a5c94:	220a      	movls	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a5c96:	b530      	push	{r4, r5, lr}
 80a5c98:	b08b      	sub	sp, #44	; 0x2c
 80a5c9a:	460c      	mov	r4, r1
  *str = '\0';
 80a5c9c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  if (base < 2) base = 10;
 80a5ca0:	a909      	add	r1, sp, #36	; 0x24

  do {
   decltype(n) m = n;
   n /= base;
 80a5ca2:	4625      	mov	r5, r4
 80a5ca4:	fbb4 f4f2 	udiv	r4, r4, r2
   char c = m - base * n;
 80a5ca8:	fb04 5312 	mls	r3, r4, r2, r5
 80a5cac:	b2db      	uxtb	r3, r3
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a5cae:	2b09      	cmp	r3, #9
 80a5cb0:	bf94      	ite	ls
 80a5cb2:	3330      	addls	r3, #48	; 0x30
 80a5cb4:	3337      	addhi	r3, #55	; 0x37
 80a5cb6:	b2db      	uxtb	r3, r3
  } while(n);
 80a5cb8:	42aa      	cmp	r2, r5
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a5cba:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while(n);
 80a5cbe:	d9f0      	bls.n	80a5ca2 <_ZN5Print11printNumberEmh+0x14>

  return write(str);
 80a5cc0:	f7fc fa1b 	bl	80a20fa <_ZN5Print5writeEPKc>
}
 80a5cc4:	b00b      	add	sp, #44	; 0x2c
 80a5cc6:	bd30      	pop	{r4, r5, pc}

080a5cc8 <_ZN5Print7vprintfEbPKcSt9__va_list>:

  return n;
}

size_t Print::vprintf(bool newline, const char* format, va_list args)
{
 80a5cc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a5ccc:	b086      	sub	sp, #24
 80a5cce:	af00      	add	r7, sp, #0
 80a5cd0:	4605      	mov	r5, r0
 80a5cd2:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list args2;
    va_copy(args2, args);
    size_t n = vsnprintf(test, bufsize, format, args);
 80a5cd4:	1d38      	adds	r0, r7, #4
 80a5cd6:	2114      	movs	r1, #20
{
 80a5cd8:	4614      	mov	r4, r2
    va_copy(args2, args);
 80a5cda:	603b      	str	r3, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, args);
 80a5cdc:	f7fe fc76 	bl	80a45cc <vsnprintf>

    if (n<bufsize)
 80a5ce0:	2813      	cmp	r0, #19
 80a5ce2:	d80e      	bhi.n	80a5d02 <_ZN5Print7vprintfEbPKcSt9__va_list+0x3a>
  return write(str);
 80a5ce4:	4628      	mov	r0, r5
 80a5ce6:	1d39      	adds	r1, r7, #4
 80a5ce8:	f7fc fa07 	bl	80a20fa <_ZN5Print5writeEPKc>
 80a5cec:	4604      	mov	r4, r0
    {
        char bigger[n+1];
        n = vsnprintf(bigger, n+1, format, args2);
        n = print(bigger);
    }
    if (newline)
 80a5cee:	b11e      	cbz	r6, 80a5cf8 <_ZN5Print7vprintfEbPKcSt9__va_list+0x30>
        n += println();
 80a5cf0:	4628      	mov	r0, r5
 80a5cf2:	f7ff ffc0 	bl	80a5c76 <_ZN5Print7printlnEv>
 80a5cf6:	4404      	add	r4, r0

    va_end(args2);
    return n;
}
 80a5cf8:	4620      	mov	r0, r4
 80a5cfa:	3718      	adds	r7, #24
 80a5cfc:	46bd      	mov	sp, r7
 80a5cfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        char bigger[n+1];
 80a5d02:	f100 0308 	add.w	r3, r0, #8
 80a5d06:	f023 0307 	bic.w	r3, r3, #7
        n = print(bigger);
 80a5d0a:	46e8      	mov	r8, sp
        char bigger[n+1];
 80a5d0c:	ebad 0d03 	sub.w	sp, sp, r3
        n = vsnprintf(bigger, n+1, format, args2);
 80a5d10:	4622      	mov	r2, r4
 80a5d12:	1c41      	adds	r1, r0, #1
 80a5d14:	683b      	ldr	r3, [r7, #0]
 80a5d16:	4668      	mov	r0, sp
 80a5d18:	f7fe fc58 	bl	80a45cc <vsnprintf>
  return write(str);
 80a5d1c:	4669      	mov	r1, sp
 80a5d1e:	4628      	mov	r0, r5
 80a5d20:	f7fc f9eb 	bl	80a20fa <_ZN5Print5writeEPKc>
 80a5d24:	4604      	mov	r4, r0
 80a5d26:	46c5      	mov	sp, r8
 80a5d28:	e7e1      	b.n	80a5cee <_ZN5Print7vprintfEbPKcSt9__va_list+0x26>
	...

080a5d2c <_GLOBAL__sub_I_RGB>:
    _Function_base() : _M_manager(nullptr) { }
 80a5d2c:	2200      	movs	r2, #0
 80a5d2e:	4b01      	ldr	r3, [pc, #4]	; (80a5d34 <_GLOBAL__sub_I_RGB+0x8>)
 80a5d30:	609a      	str	r2, [r3, #8]
{
    RGBClass* const d = static_cast<RGBClass*>(data);
    if (d->changeHandler_) {
        d->changeHandler_(r, g, b);
    }
}
 80a5d32:	4770      	bx	lr
 80a5d34:	20001668 	.word	0x20001668

080a5d38 <_ZN5Servo17writeMicrosecondsEt>:
}

void Servo::writeMicroseconds(uint16_t pulseWidth)
{

  if (!this->attached())
 80a5d38:	f9b0 2000 	ldrsh.w	r2, [r0]
{
 80a5d3c:	460b      	mov	r3, r1
  if (!this->attached())
 80a5d3e:	1c51      	adds	r1, r2, #1
 80a5d40:	d00a      	beq.n	80a5d58 <_ZN5Servo17writeMicrosecondsEt+0x20>
  {
    return;
  }

  pulseWidth = constrain(pulseWidth, this->minPW, this->maxPW);
 80a5d42:	8841      	ldrh	r1, [r0, #2]
 80a5d44:	8880      	ldrh	r0, [r0, #4]
typename std::common_type<T, U>::type
min (T a, U b) { return static_cast<typename std::common_type<T, U>::type>((a)<(b)?(a):(b)); }

template <typename T, typename U, typename V>
static inline
T constrain (T amt, U low, V high) { return ((amt)<(low)?(low):((amt)>(high)?(high):(amt))); }
 80a5d46:	4299      	cmp	r1, r3
 80a5d48:	d803      	bhi.n	80a5d52 <_ZN5Servo17writeMicrosecondsEt+0x1a>
 80a5d4a:	4298      	cmp	r0, r3
 80a5d4c:	4601      	mov	r1, r0
 80a5d4e:	bf28      	it	cs
 80a5d50:	4619      	movcs	r1, r3

  HAL_Servo_Write_Pulse_Width(this->pin, pulseWidth);
 80a5d52:	b290      	uxth	r0, r2
 80a5d54:	f7fe ba86 	b.w	80a4264 <HAL_Servo_Write_Pulse_Width>
}
 80a5d58:	4770      	bx	lr

080a5d5a <_ZN5Servo5writeEi>:
{
 80a5d5a:	b513      	push	{r0, r1, r4, lr}
 80a5d5c:	4604      	mov	r4, r0
 80a5d5e:	4608      	mov	r0, r1
 80a5d60:	f9b4 1006 	ldrsh.w	r1, [r4, #6]
 80a5d64:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
 80a5d68:	4288      	cmp	r0, r1
 80a5d6a:	db10      	blt.n	80a5d8e <_ZN5Servo5writeEi+0x34>
 80a5d6c:	4290      	cmp	r0, r2
 80a5d6e:	bfa8      	it	ge
 80a5d70:	4610      	movge	r0, r2
  this->writeMicroseconds(ANGLE_TO_US(degrees)+trim);
 80a5d72:	88a3      	ldrh	r3, [r4, #4]
 80a5d74:	9300      	str	r3, [sp, #0]
 80a5d76:	8863      	ldrh	r3, [r4, #2]
 80a5d78:	f7fe fc48 	bl	80a460c <_Z3mapiiiii>
 80a5d7c:	68e1      	ldr	r1, [r4, #12]
 80a5d7e:	4401      	add	r1, r0
 80a5d80:	4620      	mov	r0, r4
 80a5d82:	b289      	uxth	r1, r1
}
 80a5d84:	b002      	add	sp, #8
 80a5d86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  this->writeMicroseconds(ANGLE_TO_US(degrees)+trim);
 80a5d8a:	f7ff bfd5 	b.w	80a5d38 <_ZN5Servo17writeMicrosecondsEt>
 80a5d8e:	4608      	mov	r0, r1
 80a5d90:	e7ef      	b.n	80a5d72 <_ZN5Servo5writeEi+0x18>
	...

080a5d94 <_ZN5Servo11resetFieldsEv>:
{
  this->pin = NOT_ATTACHED;
  this->minAngle = SERVO_DEFAULT_MIN_ANGLE;
  this->maxAngle = SERVO_DEFAULT_MAX_ANGLE;
  this->minPW = SERVO_DEFAULT_MIN_PW;
  this->maxPW = SERVO_DEFAULT_MAX_PW;
 80a5d94:	f44f 6316 	mov.w	r3, #2400	; 0x960
 80a5d98:	4a03      	ldr	r2, [pc, #12]	; (80a5da8 <_ZN5Servo11resetFieldsEv+0x14>)
 80a5d9a:	e9c0 2300 	strd	r2, r3, [r0]
  this->maxAngle = SERVO_DEFAULT_MAX_ANGLE;
 80a5d9e:	23b4      	movs	r3, #180	; 0xb4
 80a5da0:	8103      	strh	r3, [r0, #8]
  this->trim = 0;
 80a5da2:	2300      	movs	r3, #0
 80a5da4:	60c3      	str	r3, [r0, #12]
}
 80a5da6:	4770      	bx	lr
 80a5da8:	0220ffff 	.word	0x0220ffff

080a5dac <_ZN5ServoC1Ev>:
Servo::Servo()
 80a5dac:	b508      	push	{r3, lr}
  this->resetFields();
 80a5dae:	f7ff fff1 	bl	80a5d94 <_ZN5Servo11resetFieldsEv>
}
 80a5db2:	bd08      	pop	{r3, pc}

080a5db4 <_ZN5Servo6detachEv>:
{
 80a5db4:	b510      	push	{r4, lr}
 80a5db6:	4604      	mov	r4, r0
  if (!this->attached())
 80a5db8:	f9b0 0000 	ldrsh.w	r0, [r0]
 80a5dbc:	1c43      	adds	r3, r0, #1
 80a5dbe:	d007      	beq.n	80a5dd0 <_ZN5Servo6detachEv+0x1c>
  HAL_Servo_Detach(this->pin);
 80a5dc0:	b280      	uxth	r0, r0
 80a5dc2:	f7fe fa47 	bl	80a4254 <HAL_Servo_Detach>
  this->resetFields();
 80a5dc6:	4620      	mov	r0, r4
 80a5dc8:	f7ff ffe4 	bl	80a5d94 <_ZN5Servo11resetFieldsEv>
  return true;
 80a5dcc:	2001      	movs	r0, #1
}
 80a5dce:	bd10      	pop	{r4, pc}
    return false;
 80a5dd0:	2000      	movs	r0, #0
 80a5dd2:	e7fc      	b.n	80a5dce <_ZN5Servo6detachEv+0x1a>

080a5dd4 <_ZN5Servo6attachEtttss>:
{
 80a5dd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a5dd8:	460d      	mov	r5, r1
 80a5dda:	4604      	mov	r4, r0
  if (HAL_Validate_Pin_Function(pin, PF_TIMER)!=PF_TIMER)
 80a5ddc:	2102      	movs	r1, #2
 80a5dde:	4628      	mov	r0, r5
{
 80a5de0:	4690      	mov	r8, r2
 80a5de2:	461f      	mov	r7, r3
  if (HAL_Validate_Pin_Function(pin, PF_TIMER)!=PF_TIMER)
 80a5de4:	f7fe f9c4 	bl	80a4170 <HAL_Validate_Pin_Function>
 80a5de8:	2802      	cmp	r0, #2
 80a5dea:	d003      	beq.n	80a5df4 <_ZN5Servo6attachEtttss+0x20>
    return false;
 80a5dec:	2600      	movs	r6, #0
}
 80a5dee:	4630      	mov	r0, r6
 80a5df0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!pinAvailable(pin))
 80a5df4:	4628      	mov	r0, r5
 80a5df6:	f000 fc49 	bl	80a668c <pinAvailable>
 80a5dfa:	4606      	mov	r6, r0
 80a5dfc:	2800      	cmp	r0, #0
 80a5dfe:	d0f5      	beq.n	80a5dec <_ZN5Servo6attachEtttss+0x18>
  if (this->attached())
 80a5e00:	f9b4 3000 	ldrsh.w	r3, [r4]
 80a5e04:	3301      	adds	r3, #1
 80a5e06:	d002      	beq.n	80a5e0e <_ZN5Servo6attachEtttss+0x3a>
    this->detach();
 80a5e08:	4620      	mov	r0, r4
 80a5e0a:	f7ff ffd3 	bl	80a5db4 <_ZN5Servo6detachEv>
  this->minAngle = minAngle;
 80a5e0e:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
  HAL_Servo_Attach(this->pin);
 80a5e12:	4628      	mov	r0, r5
  this->minAngle = minAngle;
 80a5e14:	80e3      	strh	r3, [r4, #6]
  this->maxAngle = maxAngle;
 80a5e16:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
  this->pin = pin;
 80a5e1a:	8025      	strh	r5, [r4, #0]
  this->minPW = minPW;
 80a5e1c:	f8a4 8002 	strh.w	r8, [r4, #2]
  this->maxPW = maxPW;
 80a5e20:	80a7      	strh	r7, [r4, #4]
  this->maxAngle = maxAngle;
 80a5e22:	8123      	strh	r3, [r4, #8]
  HAL_Servo_Attach(this->pin);
 80a5e24:	f7fe fa0e 	bl	80a4244 <HAL_Servo_Attach>
  return true;
 80a5e28:	e7e1      	b.n	80a5dee <_ZN5Servo6attachEtttss+0x1a>

080a5e2a <_ZN8SPIClass6unlockEv>:
    void unlock() { os_mutex_recursive_unlock(handle_); }
 80a5e2a:	6880      	ldr	r0, [r0, #8]
 80a5e2c:	f7fe b970 	b.w	80a4110 <os_mutex_recursive_unlock>

080a5e30 <_ZN8SPIClassC1E19hal_spi_interface_t>:
    }
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(hal_spi_interface_t spi)
 80a5e30:	b570      	push	{r4, r5, r6, lr}
    RecursiveMutex() : handle_(nullptr)
 80a5e32:	2600      	movs	r6, #0
 80a5e34:	4604      	mov	r4, r0
 80a5e36:	460d      	mov	r5, r1
 80a5e38:	f840 6f08 	str.w	r6, [r0, #8]!
        os_mutex_recursive_create(&handle_);
 80a5e3c:	f7fe f950 	bl	80a40e0 <os_mutex_recursive_create>
{
    _spi = spi;
    hal_spi_init(_spi);
 80a5e40:	4628      	mov	r0, r5
    _spi = spi;
 80a5e42:	7025      	strb	r5, [r4, #0]
    hal_spi_init(_spi);
 80a5e44:	f7fe fa26 	bl	80a4294 <hal_spi_init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
}
 80a5e48:	4620      	mov	r0, r4
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
 80a5e4a:	6066      	str	r6, [r4, #4]
}
 80a5e4c:	bd70      	pop	{r4, r5, r6, pc}

080a5e4e <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
 80a5e4e:	b510      	push	{r4, lr}
 80a5e50:	4604      	mov	r4, r0
    void lock() { os_mutex_recursive_lock(handle_); }
 80a5e52:	6880      	ldr	r0, [r0, #8]
 80a5e54:	f7fe f954 	bl	80a4100 <os_mutex_recursive_lock>
    // TODO: Fetch default pin from HAL
    if (!lock())
    {
        hal_spi_begin(_spi, SPI_DEFAULT_SS);
 80a5e58:	7820      	ldrb	r0, [r4, #0]
 80a5e5a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80a5e5e:	f7fe fa09 	bl	80a4274 <hal_spi_begin>
        unlock();
 80a5e62:	4620      	mov	r0, r4
 80a5e64:	f7ff ffe1 	bl	80a5e2a <_ZN8SPIClass6unlockEv>
    }
}
 80a5e68:	bd10      	pop	{r4, pc}

080a5e6a <_ZN8SPIClass14endTransactionEv>:

    return 0;
}

void SPIClass::endTransaction()
{
 80a5e6a:	b508      	push	{r3, lr}
    // Release peripheral
    unlock();
 80a5e6c:	f7ff ffdd 	bl	80a5e2a <_ZN8SPIClass6unlockEv>
}
 80a5e70:	bd08      	pop	{r3, pc}
	...

080a5e74 <_ZN8SPIClass19computeClockDividerEjjRhRj>:
    }
}

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
 80a5e74:	b530      	push	{r4, r5, lr}
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
 80a5e76:	2400      	movs	r4, #0
 80a5e78:	0840      	lsrs	r0, r0, #1
 80a5e7a:	6018      	str	r0, [r3, #0]
    while (clock > targetSpeed && scale < 7)
 80a5e7c:	6818      	ldr	r0, [r3, #0]
 80a5e7e:	b2e5      	uxtb	r5, r4
 80a5e80:	4288      	cmp	r0, r1
 80a5e82:	d906      	bls.n	80a5e92 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
 80a5e84:	3401      	adds	r4, #1
 80a5e86:	2c08      	cmp	r4, #8
 80a5e88:	d002      	beq.n	80a5e90 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
    {
        clock >>= 1;
 80a5e8a:	0840      	lsrs	r0, r0, #1
 80a5e8c:	6018      	str	r0, [r3, #0]
    while (clock > targetSpeed && scale < 7)
 80a5e8e:	e7f5      	b.n	80a5e7c <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
 80a5e90:	2507      	movs	r5, #7
        scale++;
    }
    divider = clock_divisors[scale];
 80a5e92:	4b02      	ldr	r3, [pc, #8]	; (80a5e9c <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
 80a5e94:	5d5b      	ldrb	r3, [r3, r5]
 80a5e96:	7013      	strb	r3, [r2, #0]
}
 80a5e98:	bd30      	pop	{r4, r5, pc}
 80a5e9a:	bf00      	nop
 80a5e9c:	080a7f9c 	.word	0x080a7f9c

080a5ea0 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>:
{
 80a5ea0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a5ea4:	4606      	mov	r6, r0
 80a5ea6:	b08f      	sub	sp, #60	; 0x3c
 80a5ea8:	6880      	ldr	r0, [r0, #8]
 80a5eaa:	460c      	mov	r4, r1
 80a5eac:	f7fe f928 	bl	80a4100 <os_mutex_recursive_lock>
    memset(info, 0, sizeof(hal_spi_info_t));
 80a5eb0:	2214      	movs	r2, #20
 80a5eb2:	2100      	movs	r1, #0
 80a5eb4:	a809      	add	r0, sp, #36	; 0x24
    querySpiInfo(_spi, &spi_info);
 80a5eb6:	7835      	ldrb	r5, [r6, #0]
    memset(info, 0, sizeof(hal_spi_info_t));
 80a5eb8:	f001 fcfe 	bl	80a78b8 <memset>
    info->version = HAL_SPI_INFO_VERSION_1;
 80a5ebc:	230b      	movs	r3, #11
    hal_spi_info(spi, info, nullptr);
 80a5ebe:	2200      	movs	r2, #0
 80a5ec0:	4628      	mov	r0, r5
 80a5ec2:	a909      	add	r1, sp, #36	; 0x24
    info->version = HAL_SPI_INFO_VERSION_1;
 80a5ec4:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    hal_spi_info(spi, info, nullptr);
 80a5ec8:	f7fe f9f4 	bl	80a42b4 <hal_spi_info>
    if (!info || !info->enabled || info->default_settings)
 80a5ecc:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
 80a5ed0:	b113      	cbz	r3, 80a5ed8 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x38>
 80a5ed2:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
 80a5ed6:	b155      	cbz	r5, 80a5eee <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4e>
      dataMode_{dataMode}
  {
  }

  SPISettings()
  {
 80a5ed8:	2700      	movs	r7, #0
 80a5eda:	2501      	movs	r5, #1
 80a5edc:	46b9      	mov	r9, r7
 80a5ede:	46b8      	mov	r8, r7
  virtual ~SPISettings() {
  }

  bool operator==(const SPISettings& other) const
  {
    if (default_ && other.default_)
 80a5ee0:	7923      	ldrb	r3, [r4, #4]
 80a5ee2:	b15d      	cbz	r5, 80a5efc <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x5c>
 80a5ee4:	b1c3      	cbz	r3, 80a5f18 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x78>
}
 80a5ee6:	2000      	movs	r0, #0
 80a5ee8:	b00f      	add	sp, #60	; 0x3c
 80a5eea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
 80a5eee:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 80a5ef2:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
 80a5ef6:	f89d 7035 	ldrb.w	r7, [sp, #53]	; 0x35
  }
 80a5efa:	e7f1      	b.n	80a5ee0 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x40>
      return true;

    if (default_ == other.default_ &&
 80a5efc:	2b00      	cmp	r3, #0
 80a5efe:	d135      	bne.n	80a5f6c <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xcc>
 80a5f00:	68a3      	ldr	r3, [r4, #8]
 80a5f02:	4543      	cmp	r3, r8
 80a5f04:	d108      	bne.n	80a5f18 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x78>
        clock_ == other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a5f06:	f88d 9020 	strb.w	r9, [sp, #32]
 80a5f0a:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 80a5f0e:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a5f12:	89a3      	ldrh	r3, [r4, #12]
 80a5f14:	429a      	cmp	r2, r3
 80a5f16:	d0e6      	beq.n	80a5ee6 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x46>
            uint8_t divisor = 0;
 80a5f18:	2300      	movs	r3, #0
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
 80a5f1a:	68a1      	ldr	r1, [r4, #8]
            uint8_t divisor = 0;
 80a5f1c:	f88d 300f 	strb.w	r3, [sp, #15]
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
 80a5f20:	980a      	ldr	r0, [sp, #40]	; 0x28
 80a5f22:	ab04      	add	r3, sp, #16
 80a5f24:	f10d 020f 	add.w	r2, sp, #15
 80a5f28:	f7ff ffa4 	bl	80a5e74 <_ZN8SPIClass19computeClockDividerEjjRhRj>
    return false;
  }

  bool operator<=(const SPISettings& other) const
  {
    if (default_ && other.default_)
 80a5f2c:	7921      	ldrb	r1, [r4, #4]
 80a5f2e:	b985      	cbnz	r5, 80a5f52 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb2>
      return true;

    if (default_ == other.default_ &&
 80a5f30:	b989      	cbnz	r1, 80a5f56 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
 80a5f32:	68a3      	ldr	r3, [r4, #8]
 80a5f34:	4543      	cmp	r3, r8
 80a5f36:	d30e      	bcc.n	80a5f56 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
        clock_ <= other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a5f38:	f88d 9020 	strb.w	r9, [sp, #32]
 80a5f3c:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 80a5f40:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a5f44:	89a3      	ldrh	r3, [r4, #12]
 80a5f46:	429a      	cmp	r2, r3
 80a5f48:	d105      	bne.n	80a5f56 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
 80a5f4a:	9b04      	ldr	r3, [sp, #16]
 80a5f4c:	4543      	cmp	r3, r8
 80a5f4e:	d102      	bne.n	80a5f56 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
 80a5f50:	e7c9      	b.n	80a5ee6 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x46>
    if (default_ && other.default_)
 80a5f52:	2900      	cmp	r1, #0
 80a5f54:	d1f9      	bne.n	80a5f4a <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xaa>
                hal_spi_set_settings(_spi, settings.default_, divisor, settings.bitOrder_,
 80a5f56:	2300      	movs	r3, #0
 80a5f58:	9301      	str	r3, [sp, #4]
 80a5f5a:	7b63      	ldrb	r3, [r4, #13]
 80a5f5c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80a5f60:	9300      	str	r3, [sp, #0]
 80a5f62:	7b23      	ldrb	r3, [r4, #12]
            hal_spi_set_settings(_spi, settings.default_, 0, 0, 0, nullptr);
 80a5f64:	7830      	ldrb	r0, [r6, #0]
 80a5f66:	f7fe f9bd 	bl	80a42e4 <hal_spi_set_settings>
    return 0;
 80a5f6a:	e7bc      	b.n	80a5ee6 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x46>
            hal_spi_set_settings(_spi, settings.default_, 0, 0, 0, nullptr);
 80a5f6c:	462b      	mov	r3, r5
 80a5f6e:	462a      	mov	r2, r5
 80a5f70:	2101      	movs	r1, #1
 80a5f72:	e9cd 5500 	strd	r5, r5, [sp]
 80a5f76:	e7f5      	b.n	80a5f64 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xc4>

080a5f78 <_ZN8SPIClass8transferEh>:

    return clock;
}

byte SPIClass::transfer(byte _data)
{
 80a5f78:	b508      	push	{r3, lr}
    return static_cast<byte>(hal_spi_transfer(_spi, _data));
 80a5f7a:	7800      	ldrb	r0, [r0, #0]
 80a5f7c:	f7fe f982 	bl	80a4284 <hal_spi_transfer>
}
 80a5f80:	b2c0      	uxtb	r0, r0
 80a5f82:	bd08      	pop	{r3, pc}

080a5f84 <_ZN8SPIClass8transferEPvS0_jPFvvE>:

void SPIClass::transfer(void* tx_buffer, void* rx_buffer, size_t length,
                        wiring_spi_dma_transfercomplete_callback_t user_callback)
{
 80a5f84:	b530      	push	{r4, r5, lr}
 80a5f86:	b087      	sub	sp, #28
 80a5f88:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80a5f8a:	4604      	mov	r4, r0
    hal_spi_transfer_dma(_spi, tx_buffer, rx_buffer, length, user_callback);
 80a5f8c:	9500      	str	r5, [sp, #0]
 80a5f8e:	7800      	ldrb	r0, [r0, #0]
 80a5f90:	f7fe f998 	bl	80a42c4 <hal_spi_transfer_dma>
    if (user_callback == NULL)
 80a5f94:	b93d      	cbnz	r5, 80a5fa6 <_ZN8SPIClass8transferEPvS0_jPFvvE+0x22>
    {
        hal_spi_transfer_status_t st;
        do
        {
            hal_spi_transfer_dma_status(_spi, &st);
 80a5f96:	7820      	ldrb	r0, [r4, #0]
 80a5f98:	a902      	add	r1, sp, #8
 80a5f9a:	f7fe f99b 	bl	80a42d4 <hal_spi_transfer_dma_status>
        } while (st.transfer_ongoing);
 80a5f9e:	f89d 3014 	ldrb.w	r3, [sp, #20]
 80a5fa2:	07db      	lsls	r3, r3, #31
 80a5fa4:	d4f7      	bmi.n	80a5f96 <_ZN8SPIClass8transferEPvS0_jPFvvE+0x12>
    }
}
 80a5fa6:	b007      	add	sp, #28
 80a5fa8:	bd30      	pop	{r4, r5, pc}

080a5faa <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a5faa:	b510      	push	{r4, lr}
 80a5fac:	4604      	mov	r4, r0
{
	free(buffer);
 80a5fae:	6800      	ldr	r0, [r0, #0]
 80a5fb0:	f7fe fafc 	bl	80a45ac <free>
}
 80a5fb4:	4620      	mov	r0, r4
 80a5fb6:	bd10      	pop	{r4, pc}

080a5fb8 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a5fb8:	b510      	push	{r4, lr}
 80a5fba:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a5fbc:	6800      	ldr	r0, [r0, #0]
 80a5fbe:	b108      	cbz	r0, 80a5fc4 <_ZN6String10invalidateEv+0xc>
 80a5fc0:	f7fe faf4 	bl	80a45ac <free>
	buffer = NULL;
 80a5fc4:	2300      	movs	r3, #0
	capacity = len = 0;
 80a5fc6:	e9c4 3301 	strd	r3, r3, [r4, #4]
	buffer = NULL;
 80a5fca:	6023      	str	r3, [r4, #0]
}
 80a5fcc:	bd10      	pop	{r4, pc}

080a5fce <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a5fce:	b538      	push	{r3, r4, r5, lr}
 80a5fd0:	4604      	mov	r4, r0
 80a5fd2:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a5fd4:	6800      	ldr	r0, [r0, #0]
 80a5fd6:	3101      	adds	r1, #1
 80a5fd8:	f7fe faf0 	bl	80a45bc <realloc>
	if (newbuffer) {
 80a5fdc:	b110      	cbz	r0, 80a5fe4 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a5fde:	e9c4 0500 	strd	r0, r5, [r4]
		return 1;
 80a5fe2:	2001      	movs	r0, #1
	}
	return 0;
}
 80a5fe4:	bd38      	pop	{r3, r4, r5, pc}

080a5fe6 <_ZN6String7reserveEj>:
{
 80a5fe6:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a5fe8:	6803      	ldr	r3, [r0, #0]
{
 80a5fea:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a5fec:	b123      	cbz	r3, 80a5ff8 <_ZN6String7reserveEj+0x12>
 80a5fee:	6843      	ldr	r3, [r0, #4]
 80a5ff0:	428b      	cmp	r3, r1
 80a5ff2:	d301      	bcc.n	80a5ff8 <_ZN6String7reserveEj+0x12>
 80a5ff4:	2001      	movs	r0, #1
}
 80a5ff6:	bd10      	pop	{r4, pc}
	if (changeBuffer(size)) {
 80a5ff8:	4620      	mov	r0, r4
 80a5ffa:	f7ff ffe8 	bl	80a5fce <_ZN6String12changeBufferEj>
 80a5ffe:	2800      	cmp	r0, #0
 80a6000:	d0f9      	beq.n	80a5ff6 <_ZN6String7reserveEj+0x10>
		if (len == 0) buffer[0] = 0;
 80a6002:	68a3      	ldr	r3, [r4, #8]
 80a6004:	2b00      	cmp	r3, #0
 80a6006:	d1f5      	bne.n	80a5ff4 <_ZN6String7reserveEj+0xe>
 80a6008:	6822      	ldr	r2, [r4, #0]
 80a600a:	7013      	strb	r3, [r2, #0]
 80a600c:	e7f2      	b.n	80a5ff4 <_ZN6String7reserveEj+0xe>

080a600e <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a600e:	b570      	push	{r4, r5, r6, lr}
 80a6010:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a6012:	4611      	mov	r1, r2
{
 80a6014:	4604      	mov	r4, r0
 80a6016:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a6018:	f7ff ffe5 	bl	80a5fe6 <_ZN6String7reserveEj>
 80a601c:	b920      	cbnz	r0, 80a6028 <_ZN6String4copyEPKcj+0x1a>
		invalidate();
 80a601e:	4620      	mov	r0, r4
 80a6020:	f7ff ffca 	bl	80a5fb8 <_ZN6String10invalidateEv>
	}
	len = length;
	memcpy(buffer, cstr, length);
	buffer[len] = 0;
	return *this;
}
 80a6024:	4620      	mov	r0, r4
 80a6026:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(buffer, cstr, length);
 80a6028:	462a      	mov	r2, r5
 80a602a:	4631      	mov	r1, r6
 80a602c:	6820      	ldr	r0, [r4, #0]
	len = length;
 80a602e:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a6030:	f001 fc1a 	bl	80a7868 <memcpy>
	buffer[len] = 0;
 80a6034:	2100      	movs	r1, #0
 80a6036:	6822      	ldr	r2, [r4, #0]
 80a6038:	68a3      	ldr	r3, [r4, #8]
 80a603a:	54d1      	strb	r1, [r2, r3]
	return *this;
 80a603c:	e7f2      	b.n	80a6024 <_ZN6String4copyEPKcj+0x16>

080a603e <_ZN6StringC1EPKc>:
String::String(const char *cstr)
 80a603e:	b538      	push	{r3, r4, r5, lr}
	buffer = NULL;
 80a6040:	2300      	movs	r3, #0
String::String(const char *cstr)
 80a6042:	4604      	mov	r4, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a6044:	460d      	mov	r5, r1
	capacity = 0;
 80a6046:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a604a:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a604c:	7303      	strb	r3, [r0, #12]
	if (cstr) copy(cstr, strlen(cstr));
 80a604e:	b139      	cbz	r1, 80a6060 <_ZN6StringC1EPKc+0x22>
 80a6050:	4608      	mov	r0, r1
 80a6052:	f001 fcba 	bl	80a79ca <strlen>
 80a6056:	4629      	mov	r1, r5
 80a6058:	4602      	mov	r2, r0
 80a605a:	4620      	mov	r0, r4
 80a605c:	f7ff ffd7 	bl	80a600e <_ZN6String4copyEPKcj>
}
 80a6060:	4620      	mov	r0, r4
 80a6062:	bd38      	pop	{r3, r4, r5, pc}

080a6064 <_ZN6String4moveERS_>:
    return copy(reinterpret_cast<const char*>(pstr), length);
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
void String::move(String &rhs)
{
 80a6064:	b538      	push	{r3, r4, r5, lr}
 80a6066:	4605      	mov	r5, r0
	if (buffer) {
 80a6068:	6800      	ldr	r0, [r0, #0]
{
 80a606a:	460c      	mov	r4, r1
	if (buffer) {
 80a606c:	b168      	cbz	r0, 80a608a <_ZN6String4moveERS_+0x26>
		if (capacity >= rhs.len) {
 80a606e:	686a      	ldr	r2, [r5, #4]
 80a6070:	688b      	ldr	r3, [r1, #8]
 80a6072:	429a      	cmp	r2, r3
 80a6074:	d307      	bcc.n	80a6086 <_ZN6String4moveERS_+0x22>
			strcpy(buffer, rhs.buffer);
 80a6076:	6809      	ldr	r1, [r1, #0]
 80a6078:	f001 fc9f 	bl	80a79ba <strcpy>
			len = rhs.len;
 80a607c:	68a3      	ldr	r3, [r4, #8]
 80a607e:	60ab      	str	r3, [r5, #8]
			rhs.len = 0;
 80a6080:	2300      	movs	r3, #0
	buffer = rhs.buffer;
	capacity = rhs.capacity;
	len = rhs.len;
	rhs.buffer = NULL;
	rhs.capacity = 0;
	rhs.len = 0;
 80a6082:	60a3      	str	r3, [r4, #8]
}
 80a6084:	bd38      	pop	{r3, r4, r5, pc}
			free(buffer);
 80a6086:	f7fe fa91 	bl	80a45ac <free>
	buffer = rhs.buffer;
 80a608a:	6823      	ldr	r3, [r4, #0]
 80a608c:	602b      	str	r3, [r5, #0]
	capacity = rhs.capacity;
 80a608e:	6863      	ldr	r3, [r4, #4]
 80a6090:	606b      	str	r3, [r5, #4]
	len = rhs.len;
 80a6092:	68a3      	ldr	r3, [r4, #8]
 80a6094:	60ab      	str	r3, [r5, #8]
	rhs.buffer = NULL;
 80a6096:	2300      	movs	r3, #0
	rhs.capacity = 0;
 80a6098:	e9c4 3300 	strd	r3, r3, [r4]
 80a609c:	e7f1      	b.n	80a6082 <_ZN6String4moveERS_+0x1e>

080a609e <_ZN6StringC1EOS_>:
	buffer = NULL;
 80a609e:	2300      	movs	r3, #0
String::String(String &&rval)
 80a60a0:	b510      	push	{r4, lr}
 80a60a2:	4604      	mov	r4, r0
	capacity = 0;
 80a60a4:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a60a8:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a60aa:	7303      	strb	r3, [r0, #12]
	move(rval);
 80a60ac:	f7ff ffda 	bl	80a6064 <_ZN6String4moveERS_>
}
 80a60b0:	4620      	mov	r0, r4
 80a60b2:	bd10      	pop	{r4, pc}

080a60b4 <_ZN6StringaSERKS_>:
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a60b4:	4288      	cmp	r0, r1
{
 80a60b6:	b510      	push	{r4, lr}
 80a60b8:	460b      	mov	r3, r1
 80a60ba:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a60bc:	d004      	beq.n	80a60c8 <_ZN6StringaSERKS_+0x14>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a60be:	6809      	ldr	r1, [r1, #0]
 80a60c0:	b121      	cbz	r1, 80a60cc <_ZN6StringaSERKS_+0x18>
 80a60c2:	689a      	ldr	r2, [r3, #8]
 80a60c4:	f7ff ffa3 	bl	80a600e <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
 80a60c8:	4620      	mov	r0, r4
 80a60ca:	bd10      	pop	{r4, pc}
	else invalidate();
 80a60cc:	f7ff ff74 	bl	80a5fb8 <_ZN6String10invalidateEv>
 80a60d0:	e7fa      	b.n	80a60c8 <_ZN6StringaSERKS_+0x14>

080a60d2 <_ZN6StringC1ERKS_>:
	buffer = NULL;
 80a60d2:	2300      	movs	r3, #0
String::String(const String &value)
 80a60d4:	b510      	push	{r4, lr}
 80a60d6:	4604      	mov	r4, r0
	capacity = 0;
 80a60d8:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a60dc:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a60de:	7303      	strb	r3, [r0, #12]
	*this = value;
 80a60e0:	f7ff ffe8 	bl	80a60b4 <_ZN6StringaSERKS_>
}
 80a60e4:	4620      	mov	r0, r4
 80a60e6:	bd10      	pop	{r4, pc}

080a60e8 <_GLOBAL__sub_I_System>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a60e8:	2202      	movs	r2, #2

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
 80a60ea:	2000      	movs	r0, #0
 80a60ec:	4b04      	ldr	r3, [pc, #16]	; (80a6100 <_GLOBAL__sub_I_System+0x18>)
 80a60ee:	601a      	str	r2, [r3, #0]
 80a60f0:	4b04      	ldr	r3, [pc, #16]	; (80a6104 <_GLOBAL__sub_I_System+0x1c>)
    SleepResult() {}
 80a60f2:	4a05      	ldr	r2, [pc, #20]	; (80a6108 <_GLOBAL__sub_I_System+0x20>)
              error_(SYSTEM_ERROR_NONE) {
 80a60f4:	6018      	str	r0, [r3, #0]
 80a60f6:	8098      	strh	r0, [r3, #4]
    SleepResult() {}
 80a60f8:	7198      	strb	r0, [r3, #6]
 80a60fa:	609a      	str	r2, [r3, #8]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a60fc:	f7fe b9ba 	b.w	80a4474 <set_system_mode>
 80a6100:	20001684 	.word	0x20001684
 80a6104:	20001678 	.word	0x20001678
 80a6108:	ffff0000 	.word	0xffff0000

080a610c <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a610c:	4b02      	ldr	r3, [pc, #8]	; (80a6118 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a610e:	681a      	ldr	r2, [r3, #0]
 80a6110:	4b02      	ldr	r3, [pc, #8]	; (80a611c <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a6112:	601a      	str	r2, [r3, #0]
{
  return isValid();
}


TimeClass Time;
 80a6114:	4770      	bx	lr
 80a6116:	bf00      	nop
 80a6118:	2000001c 	.word	0x2000001c
 80a611c:	20001688 	.word	0x20001688

080a6120 <_ZN11USARTSerialD1Ev>:
private:
  hal_usart_interface_t _serial;
  bool _blocking;
public:
  USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer);
  virtual ~USARTSerial() {};
 80a6120:	4770      	bx	lr

080a6122 <_ZN11USARTSerial14blockOnOverrunEb>:
    hal_usart_half_duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a6122:	7441      	strb	r1, [r0, #17]
}
 80a6124:	4770      	bx	lr

080a6126 <__tcf_0>:
#endif

USARTSerial& __fetch_global_Serial1()
{
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a6126:	4770      	bx	lr

080a6128 <_ZN11USARTSerial17availableForWriteEv>:
{
 80a6128:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available_data_for_write(_serial));
 80a612a:	7c00      	ldrb	r0, [r0, #16]
 80a612c:	f7fe f922 	bl	80a4374 <hal_usart_available_data_for_write>
}
 80a6130:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a6134:	bd08      	pop	{r3, pc}

080a6136 <_ZN11USARTSerial9availableEv>:
{
 80a6136:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available(_serial));
 80a6138:	7c00      	ldrb	r0, [r0, #16]
 80a613a:	f7fe f8f3 	bl	80a4324 <hal_usart_available>
}
 80a613e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a6142:	bd08      	pop	{r3, pc}

080a6144 <_ZN11USARTSerial4peekEv>:
{
 80a6144:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_peek(_serial));
 80a6146:	7c00      	ldrb	r0, [r0, #16]
 80a6148:	f7fe f8fc 	bl	80a4344 <hal_usart_peek>
}
 80a614c:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a6150:	bd08      	pop	{r3, pc}

080a6152 <_ZN11USARTSerial4readEv>:
{
 80a6152:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_read(_serial));
 80a6154:	7c00      	ldrb	r0, [r0, #16]
 80a6156:	f7fe f8ed 	bl	80a4334 <hal_usart_read>
}
 80a615a:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a615e:	bd08      	pop	{r3, pc}

080a6160 <_ZN11USARTSerial5flushEv>:
  hal_usart_flush(_serial);
 80a6160:	7c00      	ldrb	r0, [r0, #16]
 80a6162:	f7fe b8f7 	b.w	80a4354 <hal_usart_flush>

080a6166 <_ZN11USARTSerial5writeEh>:
{
 80a6166:	b570      	push	{r4, r5, r6, lr}
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a6168:	7c46      	ldrb	r6, [r0, #17]
{
 80a616a:	4604      	mov	r4, r0
 80a616c:	460d      	mov	r5, r1
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a616e:	b12e      	cbz	r6, 80a617c <_ZN11USARTSerial5writeEh+0x16>
	  return hal_usart_write(_serial, c);
 80a6170:	4629      	mov	r1, r5
 80a6172:	7c20      	ldrb	r0, [r4, #16]
}
 80a6174:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  return hal_usart_write(_serial, c);
 80a6178:	f7fe b8cc 	b.w	80a4314 <hal_usart_write>
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a617c:	7c00      	ldrb	r0, [r0, #16]
 80a617e:	f7fe f8f9 	bl	80a4374 <hal_usart_available_data_for_write>
 80a6182:	2800      	cmp	r0, #0
 80a6184:	dcf4      	bgt.n	80a6170 <_ZN11USARTSerial5writeEh+0xa>
}
 80a6186:	4630      	mov	r0, r6
 80a6188:	bd70      	pop	{r4, r5, r6, pc}

080a618a <_ZN11USARTSerialD0Ev>:
 80a618a:	b510      	push	{r4, lr}
 80a618c:	4604      	mov	r4, r0
 80a618e:	2114      	movs	r1, #20
 80a6190:	f000 fb5e 	bl	80a6850 <_ZdlPvj>
 80a6194:	4620      	mov	r0, r4
 80a6196:	bd10      	pop	{r4, pc}

080a6198 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>:
 80a6198:	f04f 0c00 	mov.w	ip, #0
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a619c:	b510      	push	{r4, lr}
 80a619e:	4604      	mov	r4, r0
 80a61a0:	4608      	mov	r0, r1
 80a61a2:	4611      	mov	r1, r2
 80a61a4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a61a8:	e9c4 c201 	strd	ip, r2, [r4, #4]
 80a61ac:	4a04      	ldr	r2, [pc, #16]	; (80a61c0 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_+0x28>)
  _serial = serial;
 80a61ae:	7420      	strb	r0, [r4, #16]
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a61b0:	6022      	str	r2, [r4, #0]
  _blocking = true;
 80a61b2:	2201      	movs	r2, #1
 80a61b4:	7462      	strb	r2, [r4, #17]
  hal_usart_init(serial, rx_buffer, tx_buffer);
 80a61b6:	461a      	mov	r2, r3
 80a61b8:	f7fe f89c 	bl	80a42f4 <hal_usart_init>
}
 80a61bc:	4620      	mov	r0, r4
 80a61be:	bd10      	pop	{r4, pc}
 80a61c0:	080a7fc8 	.word	0x080a7fc8

080a61c4 <_ZN11USARTSerial5beginEmm>:
  hal_usart_begin_config(_serial, baud, config, nullptr);
 80a61c4:	2300      	movs	r3, #0
 80a61c6:	7c00      	ldrb	r0, [r0, #16]
 80a61c8:	f7fe b8dc 	b.w	80a4384 <hal_usart_begin_config>

080a61cc <_ZN11USARTSerial5beginEm>:
  begin(baud, SERIAL_8N1);
 80a61cc:	2200      	movs	r2, #0
 80a61ce:	f7ff bff9 	b.w	80a61c4 <_ZN11USARTSerial5beginEmm>

080a61d2 <_ZN11USARTSerial3endEv>:
  hal_usart_end(_serial);
 80a61d2:	7c00      	ldrb	r0, [r0, #16]
 80a61d4:	f7fe b896 	b.w	80a4304 <hal_usart_end>

080a61d8 <_Z22__fetch_global_Serial1v>:
{
 80a61d8:	b538      	push	{r3, r4, r5, lr}
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a61da:	4d0c      	ldr	r5, [pc, #48]	; (80a620c <_Z22__fetch_global_Serial1v+0x34>)
 80a61dc:	7829      	ldrb	r1, [r5, #0]
 80a61de:	f3bf 8f5b 	dmb	ish
 80a61e2:	f011 0401 	ands.w	r4, r1, #1
 80a61e6:	d10f      	bne.n	80a6208 <_Z22__fetch_global_Serial1v+0x30>
 80a61e8:	4628      	mov	r0, r5
 80a61ea:	f7f9 ff65 	bl	80a00b8 <__cxa_guard_acquire>
 80a61ee:	b158      	cbz	r0, 80a6208 <_Z22__fetch_global_Serial1v+0x30>
 80a61f0:	4621      	mov	r1, r4
 80a61f2:	4b07      	ldr	r3, [pc, #28]	; (80a6210 <_Z22__fetch_global_Serial1v+0x38>)
 80a61f4:	4a07      	ldr	r2, [pc, #28]	; (80a6214 <_Z22__fetch_global_Serial1v+0x3c>)
 80a61f6:	4808      	ldr	r0, [pc, #32]	; (80a6218 <_Z22__fetch_global_Serial1v+0x40>)
 80a61f8:	f7ff ffce 	bl	80a6198 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>
 80a61fc:	4628      	mov	r0, r5
 80a61fe:	f7f9 ff60 	bl	80a00c2 <__cxa_guard_release>
 80a6202:	4806      	ldr	r0, [pc, #24]	; (80a621c <_Z22__fetch_global_Serial1v+0x44>)
 80a6204:	f001 fb1c 	bl	80a7840 <atexit>
    serial1_tx_buffer = new hal_usart_ring_buffer_t();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a6208:	4803      	ldr	r0, [pc, #12]	; (80a6218 <_Z22__fetch_global_Serial1v+0x40>)
 80a620a:	bd38      	pop	{r3, r4, r5, pc}
 80a620c:	2000168c 	.word	0x2000168c
 80a6210:	20001714 	.word	0x20001714
 80a6214:	20001690 	.word	0x20001690
 80a6218:	20001798 	.word	0x20001798
 80a621c:	080a6127 	.word	0x080a6127

080a6220 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a6220:	7441      	strb	r1, [r0, #17]
}
 80a6222:	4770      	bx	lr

080a6224 <__tcf_0>:
}

USBSerial& _fetch_usbserial()
{
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a6224:	4770      	bx	lr

080a6226 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a6226:	4770      	bx	lr

080a6228 <_ZN9USBSerial4readEv>:
{
 80a6228:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a622a:	2100      	movs	r1, #0
 80a622c:	7c00      	ldrb	r0, [r0, #16]
 80a622e:	f7fe f8d9 	bl	80a43e4 <HAL_USB_USART_Receive_Data>
}
 80a6232:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a6236:	bd08      	pop	{r3, pc}

080a6238 <_ZN9USBSerial4peekEv>:
{
 80a6238:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a623a:	2101      	movs	r1, #1
 80a623c:	7c00      	ldrb	r0, [r0, #16]
 80a623e:	f7fe f8d1 	bl	80a43e4 <HAL_USB_USART_Receive_Data>
}
 80a6242:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a6246:	bd08      	pop	{r3, pc}

080a6248 <_ZN9USBSerial17availableForWriteEv>:
{
 80a6248:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a624a:	7c00      	ldrb	r0, [r0, #16]
 80a624c:	f7fe f8c2 	bl	80a43d4 <HAL_USB_USART_Available_Data_For_Write>
}
 80a6250:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a6254:	bd08      	pop	{r3, pc}

080a6256 <_ZN9USBSerial9availableEv>:
{
 80a6256:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a6258:	7c00      	ldrb	r0, [r0, #16]
 80a625a:	f7fe f8b3 	bl	80a43c4 <HAL_USB_USART_Available_Data>
}
 80a625e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a6262:	bd08      	pop	{r3, pc}

080a6264 <_ZN9USBSerial5writeEh>:
{
 80a6264:	b538      	push	{r3, r4, r5, lr}
 80a6266:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a6268:	7c00      	ldrb	r0, [r0, #16]
{
 80a626a:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a626c:	f7fe f8b2 	bl	80a43d4 <HAL_USB_USART_Available_Data_For_Write>
 80a6270:	2800      	cmp	r0, #0
 80a6272:	dc01      	bgt.n	80a6278 <_ZN9USBSerial5writeEh+0x14>
 80a6274:	7c60      	ldrb	r0, [r4, #17]
 80a6276:	b128      	cbz	r0, 80a6284 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a6278:	4629      	mov	r1, r5
 80a627a:	7c20      	ldrb	r0, [r4, #16]
 80a627c:	f7fe f8ba 	bl	80a43f4 <HAL_USB_USART_Send_Data>
 80a6280:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
 80a6284:	bd38      	pop	{r3, r4, r5, pc}

080a6286 <_ZN9USBSerial5flushEv>:
  HAL_USB_USART_Flush_Data(_serial);
 80a6286:	7c00      	ldrb	r0, [r0, #16]
 80a6288:	f7fe b8bc 	b.w	80a4404 <HAL_USB_USART_Flush_Data>

080a628c <_ZN9USBSerialD0Ev>:
 80a628c:	b510      	push	{r4, lr}
 80a628e:	4604      	mov	r4, r0
 80a6290:	2114      	movs	r1, #20
 80a6292:	f000 fadd 	bl	80a6850 <_ZdlPvj>
 80a6296:	4620      	mov	r0, r4
 80a6298:	bd10      	pop	{r4, pc}

080a629a <__tcf_1>:
 80a629a:	4770      	bx	lr

080a629c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a629c:	b510      	push	{r4, lr}
 80a629e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a62a2:	4604      	mov	r4, r0
 80a62a4:	4608      	mov	r0, r1
 80a62a6:	2100      	movs	r1, #0
 80a62a8:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a62ac:	4b04      	ldr	r3, [pc, #16]	; (80a62c0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
  _serial = serial;
 80a62ae:	7420      	strb	r0, [r4, #16]
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a62b0:	6023      	str	r3, [r4, #0]
  _blocking = true;
 80a62b2:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
 80a62b4:	4611      	mov	r1, r2
  _blocking = true;
 80a62b6:	7463      	strb	r3, [r4, #17]
  HAL_USB_USART_Init(_serial, &conf);
 80a62b8:	f7fe f86c 	bl	80a4394 <HAL_USB_USART_Init>
}
 80a62bc:	4620      	mov	r0, r4
 80a62be:	bd10      	pop	{r4, pc}
 80a62c0:	080a7ff8 	.word	0x080a7ff8

080a62c4 <_ZN9USBSerial5beginEl>:
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a62c4:	2200      	movs	r2, #0
 80a62c6:	7c00      	ldrb	r0, [r0, #16]
 80a62c8:	f7fe b86c 	b.w	80a43a4 <HAL_USB_USART_Begin>

080a62cc <_ZN9USBSerial3endEv>:
    HAL_USB_USART_End(_serial);
 80a62cc:	7c00      	ldrb	r0, [r0, #16]
 80a62ce:	f7fe b871 	b.w	80a43b4 <HAL_USB_USART_End>
	...

080a62d4 <_Z19acquireSerialBufferv>:
{
 80a62d4:	b510      	push	{r4, lr}
 80a62d6:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a62d8:	2214      	movs	r2, #20
 80a62da:	2100      	movs	r1, #0
 80a62dc:	f001 faec 	bl	80a78b8 <memset>
  conf.rx_buffer = serial_rx_buffer;
 80a62e0:	4b05      	ldr	r3, [pc, #20]	; (80a62f8 <_Z19acquireSerialBufferv+0x24>)
}
 80a62e2:	4620      	mov	r0, r4
  conf.rx_buffer = serial_rx_buffer;
 80a62e4:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a62e6:	4b05      	ldr	r3, [pc, #20]	; (80a62fc <_Z19acquireSerialBufferv+0x28>)
 80a62e8:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a62ea:	f240 1301 	movw	r3, #257	; 0x101
 80a62ee:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a62f0:	2381      	movs	r3, #129	; 0x81
 80a62f2:	8223      	strh	r3, [r4, #16]
}
 80a62f4:	bd10      	pop	{r4, pc}
 80a62f6:	bf00      	nop
 80a62f8:	200017dc 	.word	0x200017dc
 80a62fc:	200018dd 	.word	0x200018dd

080a6300 <_Z16_fetch_usbserialv>:
{
 80a6300:	b530      	push	{r4, r5, lr}
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a6302:	4d0e      	ldr	r5, [pc, #56]	; (80a633c <_Z16_fetch_usbserialv+0x3c>)
{
 80a6304:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a6306:	a801      	add	r0, sp, #4
 80a6308:	f7ff ffe4 	bl	80a62d4 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a630c:	7829      	ldrb	r1, [r5, #0]
 80a630e:	f3bf 8f5b 	dmb	ish
 80a6312:	f011 0401 	ands.w	r4, r1, #1
 80a6316:	d10e      	bne.n	80a6336 <_Z16_fetch_usbserialv+0x36>
 80a6318:	4628      	mov	r0, r5
 80a631a:	f7f9 fecd 	bl	80a00b8 <__cxa_guard_acquire>
 80a631e:	b150      	cbz	r0, 80a6336 <_Z16_fetch_usbserialv+0x36>
 80a6320:	4621      	mov	r1, r4
 80a6322:	aa01      	add	r2, sp, #4
 80a6324:	4806      	ldr	r0, [pc, #24]	; (80a6340 <_Z16_fetch_usbserialv+0x40>)
 80a6326:	f7ff ffb9 	bl	80a629c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a632a:	4628      	mov	r0, r5
 80a632c:	f7f9 fec9 	bl	80a00c2 <__cxa_guard_release>
 80a6330:	4804      	ldr	r0, [pc, #16]	; (80a6344 <_Z16_fetch_usbserialv+0x44>)
 80a6332:	f001 fa85 	bl	80a7840 <atexit>
	return _usbserial;
}
 80a6336:	4802      	ldr	r0, [pc, #8]	; (80a6340 <_Z16_fetch_usbserialv+0x40>)
 80a6338:	b007      	add	sp, #28
 80a633a:	bd30      	pop	{r4, r5, pc}
 80a633c:	200017ac 	.word	0x200017ac
 80a6340:	200017b4 	.word	0x200017b4
 80a6344:	080a6225 	.word	0x080a6225

080a6348 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a6348:	b510      	push	{r4, lr}
 80a634a:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a634c:	2214      	movs	r2, #20
 80a634e:	2100      	movs	r1, #0
 80a6350:	f001 fab2 	bl	80a78b8 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a6354:	4b05      	ldr	r3, [pc, #20]	; (80a636c <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a6356:	4620      	mov	r0, r4
  conf.rx_buffer = usbserial1_rx_buffer;
 80a6358:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a635a:	4b05      	ldr	r3, [pc, #20]	; (80a6370 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a635c:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a635e:	f240 1301 	movw	r3, #257	; 0x101
 80a6362:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a6364:	2381      	movs	r3, #129	; 0x81
 80a6366:	8223      	strh	r3, [r4, #16]
}
 80a6368:	bd10      	pop	{r4, pc}
 80a636a:	bf00      	nop
 80a636c:	2000195e 	.word	0x2000195e
 80a6370:	20001a5f 	.word	0x20001a5f

080a6374 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a6374:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a6376:	4c0e      	ldr	r4, [pc, #56]	; (80a63b0 <_Z17_fetch_usbserial1v+0x3c>)
{
 80a6378:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a637a:	a801      	add	r0, sp, #4
 80a637c:	f7ff ffe4 	bl	80a6348 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a6380:	7823      	ldrb	r3, [r4, #0]
 80a6382:	f3bf 8f5b 	dmb	ish
 80a6386:	07db      	lsls	r3, r3, #31
 80a6388:	d40e      	bmi.n	80a63a8 <_Z17_fetch_usbserial1v+0x34>
 80a638a:	4620      	mov	r0, r4
 80a638c:	f7f9 fe94 	bl	80a00b8 <__cxa_guard_acquire>
 80a6390:	b150      	cbz	r0, 80a63a8 <_Z17_fetch_usbserial1v+0x34>
 80a6392:	2101      	movs	r1, #1
 80a6394:	aa01      	add	r2, sp, #4
 80a6396:	4807      	ldr	r0, [pc, #28]	; (80a63b4 <_Z17_fetch_usbserial1v+0x40>)
 80a6398:	f7ff ff80 	bl	80a629c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a639c:	4620      	mov	r0, r4
 80a639e:	f7f9 fe90 	bl	80a00c2 <__cxa_guard_release>
 80a63a2:	4805      	ldr	r0, [pc, #20]	; (80a63b8 <_Z17_fetch_usbserial1v+0x44>)
 80a63a4:	f001 fa4c 	bl	80a7840 <atexit>
  return _usbserial1;
}
 80a63a8:	4802      	ldr	r0, [pc, #8]	; (80a63b4 <_Z17_fetch_usbserial1v+0x40>)
 80a63aa:	b006      	add	sp, #24
 80a63ac:	bd10      	pop	{r4, pc}
 80a63ae:	bf00      	nop
 80a63b0:	200017b0 	.word	0x200017b0
 80a63b4:	200017c8 	.word	0x200017c8
 80a63b8:	080a629b 	.word	0x080a629b

080a63bc <_ZN5spark9WiFiClass5readyEv>:
        return network_ready(*this, 0, NULL);
 80a63bc:	2200      	movs	r2, #0
 80a63be:	6840      	ldr	r0, [r0, #4]
 80a63c0:	4611      	mov	r1, r2
 80a63c2:	f7fe b8a3 	b.w	80a450c <network_ready>

080a63c6 <_ZN5spark9WiFiClass7resolveEPKc>:
    IPAddress resolve(const char* name)
 80a63c6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a63c8:	4615      	mov	r5, r2
 80a63ca:	b089      	sub	sp, #36	; 0x24
        HAL_IPAddress ip = {};
 80a63cc:	2211      	movs	r2, #17
    IPAddress resolve(const char* name)
 80a63ce:	460e      	mov	r6, r1
 80a63d0:	4604      	mov	r4, r0
        HAL_IPAddress ip = {};
 80a63d2:	2100      	movs	r1, #0
 80a63d4:	a803      	add	r0, sp, #12
 80a63d6:	f001 fa6f 	bl	80a78b8 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a63da:	4628      	mov	r0, r5
 80a63dc:	f001 faf5 	bl	80a79ca <strlen>
 80a63e0:	2700      	movs	r7, #0
 80a63e2:	b281      	uxth	r1, r0
 80a63e4:	6873      	ldr	r3, [r6, #4]
 80a63e6:	4628      	mov	r0, r5
 80a63e8:	9700      	str	r7, [sp, #0]
 80a63ea:	aa03      	add	r2, sp, #12
 80a63ec:	f7fe f812 	bl	80a4414 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a63f0:	b130      	cbz	r0, 80a6400 <_ZN5spark9WiFiClass7resolveEPKc+0x3a>
 80a63f2:	4639      	mov	r1, r7
 80a63f4:	4620      	mov	r0, r4
 80a63f6:	f7fe f9d7 	bl	80a47a8 <_ZN9IPAddressC1Em>
    }
 80a63fa:	4620      	mov	r0, r4
 80a63fc:	b009      	add	sp, #36	; 0x24
 80a63fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a6400:	4620      	mov	r0, r4
 80a6402:	a903      	add	r1, sp, #12
 80a6404:	f7fe f9be 	bl	80a4784 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
 80a6408:	e7f7      	b.n	80a63fa <_ZN5spark9WiFiClass7resolveEPKc+0x34>

080a640a <_ZN5spark9WiFiClass9listeningEv>:
        return network_listening(*this, 0, NULL);
 80a640a:	2200      	movs	r2, #0
 80a640c:	6840      	ldr	r0, [r0, #4]
 80a640e:	4611      	mov	r1, r2
 80a6410:	f7fe b89c 	b.w	80a454c <network_listening>

080a6414 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
 80a6414:	2200      	movs	r2, #0
 80a6416:	6840      	ldr	r0, [r0, #4]
 80a6418:	4611      	mov	r1, r2
 80a641a:	f7fe b8a7 	b.w	80a456c <network_get_listen_timeout>

080a641e <_ZN5spark9WiFiClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
 80a641e:	2200      	movs	r2, #0
 80a6420:	6840      	ldr	r0, [r0, #4]
 80a6422:	f7fe b89b 	b.w	80a455c <network_set_listen_timeout>

080a6426 <_ZN5spark9WiFiClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
 80a6426:	2200      	movs	r2, #0
 80a6428:	6840      	ldr	r0, [r0, #4]
 80a642a:	f081 0101 	eor.w	r1, r1, #1
 80a642e:	f7fe b885 	b.w	80a453c <network_listen>

080a6432 <_ZN5spark9WiFiClass3offEv>:
        network_off(*this, 0, 0, NULL);
 80a6432:	2300      	movs	r3, #0
 80a6434:	6840      	ldr	r0, [r0, #4]
 80a6436:	461a      	mov	r2, r3
 80a6438:	4619      	mov	r1, r3
 80a643a:	f7fe b877 	b.w	80a452c <network_off>

080a643e <_ZN5spark9WiFiClass2onEv>:
        network_on(*this, 0, 0, NULL);
 80a643e:	2300      	movs	r3, #0
 80a6440:	6840      	ldr	r0, [r0, #4]
 80a6442:	461a      	mov	r2, r3
 80a6444:	4619      	mov	r1, r3
 80a6446:	f7fe b869 	b.w	80a451c <network_on>

080a644a <_ZN5spark9WiFiClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
 80a644a:	2200      	movs	r2, #0
 80a644c:	6840      	ldr	r0, [r0, #4]
 80a644e:	4611      	mov	r1, r2
 80a6450:	f7fe b84c 	b.w	80a44ec <network_connecting>

080a6454 <_ZN5spark9WiFiClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a6454:	2200      	movs	r2, #0
 80a6456:	2102      	movs	r1, #2
 80a6458:	6840      	ldr	r0, [r0, #4]
 80a645a:	f7fe b84f 	b.w	80a44fc <network_disconnect>

080a645e <_ZN5spark9WiFiClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
 80a645e:	2300      	movs	r3, #0
 80a6460:	6840      	ldr	r0, [r0, #4]
 80a6462:	461a      	mov	r2, r3
 80a6464:	f7fe b83a 	b.w	80a44dc <network_connect>

080a6468 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
 80a6468:	2204      	movs	r2, #4
 80a646a:	4b02      	ldr	r3, [pc, #8]	; (80a6474 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a646c:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a646e:	4a02      	ldr	r2, [pc, #8]	; (80a6478 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a6470:	601a      	str	r2, [r3, #0]
the same way.
*****************************************************************************/

    WiFiClass WiFi;
    // NetworkClass& Network = WiFi;
}
 80a6472:	4770      	bx	lr
 80a6474:	20001ae0 	.word	0x20001ae0
 80a6478:	080a8028 	.word	0x080a8028

080a647c <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
 80a647c:	b510      	push	{r4, lr}
 80a647e:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
 80a6480:	f001 faa3 	bl	80a79ca <strlen>
 80a6484:	1e43      	subs	r3, r0, #1
 80a6486:	4620      	mov	r0, r4
 80a6488:	4423      	add	r3, r4
	while(i<j){
 80a648a:	4283      	cmp	r3, r0
 80a648c:	d906      	bls.n	80a649c <_Z11str_reversePc+0x20>
		c = *i;
 80a648e:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
 80a6490:	7819      	ldrb	r1, [r3, #0]
 80a6492:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
 80a6496:	f803 2901 	strb.w	r2, [r3], #-1
	while(i<j){
 80a649a:	e7f6      	b.n	80a648a <_Z11str_reversePc+0xe>
		++i;
		--j;
	}
}
 80a649c:	bd10      	pop	{r4, pc}

080a649e <ultoa>:
      memcpy(head, ++tail, i);
      return str;
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
 80a649e:	b570      	push	{r4, r5, r6, lr}
 80a64a0:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
 80a64a2:	1e91      	subs	r1, r2, #2
 80a64a4:	2922      	cmp	r1, #34	; 0x22
 80a64a6:	d822      	bhi.n	80a64ee <ultoa+0x50>
		return NULL;
	}
	char* ptr=buffer;
 80a64a8:	4625      	mov	r5, r4

	div_t result;
	while(a){
 80a64aa:	b168      	cbz	r0, 80a64c8 <ultoa+0x2a>
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
 80a64ac:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
 80a64b0:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
 80a64b4:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
 80a64b6:	2809      	cmp	r0, #9
                *ptr += '0';
 80a64b8:	bf94      	ite	ls
 80a64ba:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
 80a64bc:	3157      	addhi	r1, #87	; 0x57
 80a64be:	b2c9      	uxtb	r1, r1
            }
            ++ptr;
            a = result.quot;
 80a64c0:	4630      	mov	r0, r6
 80a64c2:	f805 1b01 	strb.w	r1, [r5], #1
	while(a){
 80a64c6:	e7f0      	b.n	80a64aa <ultoa+0xc>
 80a64c8:	462a      	mov	r2, r5
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';
 80a64ca:	2130      	movs	r1, #48	; 0x30
        while (ptr < buffer+pad)
 80a64cc:	4423      	add	r3, r4
 80a64ce:	4293      	cmp	r3, r2
 80a64d0:	d902      	bls.n	80a64d8 <ultoa+0x3a>
            *ptr++ = '0';
 80a64d2:	f802 1b01 	strb.w	r1, [r2], #1
        while (ptr < buffer+pad)
 80a64d6:	e7fa      	b.n	80a64ce <ultoa+0x30>
 80a64d8:	1b5a      	subs	r2, r3, r5
 80a64da:	42ab      	cmp	r3, r5
 80a64dc:	bf38      	it	cc
 80a64de:	2200      	movcc	r2, #0

	*ptr = '\0';
 80a64e0:	2300      	movs	r3, #0
	str_reverse(buffer);
 80a64e2:	4620      	mov	r0, r4
	*ptr = '\0';
 80a64e4:	54ab      	strb	r3, [r5, r2]
	str_reverse(buffer);
 80a64e6:	f7ff ffc9 	bl	80a647c <_Z11str_reversePc>
	return buffer;
 80a64ea:	4620      	mov	r0, r4
}
 80a64ec:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
 80a64ee:	2000      	movs	r0, #0
 80a64f0:	e7fc      	b.n	80a64ec <ultoa+0x4e>

080a64f2 <itoa>:

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a64f2:	b538      	push	{r3, r4, r5, lr}
	if(a<0){
 80a64f4:	1e03      	subs	r3, r0, #0
__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a64f6:	460c      	mov	r4, r1
 80a64f8:	4615      	mov	r5, r2
	if(a<0){
 80a64fa:	da0d      	bge.n	80a6518 <itoa+0x26>
		*buffer = '-';
 80a64fc:	222d      	movs	r2, #45	; 0x2d
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
 80a64fe:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a6502:	bf0c      	ite	eq
 80a6504:	4618      	moveq	r0, r3
 80a6506:	4258      	negne	r0, r3
		ultoa((unsigned)v, buffer + 1, radix);
 80a6508:	2301      	movs	r3, #1
		*buffer = '-';
 80a650a:	700a      	strb	r2, [r1, #0]
		ultoa((unsigned)v, buffer + 1, radix);
 80a650c:	462a      	mov	r2, r5
 80a650e:	4419      	add	r1, r3
	}else{
		ultoa(a, buffer, radix);
 80a6510:	f7ff ffc5 	bl	80a649e <ultoa>
	}
	return buffer;
}
 80a6514:	4620      	mov	r0, r4
 80a6516:	bd38      	pop	{r3, r4, r5, pc}
		ultoa(a, buffer, radix);
 80a6518:	2301      	movs	r3, #1
 80a651a:	e7f9      	b.n	80a6510 <itoa+0x1e>

080a651c <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_>:

void module_user_init_hook()
{
#if HAL_PLATFORM_NEWLIB
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
        _impure_ptr = r;
 80a651c:	4b01      	ldr	r3, [pc, #4]	; (80a6524 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_+0x8>)
 80a651e:	6018      	str	r0, [r3, #0]
    }, nullptr);
 80a6520:	4770      	bx	lr
 80a6522:	bf00      	nop
 80a6524:	20000028 	.word	0x20000028

080a6528 <serialEventRun>:
{
 80a6528:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a652a:	4b13      	ldr	r3, [pc, #76]	; (80a6578 <serialEventRun+0x50>)
 80a652c:	b143      	cbz	r3, 80a6540 <serialEventRun+0x18>
 80a652e:	f7ff fee7 	bl	80a6300 <_Z16_fetch_usbserialv>
 80a6532:	6803      	ldr	r3, [r0, #0]
 80a6534:	691b      	ldr	r3, [r3, #16]
 80a6536:	4798      	blx	r3
 80a6538:	2800      	cmp	r0, #0
 80a653a:	dd01      	ble.n	80a6540 <serialEventRun+0x18>
        serialEvent();
 80a653c:	f3af 8000 	nop.w
    if (serialEvent1 && Serial1.available()>0)
 80a6540:	4b0e      	ldr	r3, [pc, #56]	; (80a657c <serialEventRun+0x54>)
 80a6542:	b143      	cbz	r3, 80a6556 <serialEventRun+0x2e>
 80a6544:	f7ff fe48 	bl	80a61d8 <_Z22__fetch_global_Serial1v>
 80a6548:	6803      	ldr	r3, [r0, #0]
 80a654a:	691b      	ldr	r3, [r3, #16]
 80a654c:	4798      	blx	r3
 80a654e:	2800      	cmp	r0, #0
 80a6550:	dd01      	ble.n	80a6556 <serialEventRun+0x2e>
        serialEvent1();
 80a6552:	f3af 8000 	nop.w
    if (serialEventRun2) serialEventRun2();
 80a6556:	4b0a      	ldr	r3, [pc, #40]	; (80a6580 <serialEventRun+0x58>)
 80a6558:	b10b      	cbz	r3, 80a655e <serialEventRun+0x36>
 80a655a:	f3af 8000 	nop.w
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a655e:	4b09      	ldr	r3, [pc, #36]	; (80a6584 <serialEventRun+0x5c>)
 80a6560:	b143      	cbz	r3, 80a6574 <serialEventRun+0x4c>
 80a6562:	f7ff ff07 	bl	80a6374 <_Z17_fetch_usbserial1v>
 80a6566:	6803      	ldr	r3, [r0, #0]
 80a6568:	691b      	ldr	r3, [r3, #16]
 80a656a:	4798      	blx	r3
 80a656c:	2800      	cmp	r0, #0
 80a656e:	dd01      	ble.n	80a6574 <serialEventRun+0x4c>
        usbSerialEvent1();
 80a6570:	f3af 8000 	nop.w
}
 80a6574:	bd08      	pop	{r3, pc}
 80a6576:	bf00      	nop
	...

080a6588 <_post_loop>:
{
 80a6588:	b508      	push	{r3, lr}
	serialEventRun();
 80a658a:	f7ff ffcd 	bl	80a6528 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a658e:	f7fd fddf 	bl	80a4150 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a6592:	4b01      	ldr	r3, [pc, #4]	; (80a6598 <_post_loop+0x10>)
 80a6594:	6018      	str	r0, [r3, #0]
}
 80a6596:	bd08      	pop	{r3, pc}
 80a6598:	20001af0 	.word	0x20001af0

080a659c <_Z33system_initialize_user_backup_ramv>:
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a659c:	4805      	ldr	r0, [pc, #20]	; (80a65b4 <_Z33system_initialize_user_backup_ramv+0x18>)
 80a659e:	4a06      	ldr	r2, [pc, #24]	; (80a65b8 <_Z33system_initialize_user_backup_ramv+0x1c>)
{
 80a65a0:	b508      	push	{r3, lr}
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a65a2:	1a12      	subs	r2, r2, r0
 80a65a4:	4905      	ldr	r1, [pc, #20]	; (80a65bc <_Z33system_initialize_user_backup_ramv+0x20>)
 80a65a6:	f001 f95f 	bl	80a7868 <memcpy>
    __backup_sram_signature = signature;
 80a65aa:	4b05      	ldr	r3, [pc, #20]	; (80a65c0 <_Z33system_initialize_user_backup_ramv+0x24>)
 80a65ac:	4a05      	ldr	r2, [pc, #20]	; (80a65c4 <_Z33system_initialize_user_backup_ramv+0x28>)
 80a65ae:	601a      	str	r2, [r3, #0]
}
 80a65b0:	bd08      	pop	{r3, pc}
 80a65b2:	bf00      	nop
 80a65b4:	40024000 	.word	0x40024000
 80a65b8:	40024004 	.word	0x40024004
 80a65bc:	080a8190 	.word	0x080a8190
 80a65c0:	40024000 	.word	0x40024000
 80a65c4:	9a271c1e 	.word	0x9a271c1e

080a65c8 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a65c8:	2300      	movs	r3, #0
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a65ca:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a65cc:	461a      	mov	r2, r3
 80a65ce:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a65d2:	9300      	str	r3, [sp, #0]
 80a65d4:	f7fd ff60 	bl	80a4498 <system_ctrl_set_result>
}
 80a65d8:	b003      	add	sp, #12
 80a65da:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a65e0 <_ZL20ctrl_request_handlerP12ctrl_request>:
static void ctrl_request_handler(ctrl_request* req) {
 80a65e0:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a65e2:	8843      	ldrh	r3, [r0, #2]
 80a65e4:	2b0a      	cmp	r3, #10
 80a65e6:	d008      	beq.n	80a65fa <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a65e8:	2b50      	cmp	r3, #80	; 0x50
 80a65ea:	d10b      	bne.n	80a6604 <_ZL20ctrl_request_handlerP12ctrl_request+0x24>
        if (log_process_ctrl_request_callback) {
 80a65ec:	4b09      	ldr	r3, [pc, #36]	; (80a6614 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a65ee:	681b      	ldr	r3, [r3, #0]
 80a65f0:	b14b      	cbz	r3, 80a6606 <_ZL20ctrl_request_handlerP12ctrl_request+0x26>
}
 80a65f2:	b003      	add	sp, #12
 80a65f4:	f85d eb04 	ldr.w	lr, [sp], #4
            log_process_ctrl_request_callback(req);
 80a65f8:	4718      	bx	r3
        ctrl_request_custom_handler(req);
 80a65fa:	f7ff ffe5 	bl	80a65c8 <_Z27ctrl_request_custom_handlerP12ctrl_request>
}
 80a65fe:	b003      	add	sp, #12
 80a6600:	f85d fb04 	ldr.w	pc, [sp], #4
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a6604:	2300      	movs	r3, #0
 80a6606:	461a      	mov	r2, r3
 80a6608:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a660c:	9300      	str	r3, [sp, #0]
 80a660e:	f7fd ff43 	bl	80a4498 <system_ctrl_set_result>
}
 80a6612:	e7f4      	b.n	80a65fe <_ZL20ctrl_request_handlerP12ctrl_request+0x1e>
 80a6614:	20001aec 	.word	0x20001aec

080a6618 <module_user_init_hook>:
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a6618:	2100      	movs	r1, #0
{
 80a661a:	b510      	push	{r4, lr}
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a661c:	4811      	ldr	r0, [pc, #68]	; (80a6664 <module_user_init_hook+0x4c>)
 80a661e:	f7fd ffed 	bl	80a45fc <newlib_impure_ptr_callback>
#endif // HAL_PLATFORM_NEWLIB

#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ = __backup_sram_signature == signature;
 80a6622:	4b11      	ldr	r3, [pc, #68]	; (80a6668 <module_user_init_hook+0x50>)
 80a6624:	681a      	ldr	r2, [r3, #0]
 80a6626:	4b11      	ldr	r3, [pc, #68]	; (80a666c <module_user_init_hook+0x54>)
 80a6628:	429a      	cmp	r2, r3
 80a662a:	bf0c      	ite	eq
 80a662c:	2201      	moveq	r2, #1
 80a662e:	2200      	movne	r2, #0
 80a6630:	4b0f      	ldr	r3, [pc, #60]	; (80a6670 <module_user_init_hook+0x58>)
 80a6632:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a6634:	d001      	beq.n	80a663a <module_user_init_hook+0x22>
        system_initialize_user_backup_ram();
 80a6636:	f7ff ffb1 	bl	80a659c <_Z33system_initialize_user_backup_ramv>
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a663a:	f7fd fd71 	bl	80a4120 <HAL_RNG_GetRandomNumber>
 80a663e:	4604      	mov	r4, r0
    srand(seed);
 80a6640:	f001 f942 	bl	80a78c8 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a6644:	4b0b      	ldr	r3, [pc, #44]	; (80a6674 <module_user_init_hook+0x5c>)
 80a6646:	b113      	cbz	r3, 80a664e <module_user_init_hook+0x36>
        random_seed_from_cloud(seed);
 80a6648:	4620      	mov	r0, r4
 80a664a:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a664e:	2100      	movs	r1, #0
 80a6650:	4808      	ldr	r0, [pc, #32]	; (80a6674 <module_user_init_hook+0x5c>)
 80a6652:	f7fd ff3b 	bl	80a44cc <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a6656:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a665a:	2100      	movs	r1, #0
 80a665c:	4806      	ldr	r0, [pc, #24]	; (80a6678 <module_user_init_hook+0x60>)
 80a665e:	f7fd bf11 	b.w	80a4484 <system_ctrl_set_app_request_handler>
 80a6662:	bf00      	nop
 80a6664:	080a651d 	.word	0x080a651d
 80a6668:	40024000 	.word	0x40024000
 80a666c:	9a271c1e 	.word	0x9a271c1e
 80a6670:	20001ae8 	.word	0x20001ae8
 80a6674:	00000000 	.word	0x00000000
 80a6678:	080a65e1 	.word	0x080a65e1

080a667c <__tcf_0>:
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a667c:	4b02      	ldr	r3, [pc, #8]	; (80a6688 <__tcf_0+0xc>)
 80a667e:	6898      	ldr	r0, [r3, #8]
 80a6680:	b108      	cbz	r0, 80a6686 <__tcf_0+0xa>
            os_mutex_recursive_destroy(handle_);
 80a6682:	f7fd bd35 	b.w	80a40f0 <os_mutex_recursive_destroy>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a6686:	4770      	bx	lr
 80a6688:	20000094 	.word	0x20000094

080a668c <pinAvailable>:
/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
  if (pin >= TOTAL_PINS) {
 80a668c:	2817      	cmp	r0, #23
bool pinAvailable(uint16_t pin) {
 80a668e:	b570      	push	{r4, r5, r6, lr}
 80a6690:	4604      	mov	r4, r0
  if (pin >= TOTAL_PINS) {
 80a6692:	d901      	bls.n	80a6698 <pinAvailable+0xc>
    return false;
 80a6694:	2000      	movs	r0, #0
    return false; // 'pin' is used
  }
#endif

  return true; // 'pin' is available
}
 80a6696:	bd70      	pop	{r4, r5, r6, pc}
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a6698:	f1a0 030d 	sub.w	r3, r0, #13
 80a669c:	2b02      	cmp	r3, #2
 80a669e:	d90b      	bls.n	80a66b8 <pinAvailable+0x2c>
  if((pin == SCL || pin == SDA) && hal_i2c_is_enabled(Wire.interface(), nullptr) == true)
 80a66a0:	2801      	cmp	r0, #1
 80a66a2:	d824      	bhi.n	80a66ee <pinAvailable+0x62>
 80a66a4:	f000 f8a2 	bl	80a67ec <_Z19__fetch_global_Wirev>
 80a66a8:	2100      	movs	r1, #0
 80a66aa:	7c00      	ldrb	r0, [r0, #16]
 80a66ac:	f7fd fdb8 	bl	80a4220 <hal_i2c_is_enabled>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a66b0:	f080 0001 	eor.w	r0, r0, #1
 80a66b4:	b2c0      	uxtb	r0, r0
 80a66b6:	e7ee      	b.n	80a6696 <pinAvailable+0xa>
 80a66b8:	4e12      	ldr	r6, [pc, #72]	; (80a6704 <pinAvailable+0x78>)
 80a66ba:	7831      	ldrb	r1, [r6, #0]
 80a66bc:	f3bf 8f5b 	dmb	ish
 80a66c0:	f011 0501 	ands.w	r5, r1, #1
 80a66c4:	d10d      	bne.n	80a66e2 <pinAvailable+0x56>
 80a66c6:	4630      	mov	r0, r6
 80a66c8:	f7f9 fcf6 	bl	80a00b8 <__cxa_guard_acquire>
 80a66cc:	b148      	cbz	r0, 80a66e2 <pinAvailable+0x56>
 80a66ce:	4629      	mov	r1, r5
 80a66d0:	480d      	ldr	r0, [pc, #52]	; (80a6708 <pinAvailable+0x7c>)
 80a66d2:	f7ff fbad 	bl	80a5e30 <_ZN8SPIClassC1E19hal_spi_interface_t>
 80a66d6:	4630      	mov	r0, r6
 80a66d8:	f7f9 fcf3 	bl	80a00c2 <__cxa_guard_release>
 80a66dc:	480b      	ldr	r0, [pc, #44]	; (80a670c <pinAvailable+0x80>)
 80a66de:	f001 f8af 	bl	80a7840 <atexit>
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a66e2:	4b09      	ldr	r3, [pc, #36]	; (80a6708 <pinAvailable+0x7c>)
 80a66e4:	7818      	ldrb	r0, [r3, #0]
 80a66e6:	f7fd fddd 	bl	80a42a4 <hal_spi_is_enabled>
 80a66ea:	2800      	cmp	r0, #0
 80a66ec:	d1d2      	bne.n	80a6694 <pinAvailable+0x8>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a66ee:	3c12      	subs	r4, #18
 80a66f0:	2c01      	cmp	r4, #1
 80a66f2:	d805      	bhi.n	80a6700 <pinAvailable+0x74>
 80a66f4:	f7ff fd70 	bl	80a61d8 <_Z22__fetch_global_Serial1v>
 80a66f8:	7c00      	ldrb	r0, [r0, #16]
 80a66fa:	f7fd fe33 	bl	80a4364 <hal_usart_is_enabled>
 80a66fe:	e7d7      	b.n	80a66b0 <pinAvailable+0x24>
  return true; // 'pin' is available
 80a6700:	2001      	movs	r0, #1
 80a6702:	e7c8      	b.n	80a6696 <pinAvailable+0xa>
 80a6704:	20000090 	.word	0x20000090
 80a6708:	20000094 	.word	0x20000094
 80a670c:	080a667d 	.word	0x080a667d

080a6710 <pinMode>:
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a6710:	2817      	cmp	r0, #23
{
 80a6712:	b538      	push	{r3, r4, r5, lr}
 80a6714:	4604      	mov	r4, r0
 80a6716:	460d      	mov	r5, r1
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a6718:	d80a      	bhi.n	80a6730 <pinMode+0x20>
 80a671a:	29ff      	cmp	r1, #255	; 0xff
 80a671c:	d008      	beq.n	80a6730 <pinMode+0x20>
  if( !pinAvailable(pin) ) {
 80a671e:	f7ff ffb5 	bl	80a668c <pinAvailable>
 80a6722:	b128      	cbz	r0, 80a6730 <pinMode+0x20>
  HAL_Pin_Mode(pin, setMode);
 80a6724:	4629      	mov	r1, r5
 80a6726:	4620      	mov	r0, r4
}
 80a6728:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_Pin_Mode(pin, setMode);
 80a672c:	f7fd bd28 	b.w	80a4180 <HAL_Pin_Mode>
}
 80a6730:	bd38      	pop	{r3, r4, r5, pc}

080a6732 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a6732:	b538      	push	{r3, r4, r5, lr}
 80a6734:	4604      	mov	r4, r0
 80a6736:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a6738:	f7fd fd2a 	bl	80a4190 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a673c:	28ff      	cmp	r0, #255	; 0xff
 80a673e:	d010      	beq.n	80a6762 <digitalWrite+0x30>
            mode == INPUT_PULLDOWN ||
 80a6740:	2806      	cmp	r0, #6
 80a6742:	d804      	bhi.n	80a674e <digitalWrite+0x1c>
 80a6744:	234d      	movs	r3, #77	; 0x4d
 80a6746:	fa23 f000 	lsr.w	r0, r3, r0
 80a674a:	07c3      	lsls	r3, r0, #31
 80a674c:	d409      	bmi.n	80a6762 <digitalWrite+0x30>
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a674e:	4620      	mov	r0, r4
 80a6750:	f7ff ff9c 	bl	80a668c <pinAvailable>
 80a6754:	b128      	cbz	r0, 80a6762 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a6756:	4629      	mov	r1, r5
 80a6758:	4620      	mov	r0, r4
}
 80a675a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_GPIO_Write(pin, value);
 80a675e:	f7fd bd1f 	b.w	80a41a0 <HAL_GPIO_Write>
}
 80a6762:	bd38      	pop	{r3, r4, r5, pc}

080a6764 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a6764:	b510      	push	{r4, lr}
 80a6766:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a6768:	f7fd fd12 	bl	80a4190 <HAL_Get_Pin_Mode>
    return mode == AF_OUTPUT_PUSHPULL ||
 80a676c:	1f03      	subs	r3, r0, #4
    if (is_af_output_mode(mode))
 80a676e:	b2db      	uxtb	r3, r3
 80a6770:	2b01      	cmp	r3, #1
 80a6772:	d908      	bls.n	80a6786 <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a6774:	4620      	mov	r0, r4
 80a6776:	f7ff ff89 	bl	80a668c <pinAvailable>
 80a677a:	b120      	cbz	r0, 80a6786 <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a677c:	4620      	mov	r0, r4
}
 80a677e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return HAL_GPIO_Read(pin);
 80a6782:	f7fd bd15 	b.w	80a41b0 <HAL_GPIO_Read>
}
 80a6786:	2000      	movs	r0, #0
 80a6788:	bd10      	pop	{r4, pc}

080a678a <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a678a:	b510      	push	{r4, lr}
 80a678c:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a678e:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a6790:	bf9c      	itt	ls
 80a6792:	340a      	addls	r4, #10
 80a6794:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a6796:	4620      	mov	r0, r4
 80a6798:	f7ff ff78 	bl	80a668c <pinAvailable>
 80a679c:	b150      	cbz	r0, 80a67b4 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a679e:	2103      	movs	r1, #3
 80a67a0:	4620      	mov	r0, r4
 80a67a2:	f7fd fce5 	bl	80a4170 <HAL_Validate_Pin_Function>
 80a67a6:	2803      	cmp	r0, #3
 80a67a8:	d104      	bne.n	80a67b4 <analogRead+0x2a>
  {
    return LOW;
  }

  return hal_adc_read(pin);
 80a67aa:	4620      	mov	r0, r4
}
 80a67ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return hal_adc_read(pin);
 80a67b0:	f7fd bd06 	b.w	80a41c0 <hal_adc_read>
}
 80a67b4:	2000      	movs	r0, #0
 80a67b6:	bd10      	pop	{r4, pc}

080a67b8 <__tcf_0>:
}
#endif

TwoWire& __fetch_global_Wire()
{
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a67b8:	4770      	bx	lr
	...

080a67bc <_Z17acquireWireBufferv>:
	hal_i2c_config_t config = {
 80a67bc:	2300      	movs	r3, #0
{
 80a67be:	b570      	push	{r4, r5, r6, lr}
	hal_i2c_config_t config = {
 80a67c0:	2520      	movs	r5, #32
 80a67c2:	8043      	strh	r3, [r0, #2]
 80a67c4:	2314      	movs	r3, #20
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a67c6:	4e08      	ldr	r6, [pc, #32]	; (80a67e8 <_Z17acquireWireBufferv+0x2c>)
{
 80a67c8:	4604      	mov	r4, r0
	hal_i2c_config_t config = {
 80a67ca:	8003      	strh	r3, [r0, #0]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a67cc:	4631      	mov	r1, r6
	hal_i2c_config_t config = {
 80a67ce:	6085      	str	r5, [r0, #8]
 80a67d0:	6105      	str	r5, [r0, #16]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a67d2:	4628      	mov	r0, r5
 80a67d4:	f000 f840 	bl	80a6858 <_ZnajRKSt9nothrow_t>
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a67d8:	4631      	mov	r1, r6
	};
 80a67da:	6060      	str	r0, [r4, #4]
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a67dc:	4628      	mov	r0, r5
 80a67de:	f000 f83b 	bl	80a6858 <_ZnajRKSt9nothrow_t>
	};
 80a67e2:	60e0      	str	r0, [r4, #12]
}
 80a67e4:	4620      	mov	r0, r4
 80a67e6:	bd70      	pop	{r4, r5, r6, pc}
 80a67e8:	080a805c 	.word	0x080a805c

080a67ec <_Z19__fetch_global_Wirev>:
{
 80a67ec:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a67ee:	4d0e      	ldr	r5, [pc, #56]	; (80a6828 <_Z19__fetch_global_Wirev+0x3c>)
{
 80a67f0:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a67f2:	7829      	ldrb	r1, [r5, #0]
 80a67f4:	f3bf 8f5b 	dmb	ish
 80a67f8:	f011 0401 	ands.w	r4, r1, #1
 80a67fc:	d111      	bne.n	80a6822 <_Z19__fetch_global_Wirev+0x36>
 80a67fe:	4628      	mov	r0, r5
 80a6800:	f7f9 fc5a 	bl	80a00b8 <__cxa_guard_acquire>
 80a6804:	b168      	cbz	r0, 80a6822 <_Z19__fetch_global_Wirev+0x36>
 80a6806:	a801      	add	r0, sp, #4
 80a6808:	f7ff ffd8 	bl	80a67bc <_Z17acquireWireBufferv>
 80a680c:	4621      	mov	r1, r4
 80a680e:	aa01      	add	r2, sp, #4
 80a6810:	4806      	ldr	r0, [pc, #24]	; (80a682c <_Z19__fetch_global_Wirev+0x40>)
 80a6812:	f7fd ff75 	bl	80a4700 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>
 80a6816:	4628      	mov	r0, r5
 80a6818:	f7f9 fc53 	bl	80a00c2 <__cxa_guard_release>
 80a681c:	4804      	ldr	r0, [pc, #16]	; (80a6830 <_Z19__fetch_global_Wirev+0x44>)
 80a681e:	f001 f80f 	bl	80a7840 <atexit>
	return wire;
}
 80a6822:	4802      	ldr	r0, [pc, #8]	; (80a682c <_Z19__fetch_global_Wirev+0x40>)
 80a6824:	b007      	add	sp, #28
 80a6826:	bd30      	pop	{r4, r5, pc}
 80a6828:	20001af4 	.word	0x20001af4
 80a682c:	20001af8 	.word	0x20001af8
 80a6830:	080a67b9 	.word	0x080a67b9

080a6834 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a6834:	2300      	movs	r3, #0
 80a6836:	b507      	push	{r0, r1, r2, lr}
 80a6838:	461a      	mov	r2, r3
 80a683a:	4619      	mov	r1, r3
 80a683c:	9300      	str	r3, [sp, #0]
 80a683e:	4803      	ldr	r0, [pc, #12]	; (80a684c <_GLOBAL__sub_I_INADDR_NONE+0x18>)
 80a6840:	f7fd ffc8 	bl	80a47d4 <_ZN9IPAddressC1Ehhhh>
 80a6844:	b003      	add	sp, #12
 80a6846:	f85d fb04 	ldr.w	pc, [sp], #4
 80a684a:	bf00      	nop
 80a684c:	20001b0c 	.word	0x20001b0c

080a6850 <_ZdlPvj>:
 80a6850:	f7f9 bc25 	b.w	80a009e <_ZdlPv>

080a6854 <_ZnwjRKSt9nothrow_t>:
 80a6854:	f7f9 bc1f 	b.w	80a0096 <_Znwj>

080a6858 <_ZnajRKSt9nothrow_t>:
 80a6858:	f7f9 bc1f 	b.w	80a009a <_Znaj>

080a685c <_ZSt25__throw_bad_function_callv>:
 80a685c:	b508      	push	{r3, lr}
 80a685e:	f7fd febd 	bl	80a45dc <abort>
	...

080a6864 <sqrtf>:
 80a6864:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a6866:	b08b      	sub	sp, #44	; 0x2c
 80a6868:	4604      	mov	r4, r0
 80a686a:	f000 f84d 	bl	80a6908 <__ieee754_sqrtf>
 80a686e:	4b24      	ldr	r3, [pc, #144]	; (80a6900 <sqrtf+0x9c>)
 80a6870:	4605      	mov	r5, r0
 80a6872:	f993 7000 	ldrsb.w	r7, [r3]
 80a6876:	1c7b      	adds	r3, r7, #1
 80a6878:	d00a      	beq.n	80a6890 <sqrtf+0x2c>
 80a687a:	4621      	mov	r1, r4
 80a687c:	4620      	mov	r0, r4
 80a687e:	f000 ffc9 	bl	80a7814 <__aeabi_fcmpun>
 80a6882:	4606      	mov	r6, r0
 80a6884:	b920      	cbnz	r0, 80a6890 <sqrtf+0x2c>
 80a6886:	2100      	movs	r1, #0
 80a6888:	4620      	mov	r0, r4
 80a688a:	f000 ff9b 	bl	80a77c4 <__aeabi_fcmplt>
 80a688e:	b910      	cbnz	r0, 80a6896 <sqrtf+0x32>
 80a6890:	4628      	mov	r0, r5
 80a6892:	b00b      	add	sp, #44	; 0x2c
 80a6894:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a6896:	2201      	movs	r2, #1
 80a6898:	4b1a      	ldr	r3, [pc, #104]	; (80a6904 <sqrtf+0xa0>)
 80a689a:	4620      	mov	r0, r4
 80a689c:	e9cd 2300 	strd	r2, r3, [sp]
 80a68a0:	9608      	str	r6, [sp, #32]
 80a68a2:	f000 f9eb 	bl	80a6c7c <__aeabi_f2d>
 80a68a6:	2200      	movs	r2, #0
 80a68a8:	2300      	movs	r3, #0
 80a68aa:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80a68ae:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80a68b2:	b1af      	cbz	r7, 80a68e0 <sqrtf+0x7c>
 80a68b4:	4610      	mov	r0, r2
 80a68b6:	4619      	mov	r1, r3
 80a68b8:	f000 fb62 	bl	80a6f80 <__aeabi_ddiv>
 80a68bc:	2f02      	cmp	r7, #2
 80a68be:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80a68c2:	d10f      	bne.n	80a68e4 <sqrtf+0x80>
 80a68c4:	f7fd fe92 	bl	80a45ec <__errno>
 80a68c8:	2321      	movs	r3, #33	; 0x21
 80a68ca:	6003      	str	r3, [r0, #0]
 80a68cc:	9b08      	ldr	r3, [sp, #32]
 80a68ce:	b98b      	cbnz	r3, 80a68f4 <sqrtf+0x90>
 80a68d0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80a68d4:	f000 fc7a 	bl	80a71cc <__aeabi_d2f>
 80a68d8:	4605      	mov	r5, r0
 80a68da:	4628      	mov	r0, r5
 80a68dc:	b00b      	add	sp, #44	; 0x2c
 80a68de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a68e0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80a68e4:	4668      	mov	r0, sp
 80a68e6:	f000 f863 	bl	80a69b0 <matherr>
 80a68ea:	2800      	cmp	r0, #0
 80a68ec:	d0ea      	beq.n	80a68c4 <sqrtf+0x60>
 80a68ee:	9b08      	ldr	r3, [sp, #32]
 80a68f0:	2b00      	cmp	r3, #0
 80a68f2:	d0ed      	beq.n	80a68d0 <sqrtf+0x6c>
 80a68f4:	f7fd fe7a 	bl	80a45ec <__errno>
 80a68f8:	9b08      	ldr	r3, [sp, #32]
 80a68fa:	6003      	str	r3, [r0, #0]
 80a68fc:	e7e8      	b.n	80a68d0 <sqrtf+0x6c>
 80a68fe:	bf00      	nop
 80a6900:	20000024 	.word	0x20000024
 80a6904:	080a8060 	.word	0x080a8060

080a6908 <__ieee754_sqrtf>:
 80a6908:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 80a690c:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80a6910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a6912:	4604      	mov	r4, r0
 80a6914:	d22f      	bcs.n	80a6976 <__ieee754_sqrtf+0x6e>
 80a6916:	b36a      	cbz	r2, 80a6974 <__ieee754_sqrtf+0x6c>
 80a6918:	2800      	cmp	r0, #0
 80a691a:	4603      	mov	r3, r0
 80a691c:	db3d      	blt.n	80a699a <__ieee754_sqrtf+0x92>
 80a691e:	f010 4fff 	tst.w	r0, #2139095040	; 0x7f800000
 80a6922:	ea4f 54e0 	mov.w	r4, r0, asr #23
 80a6926:	d02d      	beq.n	80a6984 <__ieee754_sqrtf+0x7c>
 80a6928:	2600      	movs	r6, #0
 80a692a:	07e2      	lsls	r2, r4, #31
 80a692c:	f1a4 007f 	sub.w	r0, r4, #127	; 0x7f
 80a6930:	4631      	mov	r1, r6
 80a6932:	f04f 0419 	mov.w	r4, #25
 80a6936:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80a693a:	f3c3 0316 	ubfx	r3, r3, #0, #23
 80a693e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80a6942:	bf58      	it	pl
 80a6944:	005b      	lslpl	r3, r3, #1
 80a6946:	1047      	asrs	r7, r0, #1
 80a6948:	005b      	lsls	r3, r3, #1
 80a694a:	188d      	adds	r5, r1, r2
 80a694c:	429d      	cmp	r5, r3
 80a694e:	dc02      	bgt.n	80a6956 <__ieee754_sqrtf+0x4e>
 80a6950:	1b5b      	subs	r3, r3, r5
 80a6952:	18a9      	adds	r1, r5, r2
 80a6954:	4416      	add	r6, r2
 80a6956:	3c01      	subs	r4, #1
 80a6958:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80a695c:	ea4f 0252 	mov.w	r2, r2, lsr #1
 80a6960:	d1f3      	bne.n	80a694a <__ieee754_sqrtf+0x42>
 80a6962:	b113      	cbz	r3, 80a696a <__ieee754_sqrtf+0x62>
 80a6964:	3601      	adds	r6, #1
 80a6966:	f026 0601 	bic.w	r6, r6, #1
 80a696a:	1070      	asrs	r0, r6, #1
 80a696c:	f100 507c 	add.w	r0, r0, #1056964608	; 0x3f000000
 80a6970:	eb00 50c7 	add.w	r0, r0, r7, lsl #23
 80a6974:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a6976:	4601      	mov	r1, r0
 80a6978:	f000 fd86 	bl	80a7488 <__aeabi_fmul>
 80a697c:	4621      	mov	r1, r4
 80a697e:	f000 fc7b 	bl	80a7278 <__addsf3>
 80a6982:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a6984:	f410 0200 	ands.w	r2, r0, #8388608	; 0x800000
 80a6988:	d10e      	bne.n	80a69a8 <__ieee754_sqrtf+0xa0>
 80a698a:	005b      	lsls	r3, r3, #1
 80a698c:	0218      	lsls	r0, r3, #8
 80a698e:	4611      	mov	r1, r2
 80a6990:	f102 0201 	add.w	r2, r2, #1
 80a6994:	d5f9      	bpl.n	80a698a <__ieee754_sqrtf+0x82>
 80a6996:	1a64      	subs	r4, r4, r1
 80a6998:	e7c6      	b.n	80a6928 <__ieee754_sqrtf+0x20>
 80a699a:	4601      	mov	r1, r0
 80a699c:	f000 fc6a 	bl	80a7274 <__aeabi_fsub>
 80a69a0:	4601      	mov	r1, r0
 80a69a2:	f000 fe25 	bl	80a75f0 <__aeabi_fdiv>
 80a69a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a69a8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80a69ac:	e7f3      	b.n	80a6996 <__ieee754_sqrtf+0x8e>
 80a69ae:	bf00      	nop

080a69b0 <matherr>:
 80a69b0:	2000      	movs	r0, #0
 80a69b2:	4770      	bx	lr

080a69b4 <__aeabi_drsub>:
 80a69b4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a69b8:	e002      	b.n	80a69c0 <__adddf3>
 80a69ba:	bf00      	nop

080a69bc <__aeabi_dsub>:
 80a69bc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a69c0 <__adddf3>:
 80a69c0:	b530      	push	{r4, r5, lr}
 80a69c2:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a69c6:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a69ca:	ea94 0f05 	teq	r4, r5
 80a69ce:	bf08      	it	eq
 80a69d0:	ea90 0f02 	teqeq	r0, r2
 80a69d4:	bf1f      	itttt	ne
 80a69d6:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a69da:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a69de:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a69e2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a69e6:	f000 80e2 	beq.w	80a6bae <__adddf3+0x1ee>
 80a69ea:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a69ee:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a69f2:	bfb8      	it	lt
 80a69f4:	426d      	neglt	r5, r5
 80a69f6:	dd0c      	ble.n	80a6a12 <__adddf3+0x52>
 80a69f8:	442c      	add	r4, r5
 80a69fa:	ea80 0202 	eor.w	r2, r0, r2
 80a69fe:	ea81 0303 	eor.w	r3, r1, r3
 80a6a02:	ea82 0000 	eor.w	r0, r2, r0
 80a6a06:	ea83 0101 	eor.w	r1, r3, r1
 80a6a0a:	ea80 0202 	eor.w	r2, r0, r2
 80a6a0e:	ea81 0303 	eor.w	r3, r1, r3
 80a6a12:	2d36      	cmp	r5, #54	; 0x36
 80a6a14:	bf88      	it	hi
 80a6a16:	bd30      	pophi	{r4, r5, pc}
 80a6a18:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a6a1c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a6a20:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a6a24:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a6a28:	d002      	beq.n	80a6a30 <__adddf3+0x70>
 80a6a2a:	4240      	negs	r0, r0
 80a6a2c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a6a30:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a6a34:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a6a38:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a6a3c:	d002      	beq.n	80a6a44 <__adddf3+0x84>
 80a6a3e:	4252      	negs	r2, r2
 80a6a40:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a6a44:	ea94 0f05 	teq	r4, r5
 80a6a48:	f000 80a7 	beq.w	80a6b9a <__adddf3+0x1da>
 80a6a4c:	f1a4 0401 	sub.w	r4, r4, #1
 80a6a50:	f1d5 0e20 	rsbs	lr, r5, #32
 80a6a54:	db0d      	blt.n	80a6a72 <__adddf3+0xb2>
 80a6a56:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a6a5a:	fa22 f205 	lsr.w	r2, r2, r5
 80a6a5e:	1880      	adds	r0, r0, r2
 80a6a60:	f141 0100 	adc.w	r1, r1, #0
 80a6a64:	fa03 f20e 	lsl.w	r2, r3, lr
 80a6a68:	1880      	adds	r0, r0, r2
 80a6a6a:	fa43 f305 	asr.w	r3, r3, r5
 80a6a6e:	4159      	adcs	r1, r3
 80a6a70:	e00e      	b.n	80a6a90 <__adddf3+0xd0>
 80a6a72:	f1a5 0520 	sub.w	r5, r5, #32
 80a6a76:	f10e 0e20 	add.w	lr, lr, #32
 80a6a7a:	2a01      	cmp	r2, #1
 80a6a7c:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a6a80:	bf28      	it	cs
 80a6a82:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a6a86:	fa43 f305 	asr.w	r3, r3, r5
 80a6a8a:	18c0      	adds	r0, r0, r3
 80a6a8c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a6a90:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a6a94:	d507      	bpl.n	80a6aa6 <__adddf3+0xe6>
 80a6a96:	f04f 0e00 	mov.w	lr, #0
 80a6a9a:	f1dc 0c00 	rsbs	ip, ip, #0
 80a6a9e:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a6aa2:	eb6e 0101 	sbc.w	r1, lr, r1
 80a6aa6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a6aaa:	d31b      	bcc.n	80a6ae4 <__adddf3+0x124>
 80a6aac:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a6ab0:	d30c      	bcc.n	80a6acc <__adddf3+0x10c>
 80a6ab2:	0849      	lsrs	r1, r1, #1
 80a6ab4:	ea5f 0030 	movs.w	r0, r0, rrx
 80a6ab8:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a6abc:	f104 0401 	add.w	r4, r4, #1
 80a6ac0:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a6ac4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a6ac8:	f080 809a 	bcs.w	80a6c00 <__adddf3+0x240>
 80a6acc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a6ad0:	bf08      	it	eq
 80a6ad2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a6ad6:	f150 0000 	adcs.w	r0, r0, #0
 80a6ada:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a6ade:	ea41 0105 	orr.w	r1, r1, r5
 80a6ae2:	bd30      	pop	{r4, r5, pc}
 80a6ae4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a6ae8:	4140      	adcs	r0, r0
 80a6aea:	eb41 0101 	adc.w	r1, r1, r1
 80a6aee:	3c01      	subs	r4, #1
 80a6af0:	bf28      	it	cs
 80a6af2:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80a6af6:	d2e9      	bcs.n	80a6acc <__adddf3+0x10c>
 80a6af8:	f091 0f00 	teq	r1, #0
 80a6afc:	bf04      	itt	eq
 80a6afe:	4601      	moveq	r1, r0
 80a6b00:	2000      	moveq	r0, #0
 80a6b02:	fab1 f381 	clz	r3, r1
 80a6b06:	bf08      	it	eq
 80a6b08:	3320      	addeq	r3, #32
 80a6b0a:	f1a3 030b 	sub.w	r3, r3, #11
 80a6b0e:	f1b3 0220 	subs.w	r2, r3, #32
 80a6b12:	da0c      	bge.n	80a6b2e <__adddf3+0x16e>
 80a6b14:	320c      	adds	r2, #12
 80a6b16:	dd08      	ble.n	80a6b2a <__adddf3+0x16a>
 80a6b18:	f102 0c14 	add.w	ip, r2, #20
 80a6b1c:	f1c2 020c 	rsb	r2, r2, #12
 80a6b20:	fa01 f00c 	lsl.w	r0, r1, ip
 80a6b24:	fa21 f102 	lsr.w	r1, r1, r2
 80a6b28:	e00c      	b.n	80a6b44 <__adddf3+0x184>
 80a6b2a:	f102 0214 	add.w	r2, r2, #20
 80a6b2e:	bfd8      	it	le
 80a6b30:	f1c2 0c20 	rsble	ip, r2, #32
 80a6b34:	fa01 f102 	lsl.w	r1, r1, r2
 80a6b38:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a6b3c:	bfdc      	itt	le
 80a6b3e:	ea41 010c 	orrle.w	r1, r1, ip
 80a6b42:	4090      	lslle	r0, r2
 80a6b44:	1ae4      	subs	r4, r4, r3
 80a6b46:	bfa2      	ittt	ge
 80a6b48:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a6b4c:	4329      	orrge	r1, r5
 80a6b4e:	bd30      	popge	{r4, r5, pc}
 80a6b50:	ea6f 0404 	mvn.w	r4, r4
 80a6b54:	3c1f      	subs	r4, #31
 80a6b56:	da1c      	bge.n	80a6b92 <__adddf3+0x1d2>
 80a6b58:	340c      	adds	r4, #12
 80a6b5a:	dc0e      	bgt.n	80a6b7a <__adddf3+0x1ba>
 80a6b5c:	f104 0414 	add.w	r4, r4, #20
 80a6b60:	f1c4 0220 	rsb	r2, r4, #32
 80a6b64:	fa20 f004 	lsr.w	r0, r0, r4
 80a6b68:	fa01 f302 	lsl.w	r3, r1, r2
 80a6b6c:	ea40 0003 	orr.w	r0, r0, r3
 80a6b70:	fa21 f304 	lsr.w	r3, r1, r4
 80a6b74:	ea45 0103 	orr.w	r1, r5, r3
 80a6b78:	bd30      	pop	{r4, r5, pc}
 80a6b7a:	f1c4 040c 	rsb	r4, r4, #12
 80a6b7e:	f1c4 0220 	rsb	r2, r4, #32
 80a6b82:	fa20 f002 	lsr.w	r0, r0, r2
 80a6b86:	fa01 f304 	lsl.w	r3, r1, r4
 80a6b8a:	ea40 0003 	orr.w	r0, r0, r3
 80a6b8e:	4629      	mov	r1, r5
 80a6b90:	bd30      	pop	{r4, r5, pc}
 80a6b92:	fa21 f004 	lsr.w	r0, r1, r4
 80a6b96:	4629      	mov	r1, r5
 80a6b98:	bd30      	pop	{r4, r5, pc}
 80a6b9a:	f094 0f00 	teq	r4, #0
 80a6b9e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a6ba2:	bf06      	itte	eq
 80a6ba4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a6ba8:	3401      	addeq	r4, #1
 80a6baa:	3d01      	subne	r5, #1
 80a6bac:	e74e      	b.n	80a6a4c <__adddf3+0x8c>
 80a6bae:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a6bb2:	bf18      	it	ne
 80a6bb4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a6bb8:	d029      	beq.n	80a6c0e <__adddf3+0x24e>
 80a6bba:	ea94 0f05 	teq	r4, r5
 80a6bbe:	bf08      	it	eq
 80a6bc0:	ea90 0f02 	teqeq	r0, r2
 80a6bc4:	d005      	beq.n	80a6bd2 <__adddf3+0x212>
 80a6bc6:	ea54 0c00 	orrs.w	ip, r4, r0
 80a6bca:	bf04      	itt	eq
 80a6bcc:	4619      	moveq	r1, r3
 80a6bce:	4610      	moveq	r0, r2
 80a6bd0:	bd30      	pop	{r4, r5, pc}
 80a6bd2:	ea91 0f03 	teq	r1, r3
 80a6bd6:	bf1e      	ittt	ne
 80a6bd8:	2100      	movne	r1, #0
 80a6bda:	2000      	movne	r0, #0
 80a6bdc:	bd30      	popne	{r4, r5, pc}
 80a6bde:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a6be2:	d105      	bne.n	80a6bf0 <__adddf3+0x230>
 80a6be4:	0040      	lsls	r0, r0, #1
 80a6be6:	4149      	adcs	r1, r1
 80a6be8:	bf28      	it	cs
 80a6bea:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a6bee:	bd30      	pop	{r4, r5, pc}
 80a6bf0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a6bf4:	bf3c      	itt	cc
 80a6bf6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a6bfa:	bd30      	popcc	{r4, r5, pc}
 80a6bfc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a6c00:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a6c04:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a6c08:	f04f 0000 	mov.w	r0, #0
 80a6c0c:	bd30      	pop	{r4, r5, pc}
 80a6c0e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a6c12:	bf1a      	itte	ne
 80a6c14:	4619      	movne	r1, r3
 80a6c16:	4610      	movne	r0, r2
 80a6c18:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a6c1c:	bf1c      	itt	ne
 80a6c1e:	460b      	movne	r3, r1
 80a6c20:	4602      	movne	r2, r0
 80a6c22:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a6c26:	bf06      	itte	eq
 80a6c28:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a6c2c:	ea91 0f03 	teqeq	r1, r3
 80a6c30:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a6c34:	bd30      	pop	{r4, r5, pc}
 80a6c36:	bf00      	nop

080a6c38 <__aeabi_ui2d>:
 80a6c38:	f090 0f00 	teq	r0, #0
 80a6c3c:	bf04      	itt	eq
 80a6c3e:	2100      	moveq	r1, #0
 80a6c40:	4770      	bxeq	lr
 80a6c42:	b530      	push	{r4, r5, lr}
 80a6c44:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a6c48:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a6c4c:	f04f 0500 	mov.w	r5, #0
 80a6c50:	f04f 0100 	mov.w	r1, #0
 80a6c54:	e750      	b.n	80a6af8 <__adddf3+0x138>
 80a6c56:	bf00      	nop

080a6c58 <__aeabi_i2d>:
 80a6c58:	f090 0f00 	teq	r0, #0
 80a6c5c:	bf04      	itt	eq
 80a6c5e:	2100      	moveq	r1, #0
 80a6c60:	4770      	bxeq	lr
 80a6c62:	b530      	push	{r4, r5, lr}
 80a6c64:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a6c68:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a6c6c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a6c70:	bf48      	it	mi
 80a6c72:	4240      	negmi	r0, r0
 80a6c74:	f04f 0100 	mov.w	r1, #0
 80a6c78:	e73e      	b.n	80a6af8 <__adddf3+0x138>
 80a6c7a:	bf00      	nop

080a6c7c <__aeabi_f2d>:
 80a6c7c:	0042      	lsls	r2, r0, #1
 80a6c7e:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a6c82:	ea4f 0131 	mov.w	r1, r1, rrx
 80a6c86:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a6c8a:	bf1f      	itttt	ne
 80a6c8c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a6c90:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a6c94:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a6c98:	4770      	bxne	lr
 80a6c9a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80a6c9e:	bf08      	it	eq
 80a6ca0:	4770      	bxeq	lr
 80a6ca2:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80a6ca6:	bf04      	itt	eq
 80a6ca8:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80a6cac:	4770      	bxeq	lr
 80a6cae:	b530      	push	{r4, r5, lr}
 80a6cb0:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a6cb4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a6cb8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a6cbc:	e71c      	b.n	80a6af8 <__adddf3+0x138>
 80a6cbe:	bf00      	nop

080a6cc0 <__aeabi_ul2d>:
 80a6cc0:	ea50 0201 	orrs.w	r2, r0, r1
 80a6cc4:	bf08      	it	eq
 80a6cc6:	4770      	bxeq	lr
 80a6cc8:	b530      	push	{r4, r5, lr}
 80a6cca:	f04f 0500 	mov.w	r5, #0
 80a6cce:	e00a      	b.n	80a6ce6 <__aeabi_l2d+0x16>

080a6cd0 <__aeabi_l2d>:
 80a6cd0:	ea50 0201 	orrs.w	r2, r0, r1
 80a6cd4:	bf08      	it	eq
 80a6cd6:	4770      	bxeq	lr
 80a6cd8:	b530      	push	{r4, r5, lr}
 80a6cda:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a6cde:	d502      	bpl.n	80a6ce6 <__aeabi_l2d+0x16>
 80a6ce0:	4240      	negs	r0, r0
 80a6ce2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a6ce6:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a6cea:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a6cee:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a6cf2:	f43f aed8 	beq.w	80a6aa6 <__adddf3+0xe6>
 80a6cf6:	f04f 0203 	mov.w	r2, #3
 80a6cfa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a6cfe:	bf18      	it	ne
 80a6d00:	3203      	addne	r2, #3
 80a6d02:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a6d06:	bf18      	it	ne
 80a6d08:	3203      	addne	r2, #3
 80a6d0a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a6d0e:	f1c2 0320 	rsb	r3, r2, #32
 80a6d12:	fa00 fc03 	lsl.w	ip, r0, r3
 80a6d16:	fa20 f002 	lsr.w	r0, r0, r2
 80a6d1a:	fa01 fe03 	lsl.w	lr, r1, r3
 80a6d1e:	ea40 000e 	orr.w	r0, r0, lr
 80a6d22:	fa21 f102 	lsr.w	r1, r1, r2
 80a6d26:	4414      	add	r4, r2
 80a6d28:	e6bd      	b.n	80a6aa6 <__adddf3+0xe6>
 80a6d2a:	bf00      	nop

080a6d2c <__aeabi_dmul>:
 80a6d2c:	b570      	push	{r4, r5, r6, lr}
 80a6d2e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a6d32:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a6d36:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a6d3a:	bf1d      	ittte	ne
 80a6d3c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a6d40:	ea94 0f0c 	teqne	r4, ip
 80a6d44:	ea95 0f0c 	teqne	r5, ip
 80a6d48:	f000 f8de 	bleq	80a6f08 <__aeabi_dmul+0x1dc>
 80a6d4c:	442c      	add	r4, r5
 80a6d4e:	ea81 0603 	eor.w	r6, r1, r3
 80a6d52:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80a6d56:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80a6d5a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80a6d5e:	bf18      	it	ne
 80a6d60:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80a6d64:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a6d68:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a6d6c:	d038      	beq.n	80a6de0 <__aeabi_dmul+0xb4>
 80a6d6e:	fba0 ce02 	umull	ip, lr, r0, r2
 80a6d72:	f04f 0500 	mov.w	r5, #0
 80a6d76:	fbe1 e502 	umlal	lr, r5, r1, r2
 80a6d7a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80a6d7e:	fbe0 e503 	umlal	lr, r5, r0, r3
 80a6d82:	f04f 0600 	mov.w	r6, #0
 80a6d86:	fbe1 5603 	umlal	r5, r6, r1, r3
 80a6d8a:	f09c 0f00 	teq	ip, #0
 80a6d8e:	bf18      	it	ne
 80a6d90:	f04e 0e01 	orrne.w	lr, lr, #1
 80a6d94:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80a6d98:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a6d9c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80a6da0:	d204      	bcs.n	80a6dac <__aeabi_dmul+0x80>
 80a6da2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80a6da6:	416d      	adcs	r5, r5
 80a6da8:	eb46 0606 	adc.w	r6, r6, r6
 80a6dac:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80a6db0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80a6db4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80a6db8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80a6dbc:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80a6dc0:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a6dc4:	bf88      	it	hi
 80a6dc6:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a6dca:	d81e      	bhi.n	80a6e0a <__aeabi_dmul+0xde>
 80a6dcc:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80a6dd0:	bf08      	it	eq
 80a6dd2:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80a6dd6:	f150 0000 	adcs.w	r0, r0, #0
 80a6dda:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a6dde:	bd70      	pop	{r4, r5, r6, pc}
 80a6de0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80a6de4:	ea46 0101 	orr.w	r1, r6, r1
 80a6de8:	ea40 0002 	orr.w	r0, r0, r2
 80a6dec:	ea81 0103 	eor.w	r1, r1, r3
 80a6df0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80a6df4:	bfc2      	ittt	gt
 80a6df6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a6dfa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a6dfe:	bd70      	popgt	{r4, r5, r6, pc}
 80a6e00:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a6e04:	f04f 0e00 	mov.w	lr, #0
 80a6e08:	3c01      	subs	r4, #1
 80a6e0a:	f300 80ab 	bgt.w	80a6f64 <__aeabi_dmul+0x238>
 80a6e0e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80a6e12:	bfde      	ittt	le
 80a6e14:	2000      	movle	r0, #0
 80a6e16:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80a6e1a:	bd70      	pople	{r4, r5, r6, pc}
 80a6e1c:	f1c4 0400 	rsb	r4, r4, #0
 80a6e20:	3c20      	subs	r4, #32
 80a6e22:	da35      	bge.n	80a6e90 <__aeabi_dmul+0x164>
 80a6e24:	340c      	adds	r4, #12
 80a6e26:	dc1b      	bgt.n	80a6e60 <__aeabi_dmul+0x134>
 80a6e28:	f104 0414 	add.w	r4, r4, #20
 80a6e2c:	f1c4 0520 	rsb	r5, r4, #32
 80a6e30:	fa00 f305 	lsl.w	r3, r0, r5
 80a6e34:	fa20 f004 	lsr.w	r0, r0, r4
 80a6e38:	fa01 f205 	lsl.w	r2, r1, r5
 80a6e3c:	ea40 0002 	orr.w	r0, r0, r2
 80a6e40:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80a6e44:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a6e48:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a6e4c:	fa21 f604 	lsr.w	r6, r1, r4
 80a6e50:	eb42 0106 	adc.w	r1, r2, r6
 80a6e54:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a6e58:	bf08      	it	eq
 80a6e5a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a6e5e:	bd70      	pop	{r4, r5, r6, pc}
 80a6e60:	f1c4 040c 	rsb	r4, r4, #12
 80a6e64:	f1c4 0520 	rsb	r5, r4, #32
 80a6e68:	fa00 f304 	lsl.w	r3, r0, r4
 80a6e6c:	fa20 f005 	lsr.w	r0, r0, r5
 80a6e70:	fa01 f204 	lsl.w	r2, r1, r4
 80a6e74:	ea40 0002 	orr.w	r0, r0, r2
 80a6e78:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a6e7c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a6e80:	f141 0100 	adc.w	r1, r1, #0
 80a6e84:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a6e88:	bf08      	it	eq
 80a6e8a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a6e8e:	bd70      	pop	{r4, r5, r6, pc}
 80a6e90:	f1c4 0520 	rsb	r5, r4, #32
 80a6e94:	fa00 f205 	lsl.w	r2, r0, r5
 80a6e98:	ea4e 0e02 	orr.w	lr, lr, r2
 80a6e9c:	fa20 f304 	lsr.w	r3, r0, r4
 80a6ea0:	fa01 f205 	lsl.w	r2, r1, r5
 80a6ea4:	ea43 0302 	orr.w	r3, r3, r2
 80a6ea8:	fa21 f004 	lsr.w	r0, r1, r4
 80a6eac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a6eb0:	fa21 f204 	lsr.w	r2, r1, r4
 80a6eb4:	ea20 0002 	bic.w	r0, r0, r2
 80a6eb8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80a6ebc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a6ec0:	bf08      	it	eq
 80a6ec2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a6ec6:	bd70      	pop	{r4, r5, r6, pc}
 80a6ec8:	f094 0f00 	teq	r4, #0
 80a6ecc:	d10f      	bne.n	80a6eee <__aeabi_dmul+0x1c2>
 80a6ece:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80a6ed2:	0040      	lsls	r0, r0, #1
 80a6ed4:	eb41 0101 	adc.w	r1, r1, r1
 80a6ed8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a6edc:	bf08      	it	eq
 80a6ede:	3c01      	subeq	r4, #1
 80a6ee0:	d0f7      	beq.n	80a6ed2 <__aeabi_dmul+0x1a6>
 80a6ee2:	ea41 0106 	orr.w	r1, r1, r6
 80a6ee6:	f095 0f00 	teq	r5, #0
 80a6eea:	bf18      	it	ne
 80a6eec:	4770      	bxne	lr
 80a6eee:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80a6ef2:	0052      	lsls	r2, r2, #1
 80a6ef4:	eb43 0303 	adc.w	r3, r3, r3
 80a6ef8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80a6efc:	bf08      	it	eq
 80a6efe:	3d01      	subeq	r5, #1
 80a6f00:	d0f7      	beq.n	80a6ef2 <__aeabi_dmul+0x1c6>
 80a6f02:	ea43 0306 	orr.w	r3, r3, r6
 80a6f06:	4770      	bx	lr
 80a6f08:	ea94 0f0c 	teq	r4, ip
 80a6f0c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a6f10:	bf18      	it	ne
 80a6f12:	ea95 0f0c 	teqne	r5, ip
 80a6f16:	d00c      	beq.n	80a6f32 <__aeabi_dmul+0x206>
 80a6f18:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a6f1c:	bf18      	it	ne
 80a6f1e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a6f22:	d1d1      	bne.n	80a6ec8 <__aeabi_dmul+0x19c>
 80a6f24:	ea81 0103 	eor.w	r1, r1, r3
 80a6f28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a6f2c:	f04f 0000 	mov.w	r0, #0
 80a6f30:	bd70      	pop	{r4, r5, r6, pc}
 80a6f32:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a6f36:	bf06      	itte	eq
 80a6f38:	4610      	moveq	r0, r2
 80a6f3a:	4619      	moveq	r1, r3
 80a6f3c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a6f40:	d019      	beq.n	80a6f76 <__aeabi_dmul+0x24a>
 80a6f42:	ea94 0f0c 	teq	r4, ip
 80a6f46:	d102      	bne.n	80a6f4e <__aeabi_dmul+0x222>
 80a6f48:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80a6f4c:	d113      	bne.n	80a6f76 <__aeabi_dmul+0x24a>
 80a6f4e:	ea95 0f0c 	teq	r5, ip
 80a6f52:	d105      	bne.n	80a6f60 <__aeabi_dmul+0x234>
 80a6f54:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80a6f58:	bf1c      	itt	ne
 80a6f5a:	4610      	movne	r0, r2
 80a6f5c:	4619      	movne	r1, r3
 80a6f5e:	d10a      	bne.n	80a6f76 <__aeabi_dmul+0x24a>
 80a6f60:	ea81 0103 	eor.w	r1, r1, r3
 80a6f64:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a6f68:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a6f6c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a6f70:	f04f 0000 	mov.w	r0, #0
 80a6f74:	bd70      	pop	{r4, r5, r6, pc}
 80a6f76:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a6f7a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80a6f7e:	bd70      	pop	{r4, r5, r6, pc}

080a6f80 <__aeabi_ddiv>:
 80a6f80:	b570      	push	{r4, r5, r6, lr}
 80a6f82:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a6f86:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a6f8a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a6f8e:	bf1d      	ittte	ne
 80a6f90:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a6f94:	ea94 0f0c 	teqne	r4, ip
 80a6f98:	ea95 0f0c 	teqne	r5, ip
 80a6f9c:	f000 f8a7 	bleq	80a70ee <__aeabi_ddiv+0x16e>
 80a6fa0:	eba4 0405 	sub.w	r4, r4, r5
 80a6fa4:	ea81 0e03 	eor.w	lr, r1, r3
 80a6fa8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a6fac:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a6fb0:	f000 8088 	beq.w	80a70c4 <__aeabi_ddiv+0x144>
 80a6fb4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a6fb8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80a6fbc:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80a6fc0:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80a6fc4:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80a6fc8:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80a6fcc:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80a6fd0:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80a6fd4:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80a6fd8:	429d      	cmp	r5, r3
 80a6fda:	bf08      	it	eq
 80a6fdc:	4296      	cmpeq	r6, r2
 80a6fde:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80a6fe2:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80a6fe6:	d202      	bcs.n	80a6fee <__aeabi_ddiv+0x6e>
 80a6fe8:	085b      	lsrs	r3, r3, #1
 80a6fea:	ea4f 0232 	mov.w	r2, r2, rrx
 80a6fee:	1ab6      	subs	r6, r6, r2
 80a6ff0:	eb65 0503 	sbc.w	r5, r5, r3
 80a6ff4:	085b      	lsrs	r3, r3, #1
 80a6ff6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a6ffa:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80a6ffe:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80a7002:	ebb6 0e02 	subs.w	lr, r6, r2
 80a7006:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a700a:	bf22      	ittt	cs
 80a700c:	1ab6      	subcs	r6, r6, r2
 80a700e:	4675      	movcs	r5, lr
 80a7010:	ea40 000c 	orrcs.w	r0, r0, ip
 80a7014:	085b      	lsrs	r3, r3, #1
 80a7016:	ea4f 0232 	mov.w	r2, r2, rrx
 80a701a:	ebb6 0e02 	subs.w	lr, r6, r2
 80a701e:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a7022:	bf22      	ittt	cs
 80a7024:	1ab6      	subcs	r6, r6, r2
 80a7026:	4675      	movcs	r5, lr
 80a7028:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a702c:	085b      	lsrs	r3, r3, #1
 80a702e:	ea4f 0232 	mov.w	r2, r2, rrx
 80a7032:	ebb6 0e02 	subs.w	lr, r6, r2
 80a7036:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a703a:	bf22      	ittt	cs
 80a703c:	1ab6      	subcs	r6, r6, r2
 80a703e:	4675      	movcs	r5, lr
 80a7040:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a7044:	085b      	lsrs	r3, r3, #1
 80a7046:	ea4f 0232 	mov.w	r2, r2, rrx
 80a704a:	ebb6 0e02 	subs.w	lr, r6, r2
 80a704e:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a7052:	bf22      	ittt	cs
 80a7054:	1ab6      	subcs	r6, r6, r2
 80a7056:	4675      	movcs	r5, lr
 80a7058:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a705c:	ea55 0e06 	orrs.w	lr, r5, r6
 80a7060:	d018      	beq.n	80a7094 <__aeabi_ddiv+0x114>
 80a7062:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80a7066:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80a706a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80a706e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80a7072:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80a7076:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80a707a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80a707e:	d1c0      	bne.n	80a7002 <__aeabi_ddiv+0x82>
 80a7080:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a7084:	d10b      	bne.n	80a709e <__aeabi_ddiv+0x11e>
 80a7086:	ea41 0100 	orr.w	r1, r1, r0
 80a708a:	f04f 0000 	mov.w	r0, #0
 80a708e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80a7092:	e7b6      	b.n	80a7002 <__aeabi_ddiv+0x82>
 80a7094:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a7098:	bf04      	itt	eq
 80a709a:	4301      	orreq	r1, r0
 80a709c:	2000      	moveq	r0, #0
 80a709e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a70a2:	bf88      	it	hi
 80a70a4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a70a8:	f63f aeaf 	bhi.w	80a6e0a <__aeabi_dmul+0xde>
 80a70ac:	ebb5 0c03 	subs.w	ip, r5, r3
 80a70b0:	bf04      	itt	eq
 80a70b2:	ebb6 0c02 	subseq.w	ip, r6, r2
 80a70b6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a70ba:	f150 0000 	adcs.w	r0, r0, #0
 80a70be:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a70c2:	bd70      	pop	{r4, r5, r6, pc}
 80a70c4:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80a70c8:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80a70cc:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80a70d0:	bfc2      	ittt	gt
 80a70d2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a70d6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a70da:	bd70      	popgt	{r4, r5, r6, pc}
 80a70dc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a70e0:	f04f 0e00 	mov.w	lr, #0
 80a70e4:	3c01      	subs	r4, #1
 80a70e6:	e690      	b.n	80a6e0a <__aeabi_dmul+0xde>
 80a70e8:	ea45 0e06 	orr.w	lr, r5, r6
 80a70ec:	e68d      	b.n	80a6e0a <__aeabi_dmul+0xde>
 80a70ee:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a70f2:	ea94 0f0c 	teq	r4, ip
 80a70f6:	bf08      	it	eq
 80a70f8:	ea95 0f0c 	teqeq	r5, ip
 80a70fc:	f43f af3b 	beq.w	80a6f76 <__aeabi_dmul+0x24a>
 80a7100:	ea94 0f0c 	teq	r4, ip
 80a7104:	d10a      	bne.n	80a711c <__aeabi_ddiv+0x19c>
 80a7106:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a710a:	f47f af34 	bne.w	80a6f76 <__aeabi_dmul+0x24a>
 80a710e:	ea95 0f0c 	teq	r5, ip
 80a7112:	f47f af25 	bne.w	80a6f60 <__aeabi_dmul+0x234>
 80a7116:	4610      	mov	r0, r2
 80a7118:	4619      	mov	r1, r3
 80a711a:	e72c      	b.n	80a6f76 <__aeabi_dmul+0x24a>
 80a711c:	ea95 0f0c 	teq	r5, ip
 80a7120:	d106      	bne.n	80a7130 <__aeabi_ddiv+0x1b0>
 80a7122:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a7126:	f43f aefd 	beq.w	80a6f24 <__aeabi_dmul+0x1f8>
 80a712a:	4610      	mov	r0, r2
 80a712c:	4619      	mov	r1, r3
 80a712e:	e722      	b.n	80a6f76 <__aeabi_dmul+0x24a>
 80a7130:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a7134:	bf18      	it	ne
 80a7136:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a713a:	f47f aec5 	bne.w	80a6ec8 <__aeabi_dmul+0x19c>
 80a713e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80a7142:	f47f af0d 	bne.w	80a6f60 <__aeabi_dmul+0x234>
 80a7146:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80a714a:	f47f aeeb 	bne.w	80a6f24 <__aeabi_dmul+0x1f8>
 80a714e:	e712      	b.n	80a6f76 <__aeabi_dmul+0x24a>

080a7150 <__aeabi_dcmpun>:
 80a7150:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a7154:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a7158:	d102      	bne.n	80a7160 <__aeabi_dcmpun+0x10>
 80a715a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a715e:	d10a      	bne.n	80a7176 <__aeabi_dcmpun+0x26>
 80a7160:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a7164:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a7168:	d102      	bne.n	80a7170 <__aeabi_dcmpun+0x20>
 80a716a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a716e:	d102      	bne.n	80a7176 <__aeabi_dcmpun+0x26>
 80a7170:	f04f 0000 	mov.w	r0, #0
 80a7174:	4770      	bx	lr
 80a7176:	f04f 0001 	mov.w	r0, #1
 80a717a:	4770      	bx	lr

080a717c <__aeabi_d2iz>:
 80a717c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a7180:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a7184:	d215      	bcs.n	80a71b2 <__aeabi_d2iz+0x36>
 80a7186:	d511      	bpl.n	80a71ac <__aeabi_d2iz+0x30>
 80a7188:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a718c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a7190:	d912      	bls.n	80a71b8 <__aeabi_d2iz+0x3c>
 80a7192:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a7196:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a719a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a719e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a71a2:	fa23 f002 	lsr.w	r0, r3, r2
 80a71a6:	bf18      	it	ne
 80a71a8:	4240      	negne	r0, r0
 80a71aa:	4770      	bx	lr
 80a71ac:	f04f 0000 	mov.w	r0, #0
 80a71b0:	4770      	bx	lr
 80a71b2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a71b6:	d105      	bne.n	80a71c4 <__aeabi_d2iz+0x48>
 80a71b8:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80a71bc:	bf08      	it	eq
 80a71be:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a71c2:	4770      	bx	lr
 80a71c4:	f04f 0000 	mov.w	r0, #0
 80a71c8:	4770      	bx	lr
 80a71ca:	bf00      	nop

080a71cc <__aeabi_d2f>:
 80a71cc:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a71d0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80a71d4:	bf24      	itt	cs
 80a71d6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80a71da:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80a71de:	d90d      	bls.n	80a71fc <__aeabi_d2f+0x30>
 80a71e0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a71e4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80a71e8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80a71ec:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80a71f0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80a71f4:	bf08      	it	eq
 80a71f6:	f020 0001 	biceq.w	r0, r0, #1
 80a71fa:	4770      	bx	lr
 80a71fc:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80a7200:	d121      	bne.n	80a7246 <__aeabi_d2f+0x7a>
 80a7202:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80a7206:	bfbc      	itt	lt
 80a7208:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80a720c:	4770      	bxlt	lr
 80a720e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a7212:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80a7216:	f1c2 0218 	rsb	r2, r2, #24
 80a721a:	f1c2 0c20 	rsb	ip, r2, #32
 80a721e:	fa10 f30c 	lsls.w	r3, r0, ip
 80a7222:	fa20 f002 	lsr.w	r0, r0, r2
 80a7226:	bf18      	it	ne
 80a7228:	f040 0001 	orrne.w	r0, r0, #1
 80a722c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a7230:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80a7234:	fa03 fc0c 	lsl.w	ip, r3, ip
 80a7238:	ea40 000c 	orr.w	r0, r0, ip
 80a723c:	fa23 f302 	lsr.w	r3, r3, r2
 80a7240:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80a7244:	e7cc      	b.n	80a71e0 <__aeabi_d2f+0x14>
 80a7246:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80a724a:	d107      	bne.n	80a725c <__aeabi_d2f+0x90>
 80a724c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80a7250:	bf1e      	ittt	ne
 80a7252:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 80a7256:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 80a725a:	4770      	bxne	lr
 80a725c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 80a7260:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a7264:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a7268:	4770      	bx	lr
 80a726a:	bf00      	nop

080a726c <__aeabi_frsub>:
 80a726c:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a7270:	e002      	b.n	80a7278 <__addsf3>
 80a7272:	bf00      	nop

080a7274 <__aeabi_fsub>:
 80a7274:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a7278 <__addsf3>:
 80a7278:	0042      	lsls	r2, r0, #1
 80a727a:	bf1f      	itttt	ne
 80a727c:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a7280:	ea92 0f03 	teqne	r2, r3
 80a7284:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a7288:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a728c:	d06a      	beq.n	80a7364 <__addsf3+0xec>
 80a728e:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a7292:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a7296:	bfc1      	itttt	gt
 80a7298:	18d2      	addgt	r2, r2, r3
 80a729a:	4041      	eorgt	r1, r0
 80a729c:	4048      	eorgt	r0, r1
 80a729e:	4041      	eorgt	r1, r0
 80a72a0:	bfb8      	it	lt
 80a72a2:	425b      	neglt	r3, r3
 80a72a4:	2b19      	cmp	r3, #25
 80a72a6:	bf88      	it	hi
 80a72a8:	4770      	bxhi	lr
 80a72aa:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a72ae:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a72b2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a72b6:	bf18      	it	ne
 80a72b8:	4240      	negne	r0, r0
 80a72ba:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a72be:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a72c2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a72c6:	bf18      	it	ne
 80a72c8:	4249      	negne	r1, r1
 80a72ca:	ea92 0f03 	teq	r2, r3
 80a72ce:	d03f      	beq.n	80a7350 <__addsf3+0xd8>
 80a72d0:	f1a2 0201 	sub.w	r2, r2, #1
 80a72d4:	fa41 fc03 	asr.w	ip, r1, r3
 80a72d8:	eb10 000c 	adds.w	r0, r0, ip
 80a72dc:	f1c3 0320 	rsb	r3, r3, #32
 80a72e0:	fa01 f103 	lsl.w	r1, r1, r3
 80a72e4:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a72e8:	d502      	bpl.n	80a72f0 <__addsf3+0x78>
 80a72ea:	4249      	negs	r1, r1
 80a72ec:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a72f0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a72f4:	d313      	bcc.n	80a731e <__addsf3+0xa6>
 80a72f6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a72fa:	d306      	bcc.n	80a730a <__addsf3+0x92>
 80a72fc:	0840      	lsrs	r0, r0, #1
 80a72fe:	ea4f 0131 	mov.w	r1, r1, rrx
 80a7302:	f102 0201 	add.w	r2, r2, #1
 80a7306:	2afe      	cmp	r2, #254	; 0xfe
 80a7308:	d251      	bcs.n	80a73ae <__addsf3+0x136>
 80a730a:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a730e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a7312:	bf08      	it	eq
 80a7314:	f020 0001 	biceq.w	r0, r0, #1
 80a7318:	ea40 0003 	orr.w	r0, r0, r3
 80a731c:	4770      	bx	lr
 80a731e:	0049      	lsls	r1, r1, #1
 80a7320:	eb40 0000 	adc.w	r0, r0, r0
 80a7324:	3a01      	subs	r2, #1
 80a7326:	bf28      	it	cs
 80a7328:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 80a732c:	d2ed      	bcs.n	80a730a <__addsf3+0x92>
 80a732e:	fab0 fc80 	clz	ip, r0
 80a7332:	f1ac 0c08 	sub.w	ip, ip, #8
 80a7336:	ebb2 020c 	subs.w	r2, r2, ip
 80a733a:	fa00 f00c 	lsl.w	r0, r0, ip
 80a733e:	bfaa      	itet	ge
 80a7340:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a7344:	4252      	neglt	r2, r2
 80a7346:	4318      	orrge	r0, r3
 80a7348:	bfbc      	itt	lt
 80a734a:	40d0      	lsrlt	r0, r2
 80a734c:	4318      	orrlt	r0, r3
 80a734e:	4770      	bx	lr
 80a7350:	f092 0f00 	teq	r2, #0
 80a7354:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a7358:	bf06      	itte	eq
 80a735a:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a735e:	3201      	addeq	r2, #1
 80a7360:	3b01      	subne	r3, #1
 80a7362:	e7b5      	b.n	80a72d0 <__addsf3+0x58>
 80a7364:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a7368:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a736c:	bf18      	it	ne
 80a736e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a7372:	d021      	beq.n	80a73b8 <__addsf3+0x140>
 80a7374:	ea92 0f03 	teq	r2, r3
 80a7378:	d004      	beq.n	80a7384 <__addsf3+0x10c>
 80a737a:	f092 0f00 	teq	r2, #0
 80a737e:	bf08      	it	eq
 80a7380:	4608      	moveq	r0, r1
 80a7382:	4770      	bx	lr
 80a7384:	ea90 0f01 	teq	r0, r1
 80a7388:	bf1c      	itt	ne
 80a738a:	2000      	movne	r0, #0
 80a738c:	4770      	bxne	lr
 80a738e:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a7392:	d104      	bne.n	80a739e <__addsf3+0x126>
 80a7394:	0040      	lsls	r0, r0, #1
 80a7396:	bf28      	it	cs
 80a7398:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a739c:	4770      	bx	lr
 80a739e:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a73a2:	bf3c      	itt	cc
 80a73a4:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a73a8:	4770      	bxcc	lr
 80a73aa:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a73ae:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a73b2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a73b6:	4770      	bx	lr
 80a73b8:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a73bc:	bf16      	itet	ne
 80a73be:	4608      	movne	r0, r1
 80a73c0:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a73c4:	4601      	movne	r1, r0
 80a73c6:	0242      	lsls	r2, r0, #9
 80a73c8:	bf06      	itte	eq
 80a73ca:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a73ce:	ea90 0f01 	teqeq	r0, r1
 80a73d2:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a73d6:	4770      	bx	lr

080a73d8 <__aeabi_ui2f>:
 80a73d8:	f04f 0300 	mov.w	r3, #0
 80a73dc:	e004      	b.n	80a73e8 <__aeabi_i2f+0x8>
 80a73de:	bf00      	nop

080a73e0 <__aeabi_i2f>:
 80a73e0:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a73e4:	bf48      	it	mi
 80a73e6:	4240      	negmi	r0, r0
 80a73e8:	ea5f 0c00 	movs.w	ip, r0
 80a73ec:	bf08      	it	eq
 80a73ee:	4770      	bxeq	lr
 80a73f0:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a73f4:	4601      	mov	r1, r0
 80a73f6:	f04f 0000 	mov.w	r0, #0
 80a73fa:	e01c      	b.n	80a7436 <__aeabi_l2f+0x2a>

080a73fc <__aeabi_ul2f>:
 80a73fc:	ea50 0201 	orrs.w	r2, r0, r1
 80a7400:	bf08      	it	eq
 80a7402:	4770      	bxeq	lr
 80a7404:	f04f 0300 	mov.w	r3, #0
 80a7408:	e00a      	b.n	80a7420 <__aeabi_l2f+0x14>
 80a740a:	bf00      	nop

080a740c <__aeabi_l2f>:
 80a740c:	ea50 0201 	orrs.w	r2, r0, r1
 80a7410:	bf08      	it	eq
 80a7412:	4770      	bxeq	lr
 80a7414:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a7418:	d502      	bpl.n	80a7420 <__aeabi_l2f+0x14>
 80a741a:	4240      	negs	r0, r0
 80a741c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a7420:	ea5f 0c01 	movs.w	ip, r1
 80a7424:	bf02      	ittt	eq
 80a7426:	4684      	moveq	ip, r0
 80a7428:	4601      	moveq	r1, r0
 80a742a:	2000      	moveq	r0, #0
 80a742c:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a7430:	bf08      	it	eq
 80a7432:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a7436:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a743a:	fabc f28c 	clz	r2, ip
 80a743e:	3a08      	subs	r2, #8
 80a7440:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a7444:	db10      	blt.n	80a7468 <__aeabi_l2f+0x5c>
 80a7446:	fa01 fc02 	lsl.w	ip, r1, r2
 80a744a:	4463      	add	r3, ip
 80a744c:	fa00 fc02 	lsl.w	ip, r0, r2
 80a7450:	f1c2 0220 	rsb	r2, r2, #32
 80a7454:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a7458:	fa20 f202 	lsr.w	r2, r0, r2
 80a745c:	eb43 0002 	adc.w	r0, r3, r2
 80a7460:	bf08      	it	eq
 80a7462:	f020 0001 	biceq.w	r0, r0, #1
 80a7466:	4770      	bx	lr
 80a7468:	f102 0220 	add.w	r2, r2, #32
 80a746c:	fa01 fc02 	lsl.w	ip, r1, r2
 80a7470:	f1c2 0220 	rsb	r2, r2, #32
 80a7474:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a7478:	fa21 f202 	lsr.w	r2, r1, r2
 80a747c:	eb43 0002 	adc.w	r0, r3, r2
 80a7480:	bf08      	it	eq
 80a7482:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a7486:	4770      	bx	lr

080a7488 <__aeabi_fmul>:
 80a7488:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a748c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a7490:	bf1e      	ittt	ne
 80a7492:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a7496:	ea92 0f0c 	teqne	r2, ip
 80a749a:	ea93 0f0c 	teqne	r3, ip
 80a749e:	d06f      	beq.n	80a7580 <__aeabi_fmul+0xf8>
 80a74a0:	441a      	add	r2, r3
 80a74a2:	ea80 0c01 	eor.w	ip, r0, r1
 80a74a6:	0240      	lsls	r0, r0, #9
 80a74a8:	bf18      	it	ne
 80a74aa:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a74ae:	d01e      	beq.n	80a74ee <__aeabi_fmul+0x66>
 80a74b0:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a74b4:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a74b8:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a74bc:	fba0 3101 	umull	r3, r1, r0, r1
 80a74c0:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a74c4:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a74c8:	bf3e      	ittt	cc
 80a74ca:	0049      	lslcc	r1, r1, #1
 80a74cc:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a74d0:	005b      	lslcc	r3, r3, #1
 80a74d2:	ea40 0001 	orr.w	r0, r0, r1
 80a74d6:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a74da:	2afd      	cmp	r2, #253	; 0xfd
 80a74dc:	d81d      	bhi.n	80a751a <__aeabi_fmul+0x92>
 80a74de:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a74e2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a74e6:	bf08      	it	eq
 80a74e8:	f020 0001 	biceq.w	r0, r0, #1
 80a74ec:	4770      	bx	lr
 80a74ee:	f090 0f00 	teq	r0, #0
 80a74f2:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a74f6:	bf08      	it	eq
 80a74f8:	0249      	lsleq	r1, r1, #9
 80a74fa:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a74fe:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a7502:	3a7f      	subs	r2, #127	; 0x7f
 80a7504:	bfc2      	ittt	gt
 80a7506:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a750a:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a750e:	4770      	bxgt	lr
 80a7510:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a7514:	f04f 0300 	mov.w	r3, #0
 80a7518:	3a01      	subs	r2, #1
 80a751a:	dc5d      	bgt.n	80a75d8 <__aeabi_fmul+0x150>
 80a751c:	f112 0f19 	cmn.w	r2, #25
 80a7520:	bfdc      	itt	le
 80a7522:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a7526:	4770      	bxle	lr
 80a7528:	f1c2 0200 	rsb	r2, r2, #0
 80a752c:	0041      	lsls	r1, r0, #1
 80a752e:	fa21 f102 	lsr.w	r1, r1, r2
 80a7532:	f1c2 0220 	rsb	r2, r2, #32
 80a7536:	fa00 fc02 	lsl.w	ip, r0, r2
 80a753a:	ea5f 0031 	movs.w	r0, r1, rrx
 80a753e:	f140 0000 	adc.w	r0, r0, #0
 80a7542:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a7546:	bf08      	it	eq
 80a7548:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a754c:	4770      	bx	lr
 80a754e:	f092 0f00 	teq	r2, #0
 80a7552:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a7556:	bf02      	ittt	eq
 80a7558:	0040      	lsleq	r0, r0, #1
 80a755a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a755e:	3a01      	subeq	r2, #1
 80a7560:	d0f9      	beq.n	80a7556 <__aeabi_fmul+0xce>
 80a7562:	ea40 000c 	orr.w	r0, r0, ip
 80a7566:	f093 0f00 	teq	r3, #0
 80a756a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a756e:	bf02      	ittt	eq
 80a7570:	0049      	lsleq	r1, r1, #1
 80a7572:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a7576:	3b01      	subeq	r3, #1
 80a7578:	d0f9      	beq.n	80a756e <__aeabi_fmul+0xe6>
 80a757a:	ea41 010c 	orr.w	r1, r1, ip
 80a757e:	e78f      	b.n	80a74a0 <__aeabi_fmul+0x18>
 80a7580:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a7584:	ea92 0f0c 	teq	r2, ip
 80a7588:	bf18      	it	ne
 80a758a:	ea93 0f0c 	teqne	r3, ip
 80a758e:	d00a      	beq.n	80a75a6 <__aeabi_fmul+0x11e>
 80a7590:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a7594:	bf18      	it	ne
 80a7596:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a759a:	d1d8      	bne.n	80a754e <__aeabi_fmul+0xc6>
 80a759c:	ea80 0001 	eor.w	r0, r0, r1
 80a75a0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a75a4:	4770      	bx	lr
 80a75a6:	f090 0f00 	teq	r0, #0
 80a75aa:	bf17      	itett	ne
 80a75ac:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a75b0:	4608      	moveq	r0, r1
 80a75b2:	f091 0f00 	teqne	r1, #0
 80a75b6:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a75ba:	d014      	beq.n	80a75e6 <__aeabi_fmul+0x15e>
 80a75bc:	ea92 0f0c 	teq	r2, ip
 80a75c0:	d101      	bne.n	80a75c6 <__aeabi_fmul+0x13e>
 80a75c2:	0242      	lsls	r2, r0, #9
 80a75c4:	d10f      	bne.n	80a75e6 <__aeabi_fmul+0x15e>
 80a75c6:	ea93 0f0c 	teq	r3, ip
 80a75ca:	d103      	bne.n	80a75d4 <__aeabi_fmul+0x14c>
 80a75cc:	024b      	lsls	r3, r1, #9
 80a75ce:	bf18      	it	ne
 80a75d0:	4608      	movne	r0, r1
 80a75d2:	d108      	bne.n	80a75e6 <__aeabi_fmul+0x15e>
 80a75d4:	ea80 0001 	eor.w	r0, r0, r1
 80a75d8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a75dc:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a75e0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a75e4:	4770      	bx	lr
 80a75e6:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a75ea:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a75ee:	4770      	bx	lr

080a75f0 <__aeabi_fdiv>:
 80a75f0:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a75f4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a75f8:	bf1e      	ittt	ne
 80a75fa:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a75fe:	ea92 0f0c 	teqne	r2, ip
 80a7602:	ea93 0f0c 	teqne	r3, ip
 80a7606:	d069      	beq.n	80a76dc <__aeabi_fdiv+0xec>
 80a7608:	eba2 0203 	sub.w	r2, r2, r3
 80a760c:	ea80 0c01 	eor.w	ip, r0, r1
 80a7610:	0249      	lsls	r1, r1, #9
 80a7612:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a7616:	d037      	beq.n	80a7688 <__aeabi_fdiv+0x98>
 80a7618:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a761c:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a7620:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a7624:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a7628:	428b      	cmp	r3, r1
 80a762a:	bf38      	it	cc
 80a762c:	005b      	lslcc	r3, r3, #1
 80a762e:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a7632:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a7636:	428b      	cmp	r3, r1
 80a7638:	bf24      	itt	cs
 80a763a:	1a5b      	subcs	r3, r3, r1
 80a763c:	ea40 000c 	orrcs.w	r0, r0, ip
 80a7640:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a7644:	bf24      	itt	cs
 80a7646:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a764a:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a764e:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a7652:	bf24      	itt	cs
 80a7654:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a7658:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a765c:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a7660:	bf24      	itt	cs
 80a7662:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a7666:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a766a:	011b      	lsls	r3, r3, #4
 80a766c:	bf18      	it	ne
 80a766e:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a7672:	d1e0      	bne.n	80a7636 <__aeabi_fdiv+0x46>
 80a7674:	2afd      	cmp	r2, #253	; 0xfd
 80a7676:	f63f af50 	bhi.w	80a751a <__aeabi_fmul+0x92>
 80a767a:	428b      	cmp	r3, r1
 80a767c:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a7680:	bf08      	it	eq
 80a7682:	f020 0001 	biceq.w	r0, r0, #1
 80a7686:	4770      	bx	lr
 80a7688:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a768c:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a7690:	327f      	adds	r2, #127	; 0x7f
 80a7692:	bfc2      	ittt	gt
 80a7694:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a7698:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a769c:	4770      	bxgt	lr
 80a769e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a76a2:	f04f 0300 	mov.w	r3, #0
 80a76a6:	3a01      	subs	r2, #1
 80a76a8:	e737      	b.n	80a751a <__aeabi_fmul+0x92>
 80a76aa:	f092 0f00 	teq	r2, #0
 80a76ae:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a76b2:	bf02      	ittt	eq
 80a76b4:	0040      	lsleq	r0, r0, #1
 80a76b6:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a76ba:	3a01      	subeq	r2, #1
 80a76bc:	d0f9      	beq.n	80a76b2 <__aeabi_fdiv+0xc2>
 80a76be:	ea40 000c 	orr.w	r0, r0, ip
 80a76c2:	f093 0f00 	teq	r3, #0
 80a76c6:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a76ca:	bf02      	ittt	eq
 80a76cc:	0049      	lsleq	r1, r1, #1
 80a76ce:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a76d2:	3b01      	subeq	r3, #1
 80a76d4:	d0f9      	beq.n	80a76ca <__aeabi_fdiv+0xda>
 80a76d6:	ea41 010c 	orr.w	r1, r1, ip
 80a76da:	e795      	b.n	80a7608 <__aeabi_fdiv+0x18>
 80a76dc:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a76e0:	ea92 0f0c 	teq	r2, ip
 80a76e4:	d108      	bne.n	80a76f8 <__aeabi_fdiv+0x108>
 80a76e6:	0242      	lsls	r2, r0, #9
 80a76e8:	f47f af7d 	bne.w	80a75e6 <__aeabi_fmul+0x15e>
 80a76ec:	ea93 0f0c 	teq	r3, ip
 80a76f0:	f47f af70 	bne.w	80a75d4 <__aeabi_fmul+0x14c>
 80a76f4:	4608      	mov	r0, r1
 80a76f6:	e776      	b.n	80a75e6 <__aeabi_fmul+0x15e>
 80a76f8:	ea93 0f0c 	teq	r3, ip
 80a76fc:	d104      	bne.n	80a7708 <__aeabi_fdiv+0x118>
 80a76fe:	024b      	lsls	r3, r1, #9
 80a7700:	f43f af4c 	beq.w	80a759c <__aeabi_fmul+0x114>
 80a7704:	4608      	mov	r0, r1
 80a7706:	e76e      	b.n	80a75e6 <__aeabi_fmul+0x15e>
 80a7708:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a770c:	bf18      	it	ne
 80a770e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a7712:	d1ca      	bne.n	80a76aa <__aeabi_fdiv+0xba>
 80a7714:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a7718:	f47f af5c 	bne.w	80a75d4 <__aeabi_fmul+0x14c>
 80a771c:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a7720:	f47f af3c 	bne.w	80a759c <__aeabi_fmul+0x114>
 80a7724:	e75f      	b.n	80a75e6 <__aeabi_fmul+0x15e>
 80a7726:	bf00      	nop

080a7728 <__gesf2>:
 80a7728:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 80a772c:	e006      	b.n	80a773c <__cmpsf2+0x4>
 80a772e:	bf00      	nop

080a7730 <__lesf2>:
 80a7730:	f04f 0c01 	mov.w	ip, #1
 80a7734:	e002      	b.n	80a773c <__cmpsf2+0x4>
 80a7736:	bf00      	nop

080a7738 <__cmpsf2>:
 80a7738:	f04f 0c01 	mov.w	ip, #1
 80a773c:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a7740:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a7744:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a7748:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a774c:	bf18      	it	ne
 80a774e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a7752:	d011      	beq.n	80a7778 <__cmpsf2+0x40>
 80a7754:	b001      	add	sp, #4
 80a7756:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80a775a:	bf18      	it	ne
 80a775c:	ea90 0f01 	teqne	r0, r1
 80a7760:	bf58      	it	pl
 80a7762:	ebb2 0003 	subspl.w	r0, r2, r3
 80a7766:	bf88      	it	hi
 80a7768:	17c8      	asrhi	r0, r1, #31
 80a776a:	bf38      	it	cc
 80a776c:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80a7770:	bf18      	it	ne
 80a7772:	f040 0001 	orrne.w	r0, r0, #1
 80a7776:	4770      	bx	lr
 80a7778:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a777c:	d102      	bne.n	80a7784 <__cmpsf2+0x4c>
 80a777e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a7782:	d105      	bne.n	80a7790 <__cmpsf2+0x58>
 80a7784:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a7788:	d1e4      	bne.n	80a7754 <__cmpsf2+0x1c>
 80a778a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a778e:	d0e1      	beq.n	80a7754 <__cmpsf2+0x1c>
 80a7790:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a7794:	4770      	bx	lr
 80a7796:	bf00      	nop

080a7798 <__aeabi_cfrcmple>:
 80a7798:	4684      	mov	ip, r0
 80a779a:	4608      	mov	r0, r1
 80a779c:	4661      	mov	r1, ip
 80a779e:	e7ff      	b.n	80a77a0 <__aeabi_cfcmpeq>

080a77a0 <__aeabi_cfcmpeq>:
 80a77a0:	b50f      	push	{r0, r1, r2, r3, lr}
 80a77a2:	f7ff ffc9 	bl	80a7738 <__cmpsf2>
 80a77a6:	2800      	cmp	r0, #0
 80a77a8:	bf48      	it	mi
 80a77aa:	f110 0f00 	cmnmi.w	r0, #0
 80a77ae:	bd0f      	pop	{r0, r1, r2, r3, pc}

080a77b0 <__aeabi_fcmpeq>:
 80a77b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a77b4:	f7ff fff4 	bl	80a77a0 <__aeabi_cfcmpeq>
 80a77b8:	bf0c      	ite	eq
 80a77ba:	2001      	moveq	r0, #1
 80a77bc:	2000      	movne	r0, #0
 80a77be:	f85d fb08 	ldr.w	pc, [sp], #8
 80a77c2:	bf00      	nop

080a77c4 <__aeabi_fcmplt>:
 80a77c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a77c8:	f7ff ffea 	bl	80a77a0 <__aeabi_cfcmpeq>
 80a77cc:	bf34      	ite	cc
 80a77ce:	2001      	movcc	r0, #1
 80a77d0:	2000      	movcs	r0, #0
 80a77d2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a77d6:	bf00      	nop

080a77d8 <__aeabi_fcmple>:
 80a77d8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a77dc:	f7ff ffe0 	bl	80a77a0 <__aeabi_cfcmpeq>
 80a77e0:	bf94      	ite	ls
 80a77e2:	2001      	movls	r0, #1
 80a77e4:	2000      	movhi	r0, #0
 80a77e6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a77ea:	bf00      	nop

080a77ec <__aeabi_fcmpge>:
 80a77ec:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a77f0:	f7ff ffd2 	bl	80a7798 <__aeabi_cfrcmple>
 80a77f4:	bf94      	ite	ls
 80a77f6:	2001      	movls	r0, #1
 80a77f8:	2000      	movhi	r0, #0
 80a77fa:	f85d fb08 	ldr.w	pc, [sp], #8
 80a77fe:	bf00      	nop

080a7800 <__aeabi_fcmpgt>:
 80a7800:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a7804:	f7ff ffc8 	bl	80a7798 <__aeabi_cfrcmple>
 80a7808:	bf34      	ite	cc
 80a780a:	2001      	movcc	r0, #1
 80a780c:	2000      	movcs	r0, #0
 80a780e:	f85d fb08 	ldr.w	pc, [sp], #8
 80a7812:	bf00      	nop

080a7814 <__aeabi_fcmpun>:
 80a7814:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a7818:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a781c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a7820:	d102      	bne.n	80a7828 <__aeabi_fcmpun+0x14>
 80a7822:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a7826:	d108      	bne.n	80a783a <__aeabi_fcmpun+0x26>
 80a7828:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a782c:	d102      	bne.n	80a7834 <__aeabi_fcmpun+0x20>
 80a782e:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a7832:	d102      	bne.n	80a783a <__aeabi_fcmpun+0x26>
 80a7834:	f04f 0000 	mov.w	r0, #0
 80a7838:	4770      	bx	lr
 80a783a:	f04f 0001 	mov.w	r0, #1
 80a783e:	4770      	bx	lr

080a7840 <atexit>:
 80a7840:	2300      	movs	r3, #0
 80a7842:	4601      	mov	r1, r0
 80a7844:	461a      	mov	r2, r3
 80a7846:	4618      	mov	r0, r3
 80a7848:	f000 b998 	b.w	80a7b7c <__register_exitproc>

080a784c <memcmp>:
 80a784c:	b530      	push	{r4, r5, lr}
 80a784e:	2400      	movs	r4, #0
 80a7850:	3901      	subs	r1, #1
 80a7852:	42a2      	cmp	r2, r4
 80a7854:	d101      	bne.n	80a785a <memcmp+0xe>
 80a7856:	2000      	movs	r0, #0
 80a7858:	e005      	b.n	80a7866 <memcmp+0x1a>
 80a785a:	5d03      	ldrb	r3, [r0, r4]
 80a785c:	3401      	adds	r4, #1
 80a785e:	5d0d      	ldrb	r5, [r1, r4]
 80a7860:	42ab      	cmp	r3, r5
 80a7862:	d0f6      	beq.n	80a7852 <memcmp+0x6>
 80a7864:	1b58      	subs	r0, r3, r5
 80a7866:	bd30      	pop	{r4, r5, pc}

080a7868 <memcpy>:
 80a7868:	440a      	add	r2, r1
 80a786a:	4291      	cmp	r1, r2
 80a786c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80a7870:	d100      	bne.n	80a7874 <memcpy+0xc>
 80a7872:	4770      	bx	lr
 80a7874:	b510      	push	{r4, lr}
 80a7876:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a787a:	4291      	cmp	r1, r2
 80a787c:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a7880:	d1f9      	bne.n	80a7876 <memcpy+0xe>
 80a7882:	bd10      	pop	{r4, pc}

080a7884 <memmove>:
 80a7884:	4288      	cmp	r0, r1
 80a7886:	b510      	push	{r4, lr}
 80a7888:	eb01 0402 	add.w	r4, r1, r2
 80a788c:	d902      	bls.n	80a7894 <memmove+0x10>
 80a788e:	4284      	cmp	r4, r0
 80a7890:	4623      	mov	r3, r4
 80a7892:	d807      	bhi.n	80a78a4 <memmove+0x20>
 80a7894:	1e43      	subs	r3, r0, #1
 80a7896:	42a1      	cmp	r1, r4
 80a7898:	d008      	beq.n	80a78ac <memmove+0x28>
 80a789a:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a789e:	f803 2f01 	strb.w	r2, [r3, #1]!
 80a78a2:	e7f8      	b.n	80a7896 <memmove+0x12>
 80a78a4:	4601      	mov	r1, r0
 80a78a6:	4402      	add	r2, r0
 80a78a8:	428a      	cmp	r2, r1
 80a78aa:	d100      	bne.n	80a78ae <memmove+0x2a>
 80a78ac:	bd10      	pop	{r4, pc}
 80a78ae:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80a78b2:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80a78b6:	e7f7      	b.n	80a78a8 <memmove+0x24>

080a78b8 <memset>:
 80a78b8:	4603      	mov	r3, r0
 80a78ba:	4402      	add	r2, r0
 80a78bc:	4293      	cmp	r3, r2
 80a78be:	d100      	bne.n	80a78c2 <memset+0xa>
 80a78c0:	4770      	bx	lr
 80a78c2:	f803 1b01 	strb.w	r1, [r3], #1
 80a78c6:	e7f9      	b.n	80a78bc <memset+0x4>

080a78c8 <srand>:
 80a78c8:	b538      	push	{r3, r4, r5, lr}
 80a78ca:	4b0d      	ldr	r3, [pc, #52]	; (80a7900 <srand+0x38>)
 80a78cc:	4604      	mov	r4, r0
 80a78ce:	681d      	ldr	r5, [r3, #0]
 80a78d0:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a78d2:	b97b      	cbnz	r3, 80a78f4 <srand+0x2c>
 80a78d4:	2018      	movs	r0, #24
 80a78d6:	f7fc fe61 	bl	80a459c <malloc>
 80a78da:	4a0a      	ldr	r2, [pc, #40]	; (80a7904 <srand+0x3c>)
 80a78dc:	4b0a      	ldr	r3, [pc, #40]	; (80a7908 <srand+0x40>)
 80a78de:	63a8      	str	r0, [r5, #56]	; 0x38
 80a78e0:	e9c0 2300 	strd	r2, r3, [r0]
 80a78e4:	4b09      	ldr	r3, [pc, #36]	; (80a790c <srand+0x44>)
 80a78e6:	2201      	movs	r2, #1
 80a78e8:	6083      	str	r3, [r0, #8]
 80a78ea:	230b      	movs	r3, #11
 80a78ec:	8183      	strh	r3, [r0, #12]
 80a78ee:	2300      	movs	r3, #0
 80a78f0:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a78f4:	2200      	movs	r2, #0
 80a78f6:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a78f8:	611c      	str	r4, [r3, #16]
 80a78fa:	615a      	str	r2, [r3, #20]
 80a78fc:	bd38      	pop	{r3, r4, r5, pc}
 80a78fe:	bf00      	nop
 80a7900:	20000028 	.word	0x20000028
 80a7904:	abcd330e 	.word	0xabcd330e
 80a7908:	e66d1234 	.word	0xe66d1234
 80a790c:	0005deec 	.word	0x0005deec

080a7910 <rand>:
 80a7910:	4b13      	ldr	r3, [pc, #76]	; (80a7960 <rand+0x50>)
 80a7912:	b510      	push	{r4, lr}
 80a7914:	681c      	ldr	r4, [r3, #0]
 80a7916:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a7918:	b97b      	cbnz	r3, 80a793a <rand+0x2a>
 80a791a:	2018      	movs	r0, #24
 80a791c:	f7fc fe3e 	bl	80a459c <malloc>
 80a7920:	4a10      	ldr	r2, [pc, #64]	; (80a7964 <rand+0x54>)
 80a7922:	4b11      	ldr	r3, [pc, #68]	; (80a7968 <rand+0x58>)
 80a7924:	63a0      	str	r0, [r4, #56]	; 0x38
 80a7926:	e9c0 2300 	strd	r2, r3, [r0]
 80a792a:	4b10      	ldr	r3, [pc, #64]	; (80a796c <rand+0x5c>)
 80a792c:	2201      	movs	r2, #1
 80a792e:	6083      	str	r3, [r0, #8]
 80a7930:	230b      	movs	r3, #11
 80a7932:	8183      	strh	r3, [r0, #12]
 80a7934:	2300      	movs	r3, #0
 80a7936:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a793a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a793c:	480c      	ldr	r0, [pc, #48]	; (80a7970 <rand+0x60>)
 80a793e:	690a      	ldr	r2, [r1, #16]
 80a7940:	694b      	ldr	r3, [r1, #20]
 80a7942:	4350      	muls	r0, r2
 80a7944:	4c0b      	ldr	r4, [pc, #44]	; (80a7974 <rand+0x64>)
 80a7946:	fb04 0003 	mla	r0, r4, r3, r0
 80a794a:	fba2 3404 	umull	r3, r4, r2, r4
 80a794e:	1c5a      	adds	r2, r3, #1
 80a7950:	4404      	add	r4, r0
 80a7952:	f144 0000 	adc.w	r0, r4, #0
 80a7956:	e9c1 2004 	strd	r2, r0, [r1, #16]
 80a795a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 80a795e:	bd10      	pop	{r4, pc}
 80a7960:	20000028 	.word	0x20000028
 80a7964:	abcd330e 	.word	0xabcd330e
 80a7968:	e66d1234 	.word	0xe66d1234
 80a796c:	0005deec 	.word	0x0005deec
 80a7970:	5851f42d 	.word	0x5851f42d
 80a7974:	4c957f2d 	.word	0x4c957f2d

080a7978 <strchr>:
 80a7978:	4603      	mov	r3, r0
 80a797a:	b2c9      	uxtb	r1, r1
 80a797c:	4618      	mov	r0, r3
 80a797e:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a7982:	b112      	cbz	r2, 80a798a <strchr+0x12>
 80a7984:	428a      	cmp	r2, r1
 80a7986:	d1f9      	bne.n	80a797c <strchr+0x4>
 80a7988:	4770      	bx	lr
 80a798a:	2900      	cmp	r1, #0
 80a798c:	bf18      	it	ne
 80a798e:	2000      	movne	r0, #0
 80a7990:	4770      	bx	lr

080a7992 <strchrnul>:
 80a7992:	b510      	push	{r4, lr}
 80a7994:	4604      	mov	r4, r0
 80a7996:	f7ff ffef 	bl	80a7978 <strchr>
 80a799a:	b918      	cbnz	r0, 80a79a4 <strchrnul+0x12>
 80a799c:	4620      	mov	r0, r4
 80a799e:	f000 f814 	bl	80a79ca <strlen>
 80a79a2:	4420      	add	r0, r4
 80a79a4:	bd10      	pop	{r4, pc}

080a79a6 <strcmp>:
 80a79a6:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a79aa:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a79ae:	2a01      	cmp	r2, #1
 80a79b0:	bf28      	it	cs
 80a79b2:	429a      	cmpcs	r2, r3
 80a79b4:	d0f7      	beq.n	80a79a6 <strcmp>
 80a79b6:	1ad0      	subs	r0, r2, r3
 80a79b8:	4770      	bx	lr

080a79ba <strcpy>:
 80a79ba:	4603      	mov	r3, r0
 80a79bc:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a79c0:	f803 2b01 	strb.w	r2, [r3], #1
 80a79c4:	2a00      	cmp	r2, #0
 80a79c6:	d1f9      	bne.n	80a79bc <strcpy+0x2>
 80a79c8:	4770      	bx	lr

080a79ca <strlen>:
 80a79ca:	4603      	mov	r3, r0
 80a79cc:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a79d0:	2a00      	cmp	r2, #0
 80a79d2:	d1fb      	bne.n	80a79cc <strlen+0x2>
 80a79d4:	1a18      	subs	r0, r3, r0
 80a79d6:	3801      	subs	r0, #1
 80a79d8:	4770      	bx	lr

080a79da <strncat>:
 80a79da:	b530      	push	{r4, r5, lr}
 80a79dc:	4604      	mov	r4, r0
 80a79de:	7825      	ldrb	r5, [r4, #0]
 80a79e0:	4623      	mov	r3, r4
 80a79e2:	3401      	adds	r4, #1
 80a79e4:	2d00      	cmp	r5, #0
 80a79e6:	d1fa      	bne.n	80a79de <strncat+0x4>
 80a79e8:	3a01      	subs	r2, #1
 80a79ea:	d304      	bcc.n	80a79f6 <strncat+0x1c>
 80a79ec:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a79f0:	f803 4b01 	strb.w	r4, [r3], #1
 80a79f4:	b904      	cbnz	r4, 80a79f8 <strncat+0x1e>
 80a79f6:	bd30      	pop	{r4, r5, pc}
 80a79f8:	2a00      	cmp	r2, #0
 80a79fa:	d1f5      	bne.n	80a79e8 <strncat+0xe>
 80a79fc:	701a      	strb	r2, [r3, #0]
 80a79fe:	e7f3      	b.n	80a79e8 <strncat+0xe>

080a7a00 <strncmp>:
 80a7a00:	b510      	push	{r4, lr}
 80a7a02:	b16a      	cbz	r2, 80a7a20 <strncmp+0x20>
 80a7a04:	3901      	subs	r1, #1
 80a7a06:	1884      	adds	r4, r0, r2
 80a7a08:	f810 3b01 	ldrb.w	r3, [r0], #1
 80a7a0c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 80a7a10:	4293      	cmp	r3, r2
 80a7a12:	d103      	bne.n	80a7a1c <strncmp+0x1c>
 80a7a14:	42a0      	cmp	r0, r4
 80a7a16:	d001      	beq.n	80a7a1c <strncmp+0x1c>
 80a7a18:	2b00      	cmp	r3, #0
 80a7a1a:	d1f5      	bne.n	80a7a08 <strncmp+0x8>
 80a7a1c:	1a98      	subs	r0, r3, r2
 80a7a1e:	bd10      	pop	{r4, pc}
 80a7a20:	4610      	mov	r0, r2
 80a7a22:	e7fc      	b.n	80a7a1e <strncmp+0x1e>

080a7a24 <strncpy>:
 80a7a24:	4603      	mov	r3, r0
 80a7a26:	b510      	push	{r4, lr}
 80a7a28:	3901      	subs	r1, #1
 80a7a2a:	b132      	cbz	r2, 80a7a3a <strncpy+0x16>
 80a7a2c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a7a30:	3a01      	subs	r2, #1
 80a7a32:	f803 4b01 	strb.w	r4, [r3], #1
 80a7a36:	2c00      	cmp	r4, #0
 80a7a38:	d1f7      	bne.n	80a7a2a <strncpy+0x6>
 80a7a3a:	2100      	movs	r1, #0
 80a7a3c:	441a      	add	r2, r3
 80a7a3e:	4293      	cmp	r3, r2
 80a7a40:	d100      	bne.n	80a7a44 <strncpy+0x20>
 80a7a42:	bd10      	pop	{r4, pc}
 80a7a44:	f803 1b01 	strb.w	r1, [r3], #1
 80a7a48:	e7f9      	b.n	80a7a3e <strncpy+0x1a>

080a7a4a <strrchr>:
 80a7a4a:	b538      	push	{r3, r4, r5, lr}
 80a7a4c:	4603      	mov	r3, r0
 80a7a4e:	460c      	mov	r4, r1
 80a7a50:	b969      	cbnz	r1, 80a7a6e <strrchr+0x24>
 80a7a52:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a7a56:	f7ff bf8f 	b.w	80a7978 <strchr>
 80a7a5a:	4605      	mov	r5, r0
 80a7a5c:	1c43      	adds	r3, r0, #1
 80a7a5e:	4621      	mov	r1, r4
 80a7a60:	4618      	mov	r0, r3
 80a7a62:	f7ff ff89 	bl	80a7978 <strchr>
 80a7a66:	2800      	cmp	r0, #0
 80a7a68:	d1f7      	bne.n	80a7a5a <strrchr+0x10>
 80a7a6a:	4628      	mov	r0, r5
 80a7a6c:	bd38      	pop	{r3, r4, r5, pc}
 80a7a6e:	2500      	movs	r5, #0
 80a7a70:	e7f5      	b.n	80a7a5e <strrchr+0x14>
	...

080a7a74 <_strtol_l.isra.0>:
 80a7a74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a7a78:	468c      	mov	ip, r1
 80a7a7a:	4686      	mov	lr, r0
 80a7a7c:	4e39      	ldr	r6, [pc, #228]	; (80a7b64 <_strtol_l.isra.0+0xf0>)
 80a7a7e:	4660      	mov	r0, ip
 80a7a80:	f81c 4b01 	ldrb.w	r4, [ip], #1
 80a7a84:	5da5      	ldrb	r5, [r4, r6]
 80a7a86:	f015 0508 	ands.w	r5, r5, #8
 80a7a8a:	d1f8      	bne.n	80a7a7e <_strtol_l.isra.0+0xa>
 80a7a8c:	2c2d      	cmp	r4, #45	; 0x2d
 80a7a8e:	d133      	bne.n	80a7af8 <_strtol_l.isra.0+0x84>
 80a7a90:	f04f 0801 	mov.w	r8, #1
 80a7a94:	f89c 4000 	ldrb.w	r4, [ip]
 80a7a98:	f100 0c02 	add.w	ip, r0, #2
 80a7a9c:	2b00      	cmp	r3, #0
 80a7a9e:	d05c      	beq.n	80a7b5a <_strtol_l.isra.0+0xe6>
 80a7aa0:	2b10      	cmp	r3, #16
 80a7aa2:	d10c      	bne.n	80a7abe <_strtol_l.isra.0+0x4a>
 80a7aa4:	2c30      	cmp	r4, #48	; 0x30
 80a7aa6:	d10a      	bne.n	80a7abe <_strtol_l.isra.0+0x4a>
 80a7aa8:	f89c 0000 	ldrb.w	r0, [ip]
 80a7aac:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a7ab0:	2858      	cmp	r0, #88	; 0x58
 80a7ab2:	d14d      	bne.n	80a7b50 <_strtol_l.isra.0+0xdc>
 80a7ab4:	2310      	movs	r3, #16
 80a7ab6:	f89c 4001 	ldrb.w	r4, [ip, #1]
 80a7aba:	f10c 0c02 	add.w	ip, ip, #2
 80a7abe:	2600      	movs	r6, #0
 80a7ac0:	f108 4700 	add.w	r7, r8, #2147483648	; 0x80000000
 80a7ac4:	3f01      	subs	r7, #1
 80a7ac6:	fbb7 f9f3 	udiv	r9, r7, r3
 80a7aca:	4630      	mov	r0, r6
 80a7acc:	fb03 7a19 	mls	sl, r3, r9, r7
 80a7ad0:	f1a4 0530 	sub.w	r5, r4, #48	; 0x30
 80a7ad4:	2d09      	cmp	r5, #9
 80a7ad6:	d818      	bhi.n	80a7b0a <_strtol_l.isra.0+0x96>
 80a7ad8:	462c      	mov	r4, r5
 80a7ada:	42a3      	cmp	r3, r4
 80a7adc:	dd24      	ble.n	80a7b28 <_strtol_l.isra.0+0xb4>
 80a7ade:	1c75      	adds	r5, r6, #1
 80a7ae0:	d007      	beq.n	80a7af2 <_strtol_l.isra.0+0x7e>
 80a7ae2:	4581      	cmp	r9, r0
 80a7ae4:	d31d      	bcc.n	80a7b22 <_strtol_l.isra.0+0xae>
 80a7ae6:	d101      	bne.n	80a7aec <_strtol_l.isra.0+0x78>
 80a7ae8:	45a2      	cmp	sl, r4
 80a7aea:	db1a      	blt.n	80a7b22 <_strtol_l.isra.0+0xae>
 80a7aec:	2601      	movs	r6, #1
 80a7aee:	fb00 4003 	mla	r0, r0, r3, r4
 80a7af2:	f81c 4b01 	ldrb.w	r4, [ip], #1
 80a7af6:	e7eb      	b.n	80a7ad0 <_strtol_l.isra.0+0x5c>
 80a7af8:	2c2b      	cmp	r4, #43	; 0x2b
 80a7afa:	bf08      	it	eq
 80a7afc:	f89c 4000 	ldrbeq.w	r4, [ip]
 80a7b00:	46a8      	mov	r8, r5
 80a7b02:	bf08      	it	eq
 80a7b04:	f100 0c02 	addeq.w	ip, r0, #2
 80a7b08:	e7c8      	b.n	80a7a9c <_strtol_l.isra.0+0x28>
 80a7b0a:	f1a4 0541 	sub.w	r5, r4, #65	; 0x41
 80a7b0e:	2d19      	cmp	r5, #25
 80a7b10:	d801      	bhi.n	80a7b16 <_strtol_l.isra.0+0xa2>
 80a7b12:	3c37      	subs	r4, #55	; 0x37
 80a7b14:	e7e1      	b.n	80a7ada <_strtol_l.isra.0+0x66>
 80a7b16:	f1a4 0561 	sub.w	r5, r4, #97	; 0x61
 80a7b1a:	2d19      	cmp	r5, #25
 80a7b1c:	d804      	bhi.n	80a7b28 <_strtol_l.isra.0+0xb4>
 80a7b1e:	3c57      	subs	r4, #87	; 0x57
 80a7b20:	e7db      	b.n	80a7ada <_strtol_l.isra.0+0x66>
 80a7b22:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 80a7b26:	e7e4      	b.n	80a7af2 <_strtol_l.isra.0+0x7e>
 80a7b28:	1c73      	adds	r3, r6, #1
 80a7b2a:	d106      	bne.n	80a7b3a <_strtol_l.isra.0+0xc6>
 80a7b2c:	2322      	movs	r3, #34	; 0x22
 80a7b2e:	4638      	mov	r0, r7
 80a7b30:	f8ce 3000 	str.w	r3, [lr]
 80a7b34:	b942      	cbnz	r2, 80a7b48 <_strtol_l.isra.0+0xd4>
 80a7b36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a7b3a:	f1b8 0f00 	cmp.w	r8, #0
 80a7b3e:	d000      	beq.n	80a7b42 <_strtol_l.isra.0+0xce>
 80a7b40:	4240      	negs	r0, r0
 80a7b42:	2a00      	cmp	r2, #0
 80a7b44:	d0f7      	beq.n	80a7b36 <_strtol_l.isra.0+0xc2>
 80a7b46:	b10e      	cbz	r6, 80a7b4c <_strtol_l.isra.0+0xd8>
 80a7b48:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
 80a7b4c:	6011      	str	r1, [r2, #0]
 80a7b4e:	e7f2      	b.n	80a7b36 <_strtol_l.isra.0+0xc2>
 80a7b50:	2430      	movs	r4, #48	; 0x30
 80a7b52:	2b00      	cmp	r3, #0
 80a7b54:	d1b3      	bne.n	80a7abe <_strtol_l.isra.0+0x4a>
 80a7b56:	2308      	movs	r3, #8
 80a7b58:	e7b1      	b.n	80a7abe <_strtol_l.isra.0+0x4a>
 80a7b5a:	2c30      	cmp	r4, #48	; 0x30
 80a7b5c:	d0a4      	beq.n	80a7aa8 <_strtol_l.isra.0+0x34>
 80a7b5e:	230a      	movs	r3, #10
 80a7b60:	e7ad      	b.n	80a7abe <_strtol_l.isra.0+0x4a>
 80a7b62:	bf00      	nop
 80a7b64:	080a8067 	.word	0x080a8067

080a7b68 <strtol>:
 80a7b68:	4613      	mov	r3, r2
 80a7b6a:	460a      	mov	r2, r1
 80a7b6c:	4601      	mov	r1, r0
 80a7b6e:	4802      	ldr	r0, [pc, #8]	; (80a7b78 <strtol+0x10>)
 80a7b70:	6800      	ldr	r0, [r0, #0]
 80a7b72:	f7ff bf7f 	b.w	80a7a74 <_strtol_l.isra.0>
 80a7b76:	bf00      	nop
 80a7b78:	20000028 	.word	0x20000028

080a7b7c <__register_exitproc>:
 80a7b7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a7b80:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80a7c40 <__register_exitproc+0xc4>
 80a7b84:	4606      	mov	r6, r0
 80a7b86:	f8d8 0000 	ldr.w	r0, [r8]
 80a7b8a:	461f      	mov	r7, r3
 80a7b8c:	460d      	mov	r5, r1
 80a7b8e:	4691      	mov	r9, r2
 80a7b90:	f000 f858 	bl	80a7c44 <__retarget_lock_acquire_recursive>
 80a7b94:	4b26      	ldr	r3, [pc, #152]	; (80a7c30 <__register_exitproc+0xb4>)
 80a7b96:	681c      	ldr	r4, [r3, #0]
 80a7b98:	b934      	cbnz	r4, 80a7ba8 <__register_exitproc+0x2c>
 80a7b9a:	4c26      	ldr	r4, [pc, #152]	; (80a7c34 <__register_exitproc+0xb8>)
 80a7b9c:	601c      	str	r4, [r3, #0]
 80a7b9e:	4b26      	ldr	r3, [pc, #152]	; (80a7c38 <__register_exitproc+0xbc>)
 80a7ba0:	b113      	cbz	r3, 80a7ba8 <__register_exitproc+0x2c>
 80a7ba2:	681b      	ldr	r3, [r3, #0]
 80a7ba4:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 80a7ba8:	6863      	ldr	r3, [r4, #4]
 80a7baa:	2b1f      	cmp	r3, #31
 80a7bac:	dd07      	ble.n	80a7bbe <__register_exitproc+0x42>
 80a7bae:	f8d8 0000 	ldr.w	r0, [r8]
 80a7bb2:	f000 f849 	bl	80a7c48 <__retarget_lock_release_recursive>
 80a7bb6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a7bba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a7bbe:	b35e      	cbz	r6, 80a7c18 <__register_exitproc+0x9c>
 80a7bc0:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 80a7bc4:	b988      	cbnz	r0, 80a7bea <__register_exitproc+0x6e>
 80a7bc6:	4b1d      	ldr	r3, [pc, #116]	; (80a7c3c <__register_exitproc+0xc0>)
 80a7bc8:	b923      	cbnz	r3, 80a7bd4 <__register_exitproc+0x58>
 80a7bca:	f8d8 0000 	ldr.w	r0, [r8]
 80a7bce:	f000 f83a 	bl	80a7c46 <__retarget_lock_release>
 80a7bd2:	e7f0      	b.n	80a7bb6 <__register_exitproc+0x3a>
 80a7bd4:	f44f 7084 	mov.w	r0, #264	; 0x108
 80a7bd8:	f7fc fce0 	bl	80a459c <malloc>
 80a7bdc:	2800      	cmp	r0, #0
 80a7bde:	d0f4      	beq.n	80a7bca <__register_exitproc+0x4e>
 80a7be0:	2300      	movs	r3, #0
 80a7be2:	e9c0 3340 	strd	r3, r3, [r0, #256]	; 0x100
 80a7be6:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 80a7bea:	2201      	movs	r2, #1
 80a7bec:	6863      	ldr	r3, [r4, #4]
 80a7bee:	2e02      	cmp	r6, #2
 80a7bf0:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
 80a7bf4:	fa02 f203 	lsl.w	r2, r2, r3
 80a7bf8:	eb00 0183 	add.w	r1, r0, r3, lsl #2
 80a7bfc:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
 80a7c00:	ea43 0302 	orr.w	r3, r3, r2
 80a7c04:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
 80a7c08:	f8c1 7080 	str.w	r7, [r1, #128]	; 0x80
 80a7c0c:	bf02      	ittt	eq
 80a7c0e:	f8d0 3104 	ldreq.w	r3, [r0, #260]	; 0x104
 80a7c12:	431a      	orreq	r2, r3
 80a7c14:	f8c0 2104 	streq.w	r2, [r0, #260]	; 0x104
 80a7c18:	6863      	ldr	r3, [r4, #4]
 80a7c1a:	f8d8 0000 	ldr.w	r0, [r8]
 80a7c1e:	1c5a      	adds	r2, r3, #1
 80a7c20:	3302      	adds	r3, #2
 80a7c22:	6062      	str	r2, [r4, #4]
 80a7c24:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
 80a7c28:	f000 f80e 	bl	80a7c48 <__retarget_lock_release_recursive>
 80a7c2c:	2000      	movs	r0, #0
 80a7c2e:	e7c4      	b.n	80a7bba <__register_exitproc+0x3e>
 80a7c30:	20001bb0 	.word	0x20001bb0
 80a7c34:	20001b24 	.word	0x20001b24
 80a7c38:	00000000 	.word	0x00000000
 80a7c3c:	080a459d 	.word	0x080a459d
 80a7c40:	2000008c 	.word	0x2000008c

080a7c44 <__retarget_lock_acquire_recursive>:
 80a7c44:	4770      	bx	lr

080a7c46 <__retarget_lock_release>:
 80a7c46:	4770      	bx	lr

080a7c48 <__retarget_lock_release_recursive>:
 80a7c48:	4770      	bx	lr

080a7c4a <link_code_end>:
	...

080a7c4c <dynalib_user>:
 80a7c4c:	001d 080a 005d 080a 0085 080a 0089 080a     ....]...........
 80a7c5c:	0000 0000 6564 6166 6c75 2074 4d00 4253     ....default .MSB
 80a7c6c:	4c00 4253 3c00 5053 5349 7465 6974 676e     .LSB.<SPISetting
 80a7c7c:	2073 6564 6166 6c75 3e74 3c00 5053 5349     s default>.<SPIS
 80a7c8c:	7465 6974 676e 2073 7325 7525 2520 2073     ettings %s%u %s 
 80a7c9c:	4f4d 4544 7525 003e 736c 6400 7269 2f00     MODE%u>.ls.dir./
 80a7cac:	6c00 7561 6867 2e33 6177 0076 6c50 7961     .laugh3.wav.Play
 80a7cbc:	6e69 2067 7325 2500 2073 6f6e 2074 6f66     ing %s.%s not fo
 80a7ccc:	6e75 0064 7441 6574 706d 6574 2064 7461     und.Attempted at
 80a7cdc:	6174 6b63 6120 2074 7262 6769 7468 656e     tack at brightne
 80a7cec:	7373 2520 0a69 6200 6f6c 6b63 772e 7661     ss %i..block.wav
 80a7cfc:	2500 2066 2f2f 2520 2069 2f2f 2520 0a66     .%f // %i // %f.
 80a7d0c:	6800 6e6f 2e6b 6177 0076 616c 6775 0068     .honk.wav.laugh.
 80a7d1c:	6f70 6577 6472 776f 2e6e 6177 0076 6f74     powerdown.wav.to
 80a7d2c:	6572 6461 726f 772e 7661 6600 696c 6b63     reador.wav.flick
 80a7d3c:	7265 772e 7661 6600 6f6f 7374 6574 7370     er.wav.footsteps
 80a7d4c:	772e 7661 7300 7263 6165 2e6d 6177 0076     .wav.scream.wav.
 80a7d5c:	7473 7461 6369 772e 7661 6c00 7561 6867     static.wav.laugh
 80a7d6c:	2e4e 6177 0076 6c70 7961 6157 0076 7461     N.wav.playWav.at
 80a7d7c:	4d6b 646f 0065 4453 6920 696e 6974 6c61     kMode.SD initial
 80a7d8c:	7369 6465 6600 6961 656c 2064 6f74 6f20     ised.failed to o
 80a7d9c:	6570 206e 6163 6472 6100 7070 0000 0000     pen card.app....

080a7dac <_ZTVN8particle11SPISettingsE>:
	...
 80a7db4:	0639 080a 0519 080a 055d 080a               9.......]...

080a7dc0 <_ZTVN5spark10LogHandlerE>:
	...
 80a7dd0:	00a5 080a 051b 080a                         ........

080a7dd8 <_ZTVN5spark16SerialLogHandlerE>:
	...
 80a7de0:	05d5 080a 0609 080a 5845 080a 051d 080a     ........EX......

080a7df0 <_ZTV4File>:
	...
 80a7df8:	055b 080a 056b 080a 05ab 080a 05a5 080a     [...k...........
 80a7e08:	0525 080a 0579 080a 059f 080a 0599 080a     %...y...........

080a7e18 <CSWTCH.191>:
 80a7e18:	012c 0000 0018 0000 01f4 0000 012c 0000     ,...........,...
 80a7e28:	0050 0000                                   P...

080a7e2c <_ZTV7TwoWire>:
	...
 80a7e34:	46a9 080a 46f3 080a 46cb 080a 46ab 080a     .F...F...F...F..
 80a7e44:	46d3 080a 46db 080a 46e3 080a 46eb 080a     .F...F...F...F..

080a7e54 <_ZTV9IPAddress>:
	...
 80a7e5c:	4735 080a 4725 080a 4727 080a 6425 2500     5G..%G..'G..%d.%
 80a7e6c:	0075 2575 3430 0078 6162 6475 5300 7265     u.u%04x.baud.Ser
 80a7e7c:	6169 006c 5355 5342 7265 6169 316c 4a00     ial.USBSerial1.J
 80a7e8c:	4f53 534e 7274 6165 4c6d 676f 6148 646e     SONStreamLogHand
 80a7e9c:	656c 0072 3025 3031 2075 5d00 0020 202c     ler.%010u .] ., 
 80a7eac:	2800 3a29 0020 5b20 6300 646f 2065 203d     .(): . [.code = 
 80a7ebc:	2500 0069 6564 6174 6c69 2073 203d 0d00     .%i.details = ..
 80a7ecc:	000a 006d 0063 0066 6e6c 6600 006e 0074     ..m.c.f.ln.fn.t.
 80a7edc:	6f63 6564 6400 7465 6961 006c               code.detail.

080a7ee8 <_ZTVN5spark16JSONStreamWriterE>:
	...
 80a7ef0:	4bd9 080a 4bff 080a 4bbd 080a 481b 080a     .K...K...K...H..

080a7f00 <_ZTVN5spark16StreamLogHandlerE>:
	...
 80a7f08:	5065 080a 507d 080a 5845 080a 051d 080a     eP..}P..EX......

080a7f18 <_ZTVN5spark20JSONStreamLogHandlerE>:
	...
 80a7f20:	5091 080a 50a5 080a 59ed 080a 4bc5 080a     .P...P...Y...K..

080a7f30 <_ZTVN5spark24DefaultLogHandlerFactoryE>:
	...
 80a7f38:	4bd7 080a 4c0d 080a 5781 080a 4bc7 080a     .K...L...W...K..

080a7f48 <_ZTVN5spark26DefaultOutputStreamFactoryE>:
	...
 80a7f50:	4bd5 080a 4c1b 080a 4f8d 080a 4c39 080a     .K...L...O..9L..

080a7f60 <_ZTVN5spark12NetworkClassE>:
	...
 80a7f68:	5b61 080a 5b6b 080a 5b75 080a 5b7f 080a     a[..k[..u[...[..
 80a7f78:	5b89 080a 5b95 080a 5ba1 080a 5ba9 080a     .[...[...[...[..
 80a7f88:	5bb1 080a 5bbd 080a 5bc5 080a 5bcf 080a     .[...[...[...[..
 80a7f98:	5bd9 080a                                   .[..

080a7f9c <_ZN12_GLOBAL__N_1L14clock_divisorsE>:
 80a7f9c:	0800 1810 2820 3830 5925 252d 2d6d 6425     .... (08%Y-%m-%d
 80a7fac:	2554 3a48 4d25 253a 2553 007a 7361 7463     T%H:%M:%S%z.asct
 80a7fbc:	6d69 0065                                   ime.

080a7fc0 <_ZTV11USARTSerial>:
	...
 80a7fc8:	6121 080a 618b 080a 6167 080a 5c3d 080a     !a...a..ga..=\..
 80a7fd8:	6137 080a 6153 080a 6145 080a 6161 080a     7a..Sa..Ea..aa..
 80a7fe8:	6123 080a 6129 080a                         #a..)a..

080a7ff0 <_ZTV9USBSerial>:
	...
 80a7ff8:	6227 080a 628d 080a 6265 080a 5c3d 080a     'b...b..eb..=\..
 80a8008:	6257 080a 6229 080a 6239 080a 6287 080a     Wb..)b..9b...b..
 80a8018:	6249 080a 6221 080a                         Ib..!b..

080a8020 <_ZTVN5spark9WiFiClassE>:
	...
 80a8028:	645f 080a 6455 080a 644b 080a 63bd 080a     _d..Ud..Kd...c..
 80a8038:	643f 080a 6433 080a 5ba1 080a 5ba9 080a     ?d..3d...[...[..
 80a8048:	6427 080a 641f 080a 6415 080a 640b 080a     'd...d...d...d..
 80a8058:	63c7 080a                                   .c..

080a805c <_ZSt7nothrow>:
 80a805c:	0000 0000 7173 7472 0066                    ....sqrtf.

080a8066 <_ctype_>:
 80a8066:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
 80a8076:	2020 2020 2020 2020 2020 2020 2020 2020                     
 80a8086:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
 80a8096:	0410 0404 0404 0404 0404 1004 1010 1010     ................
 80a80a6:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
 80a80b6:	0101 0101 0101 0101 0101 0101 1010 1010     ................
 80a80c6:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
 80a80d6:	0202 0202 0202 0202 0202 0202 1010 1010     ................
 80a80e6:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

080a8167 <link_const_variable_data_end>:
	...

080a8168 <link_constructors_location>:
 80a8168:	080a10cd 	.word	0x080a10cd
 80a816c:	080a3f4d 	.word	0x080a3f4d
 80a8170:	080a5835 	.word	0x080a5835
 80a8174:	080a5c29 	.word	0x080a5c29
 80a8178:	080a5d2d 	.word	0x080a5d2d
 80a817c:	080a60e9 	.word	0x080a60e9
 80a8180:	080a610d 	.word	0x080a610d
 80a8184:	080a6469 	.word	0x080a6469
 80a8188:	080a6835 	.word	0x080a6835

080a818c <link_constructors_end>:
 80a818c:	00000000 	.word	0x00000000
